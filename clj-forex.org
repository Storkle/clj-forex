#+TITLE: CLJ-FOREX
#+Author: Seth Burleigh
#+Babel: :comments link :noweb yes :mkdirp yes
             
* Introduction
** What is forex?
Forex is a currency trading market. But you probably know all about forex, since you're here! If not, read up on it! \\
+ [[http://en.wikipedia.org/wiki/Foreign_exchange_market][Wiki article - OK]]
+ [[http://www.fxcm.com/metatrader.jsp][FXCM Retail Broker Free Metatarder Terminal -  get demo account and see what forex trading is first hand!]]
** What is clj-forex?
Clj-forex is an in progress effort to create a non-graphical backend to various forex trading backends. Right now Metatrader is the focus. 
The ultimate goal of clj-forex is to create a robust library to allow the creation of EA (expert advisors) in the scripting language clojure. Expert advisors
are programs which automatically trade the market, performing sell/buy orderes, changing stoplosses, using technical indicators, etc. They are useful for
both automating parts of manual trading systems (performing trailing stops, expiration of market orders) and also for full out automated trading.

Indicators will be calculated java side using price bars retrieved from the backends. Integration of indicator data to various gui backends (i.e. at this time,
Metatrader) will be supported. The only purpose of the forex backend is to allow access to spreads, current price, ability to buy/sell, etc. 
** The Difference
Im not sure why noone has done this before, but integration of a scripting language to create eas is, in my opinion, vital. 
Integration of a lisp-like dialect, like clojure, will allow much more rapid creation and prototyping of eas. 
This combined with easy access to any java library (clojure is implemented on the java virtual machine) makes for a winning combination! 
Things like neural networks, database, and other such ‘advanced’ concepts can now be much more easily integrated than if we had used [[http://book.mql4.com/][mql4]].

Its like an artist! Give an artist more efficient tools in the toolbox and who knows what can be created! [And clojure is fun to learn anyways!]
** Where's the code??
This file is the code (clojure, anyways). The code is untangled using the
keystroke C-c C-v t in emacs when this file is open. While currently most
of the code is simply in the Code section, it will all eventually be explained
in the [[http://groups.google.com/group/clojure/browse_thread/thread/664a1d305f32ab90][literate programming]] manner.
* Development Tools
org-mode in emacs + babel is used. Currently code is one ns per one code block
format. Therefore, i use the below code, along with the latest git repository
for org-mode (needed!). I then hit f8 to detangle all my changes to my org file.
f9 can be used to jump from source code to location in org file. 
#+begin_src emacs-lisp
  
  (defvar clj-forex-file "/home/seth/Dropbox/.rep/clj-forex/clj-forex.org")
  
  
  (defmacro with-file (file &rest body)
    "open up file in a buffer, and set current buffer to it"
    `(with-current-buffer (find-file-noselect ,file t) ,@body))
  
  (defun out-files (org-file)
    (let (args)
      (org-babel-map-src-blocks org-file
        (let ((tangle-file (with-temp-buffer
                             (insert header-args)
                             (goto-char (point-min))
                             (if (re-search-forward ":tangle[ ]+\\([^ ]+\\)" nil t)
                                 (match-string 1)
                               nil))))
          (when tangle-file (push tangle-file args))))
      args))
  
  (defmacro with-cd (dir &rest body)
    (let ((current (gensym)))
      `(let ((,current default-directory))
         (cd ,dir)
         (unwind-protect (progn ,@body) (cd default-directory)))))
  
  ;;TODO rever buffers when detangle/tangle?
  (defun detangle ()
    (interactive)
    (save-excursion
      (let* ((org-file clj-forex-file)
             (out (out-files org-file))
             (amount 0)) 
        (with-cd (file-name-directory org-file)
                 (dolist (file out)
                   (with-file
                    file
                    (goto-char (truncate (/ (+ (point-min) (point-max)) 2)))
                    (let ((detangled (org-babel-detangle)))
                      (if (= detangled 0) (progn (message "failed on %s" file)
                                                 (sleep-for 2)))
                      (incf amount detangled)))))
        (message "Detangled %s source blocks/ %s" amount (length out)))))
  (global-set-key (kbd "<f8>") 'detangle)
  (global-set-key (kbd "<f9>") 'org-babel-tangle-jump-to-org)
  (setq org-src-fontify-natively t)
#+end_src

Given the tangled output of the source files, which basically tags the
code so that it can detangle it and jump back to the org file, we can
technically work in something other than emacs if we have a clojure tool
to detangle and tangle. However, this is not yet implemented. Also, it is planned
to give noweb support for babel so that i can break up the blocks.

Yes, currently it is not very development start friendly. That will change!
* From Ideas to Implementation - Metatrader Backend
* Code 
** Project
#+srcname:project
#+begin_src clojure :tangle project.clj
  (defproject clj-forex "0.1-SNAPSHOT"
    :description "non graphical library for automated trading for forex market with various backends like metatrader"
    :dependencies [[org.clojure/clojure "1.2.0"]
		   [org.clojure/clojure-contrib "1.2.0"]           
		   [matchure "0.10.0"]
		   [clj-time "0.2.0-SNAPSHOT"]
		   [mmemail "1.0.1"] 
		   [nstools "0.2.4"]
		   [com.miglayout/miglayout "3.7.4"]
		   [commons-codec "1.4"]]   
    :dev-dependencies [[native-deps "1.0.5"]
		       [swank-clojure "1.3.0-SNAPSHOT"]]  
    :native-dependencies [[org.clojars.starry/jzmq-native-deps "2.0.10.3"]]
    :main forex.interface.main
    :repositories {"miglayout" "http://www.miglayout.com/mavensite/"} 
   ;; :run-aliases {:izpack forex.dev.install} 
    ;; :jvm-opts      ["-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8030"]
    ;;:aot :all
    )
#+end_src 
    
** Util 
*** ThirdParty
#+source:defrecord2
#+begin_src clojure :tangle src/clj/third_party/defrecord2.clj
  ;;BY David McNeil
  ;;https://github.com/david-mcneil/defrecord2
  ;;modified defrecord2 macro so i could include protocols
  ;;got rid of print-method and pprint method 

  (ns clj.third-party.defrecord2
    (:require [clojure.contrib.str-utils2 :as str2])
    (:use [clojure.contrib.core :only (seqable?)]
	  [clojure.set :only (difference)]
	  [clojure.string :only (join)]
	  [clojure.contrib.pprint :only (*simple-dispatch* use-method pprint-map)])
    (:import [clojure.lang IPersistentList IPersistentVector IPersistentMap ISeq]))

  ;;;; enhanced records with constructor support (take in a hashmap) and print-dup support

  ;; internal helpers for name conversion

  (defn- take-even [x]
    (take-nth 2 x))

  (defn- take-odd [x]
    (take-nth 2 (drop 1 x)))

  (defn- is-upper? [s]
    (= (.toUpperCase s) s))

  (defn- assemble-words [parts]
    (loop [remaining-parts parts result []]
      (if (seq remaining-parts)
	(let [part (first remaining-parts)]
	  (recur (rest remaining-parts)
		 (if (is-upper? part)
		   (conj result (.toLowerCase part))
		   (conj (if (seq result)
			   (pop result)
			   []) (str (last result) part)))))
	result)))

  (defn- camel-to-dashed
    "Convert a name like 'BigBlueCar' to 'big-blue-car'."
    [s]
    (let [parts (remove #(= "" %) (str2/partition s #"[A-Z]"))
	  words (assemble-words parts)]
      (join "-" words)))

  ;; internal helpers for changing records via maps 

  (defn set-record-field
    "Set a single field on a record."
    [source [key value]]
    (assoc source key value))

  (defn set-record-fields
    "Set many fields on a record, from a map."
    [initial value-map]
    (reduce set-record-field initial value-map))

  ;; internal helper for generating constructor function

  (defn expected-keys? [map expected-key-set]
    (not (seq (difference (set (keys map)) expected-key-set))))

  (defmacro make-record-constructor
    "Define the constructor functions used to instantiate a record."
    [ctor-name type-name field-list default-record]
    `(defn ~ctor-name
       ([value-map#]
	  (~ctor-name ~default-record value-map#))
       ([initial# value-map#]
	  {:pre [(or (nil? initial#)
		     (isa? (class initial#) ~type-name))
		 (map? value-map#)
		 (expected-keys? value-map# ~(set (map keyword field-list)))]}
	  (set-record-fields (if (nil? initial#) ~default-record initial#) value-map#)))) 

  ;; internal helpers for printing

  (defn remove-nil-native-fields [native-keys record]
    (let [extra-keys (difference (set (keys record))
				 native-keys)]
      (apply array-map (reduce into (for [[k v] record]
				      (if (or (contains? extra-keys k)
					      (not (nil? v)))
					[k v]))))))

  (defn- ns-resolve-symbol [s]
    (if-let [s (resolve s)]
      (.substring (str s) 2)
      (str s)))

  (defmacro print-record
    "Low-level function to print a record to a stream using the specified constructor name in the print output and using the provided write-contents function to write out the contents of the record (represented as a map)."
    [ctor ctor-name native-keys record stream write-contents]
    `(do 
       (.write ~stream (str "#=(" ~(ns-resolve-symbol ctor-name) " "))
       (~write-contents (remove-nil-native-fields ~native-keys ~record))
       (.write ~stream  ")")))

  (defn print-record-contents
    "Simply write the contents of a record to a stream as a string. Used for basic printing."
    [stream contents]
    (.write stream (str contents)))

  (defmacro setup-print-record-method [ctor ctor-name native-keys type-name method-name]
    `(defmethod ~method-name ~type-name [record# writer#]
       (print-record ~ctor ~ctor-name ~native-keys record# writer# (partial print-record-contents writer#))))

  (defmacro setup-print-record
    "Define the print methods to print a record nicely (so that records will print in a form that can be evaluated as itself)."
    [ctor ctor-name native-keys type-name]

    `(do ;(setup-print-record-method ~ctor ~ctor-name ~native-keys ~type-name print-method)
       (setup-print-record-method ~ctor ~ctor-name ~native-keys ~type-name print-dup)))

  (defmacro generate-record-pprint
    "Return a function that can be used in the pprint dispatch mechanism to handle a specific constructor name."
    [ctor ctor-name native-keys]
    `(fn [record#]
       (print-record ~ctor ~ctor-name ~native-keys record# *out* pprint-map)))

  ;; internal helpers - walking data structures

  ;; w - walker function
  ;; f - mutator function
  ;; n - node in data tree being walked

  ;; helper - generating walking methods like this:
  (comment (defmethod prewalk2 Foo [f foo]
	     (if-let [foo2 (f foo)]
	       (new-foo foo2 {:a (prewalk2 f (:a foo2))
			      :b (prewalk2 f (:b foo2))})))

	   (defmethod postwalk2 Foo [f foo]
	     (f (new-foo foo {:a (postwalk2 f (:a foo))
			      :b (postwalk2 f (:b foo))}))))

  (defmulti walk2 (fn [w f n] (class n)))

  (defmethod walk2 :default [w f n]
    n)

  ;; TODO: handle sets

  (defmethod walk2 IPersistentVector [w f n]
    (apply vector (map (partial w f) n)))

  (defmethod walk2 IPersistentMap [w f n]
    ;; TODO: handle sorted maps
    (apply array-map (mapcat (partial walk2 w f) n)))

  (defmethod walk2 IPersistentList [w f n]
    (apply list (map (partial w f) n)))

  (prefer-method walk2 IPersistentList ISeq)

  (defmethod walk2 ISeq [w f n]
    (map (partial w f) n))

  (defmacro walking-helper-field
    ([w f n field]
       `[~(keyword field) (~w ~f (~(keyword field) ~n))])
    ([w f n field & more]
       `(concat (walking-helper-field ~w ~f ~n ~field) (walking-helper-field ~w ~f ~n ~@more))))

  (defmacro walking-helper-fields
    [w f n fields]
    `(apply array-map (walking-helper-field ~w ~f ~n ~@fields)))

  (defmacro make-prewalk2-method
    "Define the methods used to walk data structures."
    [ctor-name type-name field-list]
    `(defmethod prewalk2 ~type-name [f# n#]
       (if-let [n2# (f# n#)]
	 (~ctor-name n2# (walking-helper-fields prewalk2 f# n2# ~field-list)))))

  (defmacro make-postwalk2-method
    "Define the methods used to walk data structures."
    [ctor-name type-name field-list]
    `(defmethod postwalk2 ~type-name [f# n#]
       (f# (~ctor-name n# (walking-helper-fields postwalk2 f# n# ~field-list)))))

  ;; public entry points

  (defmulti prewalk2 (fn [f n] (class n)))

  (defmethod prewalk2 :default [f n]
    (walk2 prewalk2 f (f n)))

  (defmulti postwalk2 (fn [f n] (class n)))

  (defmethod postwalk2 :default [f n]
    (f (walk2 postwalk2 f n)))

  (defmacro defrecord2
    "Defines a record and sets up constructor functions, printing, and pprinting for the new record type."
    [type field-list & protocols]
    (let [type-name (if (seqable? type) (first type) type)
	  ctor-name (if (seqable? type)
		      (second type)
		      (symbol (str "new-" (camel-to-dashed (str type)))))]
      `(do 
	 ;; define the record
	 (defrecord ~type-name ~field-list ~@protocols)
	 ;; define the constructor functions
	 (make-record-constructor ~ctor-name
				  ~type-name
				  ~field-list
				  (~(symbol (str type-name ".")) ~@(repeat (count field-list) nil)))
	 ;; setup tree walking methods
	 (make-prewalk2-method ~ctor-name ~type-name ~field-list)
	 (make-postwalk2-method ~ctor-name ~type-name ~field-list)

	 ;; setup printing
	 (let [empty-record# (~ctor-name {})
	       native-keys# (set (keys empty-record#))]
	   (setup-print-record ~ctor-name ~ctor-name native-keys# ~type-name)
	   ;; setup pprinting
	   (comment
	     (use-method *simple-dispatch*
			 ~type-name

			 (generate-record-pprint ~ctor-name
						 ~ctor-name
						 native-keys#)))))))
#+end_src

*** CLJ
#+source:clj-core
#+begin_src clojure :tangle src/clj/core.clj
  (ns clj.core
    (:refer-clojure :exclude [promise swap! reset! defrecord spit file])
    (:require clj.third-party.defrecord2)
    (:import clojure.lang.APersistentMap java.io.Writer))
  (defmacro defrecord [name fields & protocols]
    `(clj.third-party.defrecord2/defrecord2 ~name ~fields ~@protocols))

  ;;TODO: serializable records and atoms and refs 
  (defmulti swap! (fn [a & args] (class a)))
  (defmethod swap! clojure.lang.Atom [& args]
    (apply clojure.core/swap! args))
  (defmulti reset! (fn [a & args] (class a)))
  (defmethod reset! clojure.lang.Atom [& args]
    (apply clojure.core/reset! args))
  (defprotocol PWait 
    (wait-for [this timeout units] [this timeout]))
  ;;copied from clojure source, but adding timeout wait-for
  (defn promise
    "Alpha - subject to change.
    Returns a promise object that can be read with deref/@, and set,
    once only, with deliver. Calls to deref/@ prior to delivery will
    block. All subsequent derefs will return the same delivered value
    without blocking."
    {:added "1.1"}
    []
    (let [d (java.util.concurrent.CountDownLatch. 1)
	  v (atom nil)]
      (reify 
	clojure.lang.IDeref
	(deref [_] (.await d) @v)
	PWait
	(wait-for [this timeout]
		  (wait-for this timeout
			    java.util.concurrent.TimeUnit/MILLISECONDS))
	(wait-for [this timeout units]
		  (if timeout
		    (.await d timeout units)
		    (do (.await d) true)))
	clojure.lang.IFn
	(invoke [this x] 
		(locking d
		  (if (pos? (.getCount d))
		    (do (reset! v x)
			(.countDown d)
			x)
		    (throw
		     (IllegalStateException.
		      "Multiple deliver calls to a promise"))))))))

  (defmethod print-dup clojure.lang.Atom [o w]
    (.write w "#=(clojure.core/atom ") (print-dup @o w) (.write w ")"))
  (defmethod print-dup clojure.lang.Ref [o w]
    (.write w "#=(clojure.core/ref ") (print-dup @o w) (.write w ")"))
#+end_src

#+source:clj-io
#+begin_src clojure :tangle src/clj/io.clj
  ;;; duck_streams.clj -- duck-typed I/O streams for Clojure

  ;; by Stuart Sierra, http://stuartsierra.com/
  ;; May 13, 2009

  ;; Copyright (c) Stuart Sierra, 2009. All rights reserved.  The use
  ;; and distribution terms for this software are covered by the Eclipse
  ;; Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
  ;; which can be found in the file epl-v10.html at the root of this
  ;; distribution.  By using this software in any fashion, you are
  ;; agreeing to be bound by the terms of this license.  You must not
  ;; remove this notice, or any other, from this software.


  ;; This file defines "duck-typed" I/O utility functions for Clojure.
  ;; The 'reader' and 'writer' functions will open and return an
  ;; instance of java.io.BufferedReader and java.io.BufferedWriter,
  ;; respectively, for a variety of argument types -- filenames as
  ;; strings, URLs, java.io.File's, etc.  'reader' even works on http
  ;; URLs.
  ;;
  ;; Note: this is not really "duck typing" as implemented in languages
  ;; like Ruby.  A better name would have been "do-what-I-mean-streams"
  ;; or "just-give-me-a-stream", but ducks are funnier.


  ;; CHANGE LOG
  ;;
  ;; May 13, 2009: added functions to open writers for appending
  ;;
  ;; May 3, 2009: renamed file to file-str, for compatibility with
  ;; clojure.contrib.java.  reader/writer no longer use this
  ;; function.
  ;;
  ;; February 16, 2009: (lazy branch) fixed read-lines to work with lazy
  ;; Clojure.
  ;;
  ;; January 10, 2009: added *default-encoding*, so streams are always
  ;; opened as UTF-8.
  ;;
  ;; December 19, 2008: rewrote reader and writer as multimethods; added
  ;; slurp*, file, and read-lines
  ;;
  ;; April 8, 2008: first version



  (ns
   #^{:author "Stuart Sierra",
      :doc "This file defines polymorphic I/O utility functions for Clojure.

	     The Streams protocol defines reader, writer, input-stream and
	     output-stream methods that return BufferedReader, BufferedWriter,
	     BufferedInputStream and BufferedOutputStream instances (respectively),
	     with default implementations extended to a variety of argument
	     types: URLs or filenames as strings, java.io.File's, Sockets, etc."}
   clj.io
   (:refer-clojure :exclude (spit))
   (:import 
    (java.io Reader InputStream InputStreamReader PushbackReader
	     BufferedReader File OutputStream
	     OutputStreamWriter BufferedWriter Writer
	     FileInputStream FileOutputStream ByteArrayOutputStream
	     StringReader ByteArrayInputStream
	     BufferedInputStream BufferedOutputStream
	     CharArrayReader)
    (java.net URI URL MalformedURLException Socket)))

  (defmulti #^File ^{:private true} as-file 
    "Interpret a String or a java.io.File as a File. Building block
     for clojure.contrib.java/file, which you should prefer
     in most cases."
    class)
  (defmethod ^{:private true} as-file String [#^String s] (File. s))
  (defmethod ^{:private true} as-file File [f] f)


  (def
   #^{:doc "Name of the default encoding to use when reading & writing.
    Default is UTF-8."
      :tag "java.lang.String"}
   *default-encoding* "UTF-8")

  (def
   #^{:doc "Size, in bytes or characters, of the buffer used when
    copying streams."}
   *buffer-size* 1024)

  (def
   #^{:doc "Type object for a Java primitive byte array."}
   *byte-array-type* (class (make-array Byte/TYPE 0)))

  (def
   #^{:doc "Type object for a Java primitive char array."}
   *char-array-type* (class (make-array Character/TYPE 0)))


  (defn #^File file-str
    "Concatenates args as strings and returns a java.io.File.  Replaces
    all / and \\ with File/separatorChar.  Replaces ~ at the start of
    the path with the user.home system property."
    [& args]
    (let [#^String s (apply str args)
	  s (.replace s \\ File/separatorChar)
	  s (.replace s \/ File/separatorChar)
	  s (if (.startsWith s "~")
	      (str (System/getProperty "user.home")
		   File/separator (subs s 1))
	      s)]
      (File. s)))

  (def
   #^{:doc "If true, writer, output-stream and spit will open files in append mode.
	    Defaults to false.  Instead of binding this var directly, use append-writer,
	    append-output-stream or append-spit."
      :tag "java.lang.Boolean"}
   *append* false)

  (defn- assert-not-appending []
    (when *append*
      (throw (Exception. "Cannot change an open stream to append mode."))))

  ;; @todo -- Both simple and elaborate methods for controlling buffering of
  ;; in the Streams protocol were implemented, considered, and postponed
  ;; see http://groups.google.com/group/clojure-dev/browse_frm/thread/3e39e9b3982f542b
  (defprotocol Streams
    (reader [x]
      "Attempts to coerce its argument into an open java.io.Reader.
       The default implementations of this protocol always return a
       java.io.BufferedReader.

       Default implementations are provided for Reader, BufferedReader,
       InputStream, File, URI, URL, Socket, byte arrays, character arrays,
       and String.

       If argument is a String, it tries to resolve it first as a URI, then
       as a local file name.  URIs with a 'file' protocol are converted to
       local file names.  If this fails, a final attempt is made to resolve
       the string as a resource on the CLASSPATH.

       Uses *default-encoding* as the text encoding.

       Should be used inside with-open to ensure the Reader is properly
       closed.")
    (writer [x]
      "Attempts to coerce its argument into an open java.io.Writer.
       The default implementations of this protocol always return a
       java.io.BufferedWriter.

       Default implementations are provided for Writer, BufferedWriter,
       OutputStream, File, URI, URL, Socket, and String.

       If the argument is a String, it tries to resolve it first as a URI, then
       as a local file name.  URIs with a 'file' protocol are converted to
       local file names.

       Should be used inside with-open to ensure the Writer is properly
       closed.")
    (input-stream [x]
      "Attempts to coerce its argument into an open java.io.InputStream.
       The default implementations of this protocol always return a
       java.io.BufferedInputStream.

       Default implementations are defined for OutputStream, File, URI, URL,
       Socket, byte array, and String arguments.

       If the argument is a String, it tries to resolve it first as a URI, then
       as a local file name.  URIs with a 'file' protocol are converted to
       local file names.

       Should be used inside with-open to ensure the InputStream is properly
       closed.")
    (output-stream [x]
      "Attempts to coerce its argument into an open java.io.OutputStream.
       The default implementations of this protocol always return a
       java.io.BufferedOutputStream.

       Default implementations are defined for OutputStream, File, URI, URL,
       Socket, and String arguments.

       If the argument is a String, it tries to resolve it first as a URI, then
       as a local file name.  URIs with a 'file' protocol are converted to
       local file names.

       Should be used inside with-open to ensure the OutputStream is
       properly closed."))

  (def default-streams-impl
    {:reader #(reader (input-stream %))
     :writer #(writer (output-stream %))
     :input-stream #(throw (Exception. (str "Cannot open <" (pr-str %) "> as an InputStream.")))
     :output-stream #(throw (Exception. (str "Cannot open <" (pr-str %) "> as an OutputStream.")))})

  (extend File
    Streams
    (assoc default-streams-impl
      :input-stream #(input-stream (FileInputStream. #^File %))
      :output-stream #(let [stream (FileOutputStream. #^File % *append*)]
			(binding [*append* false]
			  (output-stream stream)))))
  (extend URL
    Streams
    (assoc default-streams-impl
      :input-stream (fn [#^URL x]
		      (input-stream (if (= "file" (.getProtocol x))
				      (FileInputStream. (.getPath x))
				      (.openStream x))))
      :output-stream (fn [#^URL x]
		       (if (= "file" (.getProtocol x))
			 (output-stream (File. (.getPath x)))
			 (throw (Exception. (str "Can not write to non-file URL <" x ">")))))))
  (extend URI
    Streams
    (assoc default-streams-impl
      :input-stream #(input-stream (.toURL #^URI %))
      :output-stream #(output-stream (.toURL #^URI %))))
  (extend String
    Streams
    (assoc default-streams-impl
      :input-stream #(try
		       (input-stream (URL. %))
		       (catch MalformedURLException e
			 (input-stream (File. #^String %))))
      :output-stream #(try
			(output-stream (URL. %))
			(catch MalformedURLException err
			  (output-stream (File. #^String %))))))
  (extend Socket
    Streams
    (assoc default-streams-impl
      :input-stream #(.getInputStream #^Socket %)
      :output-stream #(output-stream (.getOutputStream #^Socket %))))
  (extend *byte-array-type*
    Streams
    (assoc default-streams-impl :input-stream #(input-stream (ByteArrayInputStream. %))))
  (extend *char-array-type*
    Streams
    (assoc default-streams-impl :reader #(reader (CharArrayReader. %))))
  (extend Object
    Streams
    default-streams-impl)

  (extend Reader
    Streams
    (assoc default-streams-impl :reader #(BufferedReader. %)))
  (extend BufferedReader
    Streams
    (assoc default-streams-impl :reader identity))
  (defn- inputstream->reader
    [#^InputStream is]
    (reader (InputStreamReader. is *default-encoding*)))
  (extend InputStream
    Streams
    (assoc default-streams-impl :input-stream #(BufferedInputStream. %)
      :reader inputstream->reader))
  (extend BufferedInputStream
    Streams
    (assoc default-streams-impl
      :input-stream identity
      :reader inputstream->reader))

  (extend Writer
    Streams
    (assoc default-streams-impl :writer #(do (assert-not-appending)
					     (BufferedWriter. %))))
  (extend BufferedWriter
    Streams
    (assoc default-streams-impl :writer #(do (assert-not-appending) %)))
  (defn- outputstream->writer
    [#^OutputStream os]
    (assert-not-appending)
    (writer (OutputStreamWriter. os *default-encoding*)))
  (extend OutputStream
    Streams
    (assoc default-streams-impl
      :output-stream #(do (assert-not-appending)
			  (BufferedOutputStream. %))
      :writer outputstream->writer))
  (extend BufferedOutputStream
    Streams
    (assoc default-streams-impl
      :output-stream #(do (assert-not-appending) %)
	:writer outputstream->writer))

  (defn append-output-stream
    "Like output-stream but opens file for appending.  Does not work on streams
    that are already open."
    [x]
    (binding [*append* true]
      (output-stream x)))

  (defn append-writer
    "Like writer but opens file for appending.  Does not work on streams
    that are already open."
    [x]
    (binding [*append* true]
      (writer x)))

  (defn write-lines
    "Writes lines (a seq) to f, separated by newlines.  f is opened with
    writer, and automatically closed at the end of the sequence."
    [f lines]
    (with-open [#^BufferedWriter writer (writer f)]
      (loop [lines lines]
	(when-let [line (first lines)]
	  (.write writer (str line))
	  (.newLine writer)
	  (recur (rest lines))))))

  (defn read-lines
    "Like clojure.core/line-seq but opens f with reader.  Automatically
    closes the reader AFTER YOU CONSUME THE ENTIRE SEQUENCE."
    [f]
    (let [read-line (fn this [#^BufferedReader rdr]
		      (lazy-seq
		       (if-let [line (.readLine rdr)]
			 (cons line (this rdr))
			 (.close rdr))))]
      (read-line (reader f))))

  (defn #^String slurp*
    "Like clojure.core/slurp but opens f with reader."
    [f]
    (with-open [#^BufferedReader r (reader f)]
	(let [sb (StringBuilder.)]
	  (loop [c (.read r)]
	    (if (neg? c)
	      (str sb)
	      (do (.append sb (char c))
		  (recur (.read r))))))))

  (defn spit
    "Opposite of slurp.  Opens f with writer, writes content, then
    closes f."
    [f content]
    (with-open [#^Writer w (writer f)]
      (.write w content)))

  (defn append-spit
    "Like spit but appends to file."
    [f content]
    (with-open [#^Writer w (append-writer f)]
      (.write w content)))

  (defn pwd
    "Returns current working directory as a String.  (Like UNIX 'pwd'.)
    Note: In Java, you cannot change the current working directory."
    []
    (System/getProperty "user.dir"))



  (defmacro with-out-writer
    "Opens a writer on f, binds it to *out*, and evalutes body.
    Anything printed within body will be written to f."
    [f & body]
    `(with-open [stream# (writer ~f)]
       (binding [*out* stream#]
	 ~@body)))

  (defmacro with-out-append-writer
    "Like with-out-writer but appends to file."
    [f & body]
    `(with-open [stream# (append-writer ~f)]
       (binding [*out* stream#]
	 ~@body)))

  (defmacro with-in-reader
    "Opens a PushbackReader on f, binds it to *in*, and evaluates body."
    [f & body]
    `(with-open [stream# (PushbackReader. (reader ~f))]
       (binding [*in* stream#]
	 ~@body)))

  (defmulti
    #^{:doc "Copies input to output.  Returns nil.
    Input may be an InputStream, Reader, File, byte[], or String.
    Output may be an OutputStream, Writer, or File.

    Does not close any streams except those it opens itself 
    (on a File).

    Writing a File fails if the parent directory does not exist."
       :arglists '([input output])}
    copy
    (fn [input output]
      [(if (string? input) File (type input))
       (if (string? output) File (type output))]))

  (defmethod copy [InputStream OutputStream] [#^InputStream input #^OutputStream output]
    (let [buffer (make-array Byte/TYPE *buffer-size*)]
      (loop []
	(let [size (.read input buffer)]
	  (when (pos? size)
	    (do (.write output buffer 0 size)
		(recur)))))))

  (defmethod copy [InputStream Writer] [#^InputStream input #^Writer output]
    (let [#^"[B" buffer (make-array Byte/TYPE *buffer-size*)]
      (loop []
	(let [size (.read input buffer)]
	  (when (pos? size)
	    (let [chars (.toCharArray (String. buffer 0 size *default-encoding*))]
	      (do (.write output chars)
		  (recur))))))))


  (defmethod copy [InputStream File] [#^InputStream input #^File output]
    (with-open [out (FileOutputStream. output)]
      (copy input out)))

  (defmethod copy [Reader OutputStream] [#^Reader input #^OutputStream output]
    (let [#^"[C" buffer (make-array Character/TYPE *buffer-size*)]
      (loop []
	(let [size (.read input buffer)]
	  (when (pos? size)
	    (let [bytes (.getBytes (String. buffer 0 size) *default-encoding*)]
	      (do (.write output bytes)
		  (recur))))))))

  (defmethod copy [Reader Writer] [#^Reader input #^Writer output]
    (let [#^"[C" buffer (make-array Character/TYPE *buffer-size*)]
      (loop []
	(let [size (.read input buffer)]
	  (when (pos? size)
	    (do (.write output buffer 0 size)
		(recur)))))))

  (defmethod copy [Reader File] [#^Reader input #^File output]
    (with-open [out (FileOutputStream. output)]
      (copy input out)))

  (defmethod copy [File OutputStream] [#^File input #^OutputStream output]
    (with-open [in (FileInputStream. input)]
      (copy in output)))

  (defmethod copy [File Writer] [#^File input #^Writer output]
    (with-open [in (FileInputStream. input)]
      (copy in output)))

  (defmethod copy [File File] [input output]
    (with-open [in (FileInputStream. (as-file input))
		out (FileOutputStream. (as-file output))]
      (copy in out)))

  (defmethod copy [String OutputStream] [#^String input #^OutputStream output]
    (copy (StringReader. input) output))

  (defmethod copy [String Writer] [#^String input #^Writer output]
    (copy (StringReader. input) output))

  (defmethod copy [String File] [#^String input #^File output]
    (copy (StringReader. input) output))

  (defmethod copy [*char-array-type* OutputStream] [input #^OutputStream output]
    (copy (CharArrayReader. input) output))

  (defmethod copy [*char-array-type* Writer] [input #^Writer output]
    (copy (CharArrayReader. input) output))

  (defmethod copy [*char-array-type* File] [input #^File output]
    (copy (CharArrayReader. input) output))

  (defmethod copy [*byte-array-type* OutputStream] [#^"[B" input #^OutputStream output]
    (copy (ByteArrayInputStream. input) output))

  (defmethod copy [*byte-array-type* Writer] [#^"[B" input #^Writer output]
    (copy (ByteArrayInputStream. input) output))

  (defmethod copy [*byte-array-type* File] [#^"[B" input #^Writer output]
    (copy (ByteArrayInputStream. input) output))


  (defmulti
    #^{:doc "Converts argument into a Java byte array.  Argument may be
    a String, File, InputStream, or Reader.  If the argument is already
    a byte array, returns it."
      :arglists '([arg])}
    to-byte-array type)

  (defmethod to-byte-array *byte-array-type* [x] x)

  (defmethod to-byte-array String [#^String x]
    (.getBytes x *default-encoding*))

  (defmethod to-byte-array File [#^File x]
    (with-open [input (FileInputStream. x)
		buffer (ByteArrayOutputStream.)]
      (copy input buffer)
      (.toByteArray buffer)))

  (defmethod to-byte-array InputStream [#^InputStream x]
    (let [buffer (ByteArrayOutputStream.)]
      (copy x buffer)
      (.toByteArray buffer)))

  (defmethod to-byte-array Reader [#^Reader x]
    (.getBytes (slurp* x) *default-encoding*))

  (defmulti relative-path-string 
    "Interpret a String or java.io.File as a relative path string. 
     Building block for clojure.contrib.java/file."
    class)

  (defmethod relative-path-string String [#^String s]
    (relative-path-string (File. s)))

  (defmethod relative-path-string File [#^File f]
    (if (.isAbsolute f)
      (throw (IllegalArgumentException. (str f " is not a relative path")))
      (.getPath f)))


  (defn #^File file
    "Returns a java.io.File from string or file args."
    ([arg]                      
       (as-file arg))
    ([parent child]             
       (File. #^File (as-file parent) #^String (relative-path-string child)))
    ([parent child & more]
       (reduce file (file parent child) more)))

  (defn delete-file
    "Delete file f. Raise an exception if it fails unless silently is true."
    [f & [silently]]
    (or (.delete (file f))
	silently
	(throw (java.io.IOException. (str "Couldn't delete " f)))))

  (defn delete-file-recursively
    "Delete file f. If it's a directory, recursively delete all its contents.
  Raise an exception if any deletion fails unless silently is true."
    [f & [silently]]
    (let [f (file f)]
      (if (.isDirectory f)
	(doseq [child (.listFiles f)]
	  (delete-file-recursively child silently)))
      (delete-file f silently)))

  (defmulti
    #^{:doc "Coerces argument (URL, URI, or String) to a java.net.URL."
       :arglists '([arg])}
    as-url type)

  (defmethod as-url URL [x] x)

  (defmethod as-url URI [#^URI x] (.toURL x))

  (defmethod as-url String [#^String x] (URL. x))

  (defmethod as-url File [#^File x] (.toURL x))



  (defn make-parents
    "Creates all parent directories of file."
    [file]
    (.mkdirs (.getParentFile (as-file file))))


  (defn copy-dir [source target]
    (let [source (as-file source) target (as-file target)]
      (make-parents target)
      (loop [source source target target]
	(if (.isDirectory source)
	  (do (if (not (.exists target)) (.mkdir target))
	      (doseq [child (.list source)]             
		(copy-dir (file source child) (file target child))))
	  (if (.exists source) (copy source target))))))

  (defn file-type [f]
    (if (.isFile f)
      (let [a (.split (.getName f) "\\.")]
	(if (> (count a) 1)
	  (last a)
	  ""))
      ""))

  (defn list-files [source]
    (let [source (as-file source)
	  files (.listFiles source)]
      (lazy-seq
       (if (empty? files)
	 nil
	 (apply concat (vec files) (map list-files (filter #(.isDirectory %) files)))))))

  ;;(count (filter #(= (file-type %) "clj") (list-files "/home/seth/Dropbox/.rep/clj-forex/")))
#+end_src

*** Core
#+srcname:forex-util-core
#+begin_src clojure :tangle src/forex/util/core.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.core
    (:clone clj.core)
    (:use forex.util.emacs forex.util.general forex.util.spawn forex.util.log)
    (:require clojure.contrib.error-kit clojure.contrib.pprint)
    (:import java.io.File (org.joda.time DateTime DateTimeZone Instant)))

  (defonce *debug* true)
  (defn debug [msg & args]
    (when *debug* (apply out (str "DEBUG: " msg) args)))
  ;;TODO: we need a combination of saving using byte straems and saving as clojure! that way clojure stuff is compatible with later stuff 

  (defn- make-exception [a] (Exception. a))
  (defmethod print-dup Exception [o w]
    (.write w (str "#=(forex.util.core/make-exception \"" (.getMessage o) "\")")))

  ;;TODO: memoize pow?
  ;;used from http://groups.google.com/group/clojure/browse_thread/thread/cb5246d07142a3dc?fwc=2&pli=1
  (defn frm-save 
   "Save a clojure form to file." 
    [file form] 
    (with-open [w (java.io.FileWriter.
		   (if (instance? File file) file (File. file)))] 
      (binding [*out* w *print-dup* true] (prn form))))

  (defn frm-load 
    "Load a clojure form from file." 
    [file] 
    (with-open [r (java.io.PushbackReader. 
       (java.io.FileReader. (if (instance? File file) file (File. file))))] 
       (let [rec (read r)] 
	 rec)))

  (defn round [num places]
    (let [multiplier (Math/pow 10 places)]
      (/ (int (* num multiplier)) multiplier)))
  (defn ns? [a] (instance? clojure.lang.Namespace a))
  (defn decimal-places [num]
    (let [^String s (reverse (second (.split (str (double num)) "\\.")))
	  c (count s)]
      (loop [c (nth s 0) i 0]
	(cond
	 (or (= i c) (not (= c \0)))
	 (- (count s) i)
	 true
	 (recur (nth s (inc i)) (inc i))))))

  (defn ns-symbol
    ([symbol] (ns-symbol symbol *ns*))
    ([symbol ns] (ns-symbol symbol ns nil))
    ([symbol ns default]
       (let [var ((ns-interns ns) symbol)]
	 (if (and (var? var) (var-get var)) var default))))

  (deftype AtomHash [val]
    Object
    (toString [this] (str "<AtomHash " @val ">"))
    clojure.lang.IPersistentMap
    ;;ILookup
    (valAt [this key] (get @val key))
    (valAt [this key notfound] (get @val key notfound))
    ;;IPersistentCollection
    (count [this] (.count @val))
    (empty [this]  {}) 
    (cons [this e]  (.cons @val e))
    (equiv [this gs] (or (identical? this gs)
			 (when (identical? (class this) (class gs))
			   (= val (.val gs)))))
    (containsKey [this k] (or (and (get @val k) true) false))
    (entryAt [this k] (get @val k))
    ;;Seqable
    (seq [this] (seq @val))
    ;;Associative 
    (assoc [this k g] (assoc @val k g))
    (assocEx [this k g] (assoc this k g))
    (without [this k] (.without @val k))
    clojure.lang.IDeref
    (deref [this] @val))
  ;;todo - create ns-resolve-symbol, instead of hardcoding namespace
  ;;TODO: add pprint
  (defmethod print-dup AtomHash [o w]
    (.write w "#=(forex.util.core/atom-hash ") (print-dup @o w) (.write w ")"))

  (defmethod clojure.core/print-method AtomHash [o w]
    (.write w (.toString o)))
  ;;TODO: make into protocol method! not multimethod!
  (defmethod swap!  forex.util.core.AtomHash [a & args]
    (apply swap! (.val a) args))
  (defmethod reset!  forex.util.core.AtomHash [a & args]
    (apply reset! (.val a) args))

  (defn atom-hash
    ([] (atom-hash {}))
    ([val]
       (let [val (if (nil? val) {} val)]
	(is (map? val))
	(AtomHash. (atom val)))))

  (defn symbolicate
    "symbolicate symbols together. ignores things like whitespaces, just drops them!"
    [& args]
    (symbol (apply str args)))

  (defmacro naive-var-local-cache-strategy [var] 
   `(let [cache# (atom {})]
      (reify PCachingStrategy
	(retrieve [_ item#] (get @cache# item#))
	(cached? [_ item#] (contains? @cache# item#))
	(hit [this# _] this#)
	(miss [this# item# result#]
	      (reset! cache# (swap! ~var assoc item# result#))
	      this#))))

  (defmacro constants [& args]
    `(do ~@(map (fn [[name val]] `(def ~name ~val)) (group args 2))))

  (defmacro spawn-log [func name]
    `(spawn (fn [] (try (~func) (catch Exception e#
				  (.printStackTrace e#) (severe e#))))
	    ~name)) 

  (defonce *env* (atom {:period 240 :symbol "EURUSD"})) ;default +H4+, EURUSD
  (defn env
    ([] @*env*)
    ([key] (get @*env* key)))
  (defn env! [map] 
    (swap! *env* #(merge % map))
    map)

  (defmacro wenv [map & body] 
    `(binding [forex.util.core/*env*
	       (atom (merge @@~#'*env* ~map))]
       ~@body))

  ;;aliases for error kit
  (defn ns-export [from-ns]  
    (count (doall (map (fn [[sym var]]
			 (let [var-obj (if (.hasRoot var)
					 (intern *ns* sym (var-get var))
					 (intern *ns* sym))]
			   (when var-obj
			     (alter-meta! var-obj
					  (fn [old] (merge (meta var) old)))
			     var-obj)))
		       (ns-publics from-ns)))))

  (defmacro eval-when [& args]
    (eval `(do ~@args)) nil)

  (eval-when
   (require 'clojure.contrib.error-kit)
   (ns-export (find-ns 'clojure.contrib.error-kit)))

  (deferror *clj-forex-error* [] [message] 
    {:msg (str "clj-forex error: " message) 
     :unhandled (throw-msg Exception)})

  (defn throwf [msg & args] (raise *clj-forex-error* (apply format  msg args)))

  (defmacro is?
    [val & message]
    (if (vector? val)
      `(do ~@(map (fn [test] `(is? ~test ~@message)) val))
      `(let [result# ~val]
	 (if (not result#)
	   (throwf  ~(or (and (first message)
			      `(format ~@message))
			 (format "assertion %s failed"
				 (str val))))
	   result#))))
#+end_src 
*** General 
#+srcname:forex-util-general 
#+begin_src clojure :tangle src/forex/util/general.clj
  (ns forex.util.general 
    (:require  [clojure.contrib.str-utils2 :as s] clojure.string)
    (:import java.lang.management.ManagementFactory)
    (:require [matchure :as m]
	      [clojure.contrib.def :as d])
    (:use clojure.contrib.macro-utils))

  (defmacro with-out-str+
    "Evaluates exprs in a context in which *out* is bound to a fresh
    StringWriter.  Returns the string created by any nested printing
    calls."  {:added "1.0"} [arg & body]
    `(let [~arg (new java.io.StringWriter)]
       (binding [*out* ~arg]
	 ~@body)))

  (defn add-shutdown-hook [a]
    (try
      (.addShutdownHook (Runtime/getRuntime) a)
      true
      (catch Exception e false)))

  (defn dump-threads []
    (let [info (.dumpAllThreads (ManagementFactory/getThreadMXBean) false false)]
     (doall
      (map println info))
     (count info)))


  (defn seq1 [s]
    (reify clojure.lang.ISeq
      (first [_] (.first s))
      (more [_] (seq1 (.more s)))
      (next [_] (let [sn (.next s)] (and sn (seq1 sn))))
      (seq [_] (let [ss (.seq s)] (and ss (seq1 ss))))
      (count [_] (.count s))
      (cons [_ o] (.cons s o))
      (empty [_] (.empty s))
      (equiv [_ o] (.equiv s o))))
  (d/defalias defalias d/defalias)

  (defn upper? [s]
    (= (.toUpperCase s) s))

  (def join clojure.string/join)
  (def split s/split)
  (defn atom? [a] (or (symbol? a) (number? a)))

  ;;camel case - gotten from defrecord2 on github
  (defn- assemble-words [parts]
    (loop [remaining-parts parts result []]
      (if (seq remaining-parts)
	(let [part (first remaining-parts)]
	  (recur (rest remaining-parts)
		 (if (upper? part)
		   (conj result (.toLowerCase part))
		   (conj (if (seq result)
			   (pop result)
			   []) (str (last result) part)))))
	result)))



  (defn camel-to-dash
    "Convert a name like 'BigBlueCar' to 'big-blue-car'."
    [s]
    (let [parts (remove #(= "" %) (s/partition s #"[A-Z]"))
	  words (assemble-words parts)]
      (join "-" words)))
  ;;;

  (defn classpath []
    (seq (.getURLs (java.lang.ClassLoader/getSystemClassLoader))))

  (defn sequence? [a] (or (list? a) (vector? a) (seq? a)))
  (defn var-root-set [var val]
    (alter-var-root var (constantly val)))

  ;;copied from  
  (defprotocol PCachingStrategy
    "A caching strategy implements the backend for memoize. It handles the
    underlying cache and might define different strategies to remove old
    items from the cache."
    (retrieve [cache item] "Get the requested cache item.")
    (cached?  [cache item] "Checks whether the given argument list is cached.")
    (hit      [cache item] "Called in case of a cache hit.")
    (miss     [cache item result] "Called in case of a cache miss."))

  (declare naive-cache-strategy)

  (defn mem
    "Returns a memoized version of a referentially transparent function.
    The memoized version of the function keeps a cache of the mapping from
    arguments to results and, when calls with the same arguments are repeated
    often, has higher performance at the expense of higher memory use.
    Optionally takes a cache strategy. Default is the naive safe all strategy."
    ([f] (mem f (naive-cache-strategy)))
    ([f strategy]
     (let [cache-state (atom strategy)
	   hit-or-miss (fn [cache item]
			 (if (cached? cache item)
			   (hit cache item)
			   (miss cache item (delay (apply f item)))))]
       (fn [& args]
	 (let [cs (swap! cache-state hit-or-miss args)]
	   @(retrieve cs args))))))

  (deftype ^{:private true} NaiveStrategy [cache]
    PCachingStrategy
    (retrieve
      [_ item]
      (get cache item))
    (cached?
      [_ item]
      (contains? cache item))
    (hit
      [this _]
      this)
    (miss
      [_ item result]
      (NaiveStrategy. (assoc cache item result))))

  (defn- naive-cache-strategy
    "The naive safe-all cache strategy for memoize."
    []
    (NaiveStrategy. {}))  2



  ;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;

  (defmacro defonce-
    "Same as defonce but yields a private definition"
    ([name expr]
       (list `defonce (with-meta name (assoc (meta name) :private true)) expr))
    ([name expr doc]
       (list `defonce (with-meta name (assoc (meta name) :private true :doc doc)) expr)))
  (defmacro def-
    "Same as def but yields a private definition"
    [name & decls]
    (list* `def (with-meta name (assoc (meta name) :private true)) decls))
  (defmacro defmacro-
    "Same as defmacro but yields a private definition"
    [name & decls]
    (list* `defmacro (with-meta name (assoc (meta name) :private true)) decls))
  ;;WARNING: this can screw up protocols implemented on existing object - i.e. replace them, they no longer work! so you have to create new object. how to fix this???...
  (defn reload
    ([] (reload *ns*))
    ([n]
       (let [name (cond (symbol? n) n true (ns-name n))]
	 (require name :reload-all))))

  (def- *fake* (gensym))
  (defmacro defrecord+ 
    [record-name fields-and-values constructor-name & record-body] 
    (let [fields-and-values (map #(if (vector? %) % [% nil])
				 fields-and-values) 
	  fields            (vec (map first fields-and-values)) 
	  default-map       (into {} fields-and-values)
	  fn-name (symbol (or (and constructor-name (str constructor-name))
			      (str "new-" (name record-name))))] 
      `(do 
	 (defrecord ~record-name 
	     ~fields 
	   ~@record-body) 
	 (defn ~fn-name
	   ([] (~fn-name ~#'*fake* nil))
	   ([& {:keys ~fields :or ~default-map}] 
	      (new ~record-name ~@fields))))))

  (binding [*out* *out*] (defn- log [e] (.println *out* (str "ERROR!: " e))))

  ;;TODO: get rid of!
  (defmacro mapc [& args] `(dorun (map ~@args)))
  (defmacro thread [& body]
    `(let [thread# (Thread.
		    (bound-fn [] (try (do ~@body) (catch Exception e# (println "error in thread " e#)))))]
       (.start thread#)
       thread#))

  (defmacro is [val & message]
    `(let [result# ~val]
       (if (not result#)
	 (throw (Exception. ~(or (and (first message) `(format ~@message)) (format "assert: %s" (str val)))))
	 result#)))
  ;;TODO: efficiency: timeout without throwing exception? and definitely a timeout with all that thread hastle!
  ;; this should be done in a thread pool!
  (defmacro pf [& args]
    `(print (format ~@args)))

  (comment
    (defmacro throwf [message & args]
     (if args
       `(throw (Exception. (format ~message ~@args)))
       `(throw (Exception. ~message)))))

  (defn group
    ([coll] (group coll 2))
    ([coll by] (partition-all by coll)))

  (defmacro do1 [a & body]
    `(let [ret# ~a]
       ~@body
       ret#))
  (defmacro mapc [& args] `(dorun (map ~@args)))
  (defn sleep [s] (Thread/sleep (* 1000 s)))


  (defmacro on [[& args] & body]
    (let [a (group args 2)
	  first-args (map first a)
	  second-args (map second a)]
      `(doseq [[~@first-args] (map vector ~@second-args)]
	 ~@body)))





  (defalias if-match m/if-match)
  (defalias when-match m/when-match)
  (defalias cond-match m/cond-match)
  (defmacro match
    "match item with caluses"
    [item & clauses] 
    (let [msg-gen (gensym)]
      `(let [~msg-gen ~item] 
	 (cond-match
	  ~@(mapcat (fn [[test body]]
		      `[[~test ~msg-gen] ~body]) (group clauses 2))))))
#+end_src

*** Log
#+srcname:forex-util-log 
#+begin_src clojure :tangle src/forex/util/log.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.log
    (:clone clj.core)
    (:import [java.util.logging Logger Level LogManager Handler
	      FileHandler SimpleFormatter ConsoleHandler])
    (:require [clojure.contrib.duck-streams :as f])
    (:use forex.util.emacs forex.util.general))

  ;;TODO: minor mode
  (defvar log-dir "%h/.forex")
  (defvar log-file)

  (defn- formatter [] 
    (let [d (java.util.Date.)]
      (proxy [java.util.logging.Formatter] []
	(format [r] 
		(clojure.core/format "%s%n%s: %s%n%n"
				     (do (.setTime d (.getMillis r)) d)
				     (.getLevel r)
				     (.getMessage r))))))

  ;;wrap the PrintWriter *out* in an OutputStream to be used in ConsoleHandler
  (comment
    (defn- new-out-stream [out]
      (proxy [java.io.OutputStream] []
	(close [] (.close out))
	(flush [] (.flush out))
	(write ([b] (.print out (String. b)))
	       ([b off len] (.print out (String. b off len)))))))

  (defn new-logger
    ([file] (new-logger file true))
    ([file make-file]
       (when make-file
	 (let [file (format "%s/.forex/%s" (System/getProperty "user.home")
			    file)]
	   (f/make-parents
	    (java.io.File. file))
	   (var-root-set #'log-file file)))
       (let [l (java.util.logging.Logger/getLogger (str *ns*))]
	 (mapc #(.removeHandler l %) (.getHandlers l))
	 (.addHandler l (doto (ConsoleHandler.) (.setFormatter (formatter))))
	 (when make-file
	   (.addHandler l (doto (FileHandler. (str log-dir "/" file))
			    (.setFormatter (formatter)))))
	 (.setUseParentHandlers l false)
	 l)))

  (defvar log (new-logger "forex-log" false))

  ;;TODO: set filtering levels
  ;;fine,finer,finest wont log

  (def- *debug-info* "")
  (defmacro debugging [str & args] `(binding [*debug-info* ~str] ~@args))

  (defn info [msg & args]
    (.info log (apply format (str *debug-info* " " msg) args)))
  (defn out [msg & args]
    (println (apply format (str "INFO: " *debug-info* " " msg) args))
    (apply info msg args)
    nil)

  (defn fine [msg & args]
     (.fine log (apply format  (str *debug-info* " " msg) args)))
  (defn finer [msg & args]
     (.finer log (apply format (str *debug-info* " " msg) args)))
  (defn finest [msg & args]
    (.finest log (apply format (str *debug-info* " " msg) args)))
  (defn severe [msg & args]
    (let [s (apply format (str *debug-info* " " msg) args)]
      (.severe log s)
      (print (format "SEVERE: %s%n" s))))
  (defn warn [msg & args]
    (let [s (apply format (str *debug-info* " " msg) args)]
      (.warning log s) 
      (print (format "WARNING: %s%n" s))))
#+end_src

*** Fiber
#+srcname:forex-util-fiber-spawn
#+begin_src clojure :tangle src/forex/util/fiber/spawn.clj
  ;;inspired by gambit-c termite's syntax
  (ns forex.util.fiber.spawn
    (:use forex.util.general)
    (:require [forex.util.fiber.mbox :as m]))

  ;;TODO: will eventually integrate with zeromq and will be able to be 'reactive' so we avoid
  ;;java's thread pool limit (or somehow get kilim to work?)
  ;;TODO: also, should we allow functions like ?? to discard messages? Perhaps not?
  ;;TODO: user settable default return value?
  ;;TODO: linking, remote nodes
  ;;utils
  (defonce- *mailboxes* (atom {}))
  (defn- make-mailbox [tag]
    (let [mb (m/new-mbox)]
      (swap! *mailboxes* assoc tag mb)
      mb))
  (defonce- *threads* (atom {}))

  (defn- remove-pid [pid]
    (when pid (swap! *threads* dissoc pid) (swap! *mailboxes* dissoc pid)))
  (defn- get-mailbox [tag]
    (get @*mailboxes* tag))
  (defn pid? [pid]
    "test for valid pid"
    (if (get-mailbox pid) true false))

  (defonce- *mb* (ThreadLocal.))
  (defonce- *self* (ThreadLocal.)) 
  (defn- mb [] (.get *mb*)) 

  ;; functions
  (let [r (java.util.Random.)]
    (defn make-tag []
      "produce a random tag/pid"
      (Long/toString (Math/abs (.nextLong r)) 36)))

  (defn ?? []
    (m/?? (mb) nil))
  (defn- throwf [& args] (throw (Exception. (apply format args))) )

  (defn !
    "send a message to a pid, with an option id which the message will be placed in"
    ([pid msg] (! pid nil msg))
    ([pid id msg]
       (if-let [mbox (get-mailbox pid)]
	 (m/! mbox id msg)
	 (throwf "unknown pid %s" pid))))
  (binding [*out* *out*] (defn- log [& args] (println (apply format args))))
  (defn self []
    "returns pid of current spawn or nil if it isnt a spawnage"
    (.get *self*))
  (defn spawn
    ([thunk] (spawn thunk nil))
    ([thunk name]
       (let [tag (make-tag)
	     mail (make-mailbox tag)]
	 (let [thread (let [thread (Thread.
				    (bound-fn
				     [] 
				     (try 
				       (do (.set *mb* mail) (.set *self* tag)
					   (thunk))
				       (catch Exception e
					 (log "pid %s error: %s " (self) e)
					 (.printStackTrace e)
					 )
				       (finally (remove-pid tag)))))]
			(if name (doto thread (.setName name)) thread))]
	   (swap! *threads* assoc tag thread)
	   (.start thread))
	 tag)))

  (defn- assert-spawn [] (when (not (self)) (throwf "no local spawn available")))
  ;;does work - but we dont really need it!

  (defn spawn-in-repl []
    "setup current thread as a spawned thread with mailbox"
    (let [tag (make-tag)]
      (remove-pid self)
      (.set *mb* (make-mailbox tag)) (.set *self* tag) (swap! *threads* assoc tag (Thread/currentThread))
      tag)) 

  (def- *?* nil)

  (defn ?
    "receive"
    ([] (? nil nil))
    ([timeout] (? timeout nil))
    ([timeout default] 
       (assert-spawn)
       (or (m/? (mb) nil timeout) default))) 

  (defmacro recv- [item & clauses]
    "match item with caluses"
    (let [msg-gen (gensym)]
      `(let [~msg-gen ~item]
	 (cond-match ~@(mapcat (fn [[test body]]
				 `[[~test ~msg-gen] ~body]) (group clauses 2))))))
  (defmacro recv [& clauses]
    "receive a message from current spawned thread mailbox"
    `(let [msg# (?)]
       (recv- msg# ~@clauses)))
  (defmacro recv-if [& clauses]
    "receive only if a message is in queue"
    `(let [msg# (? 0)]
       (recv- msg# ~@clauses)))

  (comment
    ;;until we figure out why soft-timeout doesnt work... we're leaving this here!
    (defn ??
      "asynchronous with timeout: wait for a receive filtered by the function, discarding any other messages received"
      ([function] (?? function nil))
      ([function timeout]
	 (soft-timeout! *?* timeout
	   (loop []
	     (let [msg (?)]
	       (if-let [it (function msg)]
		 msg
		 (recur))))))))

  (comment
    ;;until we figure out why soft-timeout doesnt work... we're leaving this here!
    (defn !?
      "asynchronous with timeout: send message with a tag and then receive back, discarding any other messages received"
      ([pid data] (!? pid data nil))
      ([pid data timeout]
	 (soft-timeout! *?* timeout
	   (let [tag (make-tag)]
	     (! pid [(self) tag data])
	     (loop []
	       (let [msg (?)]
		 (recv- msg
		   [(= ? tag) ?response] response
		   ? (recur)))))))))


  (defn stop-all 
    "stops all threads spawned. probably only useful for debugging, and assuming they respond to stop"
    []
    (map #(! % "stop") (keys @*threads*)))

  (defn kill-all
    []
    (map #(.stop %) (vals @*threads*)))
#+end_src
  
#+srcname:forex-util-fiber-mbox
#+begin_src clojure :tangle src/forex/util/fiber/mbox.clj
  ;;modified from
  ;;https://github.com/jochu/swank-clojure/tree/master/src/swank/util/concurrent/
  (ns forex.util.fiber.mbox
    (:use forex.util.general))

  ;; Holds references to the mailboxes (message queues)
  (defn- _get
    "Returns the mailbox for a given id. Creates one if one does not
     already exist."
    ([p id]
       (dosync         
	(when-not (get @(:boxes p) id)  
	  (alter (:boxes p) assoc
		 id (java.util.concurrent.LinkedBlockingQueue.)))
	(@(:boxes p) id)))
    {:tag java.util.concurrent.LinkedBlockingQueue})

  (defn !
    "Sends a message to a given id."
    ([p id message] 
       (let [mbox (_get p id)]
	 (.put mbox message))))


  (defn ??
    "poll in milliseconds"
    ([p] (?? p nil))
    ([p id]
       (let [mb (_get p id)]
	 (.peek mb))))

  (defn ?
    "poll in milliseconds"
    ([p id] (? p id nil))
    ([p id timeout]
       (is (or (not timeout) (and (number? timeout) (>= timeout 0))) "timeout must be nil or a positive number")
       (let [mb (_get p id)]
	 (cond
	   (not timeout) (.take mb)
	   true (.poll mb timeout java.util.concurrent.TimeUnit/MILLISECONDS)))))

  (defrecord+ mbox [[boxes (ref {})]]
    new-mbox)
#+end_src

#+srcname:forex-util-emacs
#+begin_src clojure :tangle src/forex/util/emacs.clj
  (ns forex.util.emacs (:use forex.util.general))

  (defn fn-meta [function meta]
    (let [ns-from *ns*]
      (proxy [clojure.lang.AFn clojure.lang.Fn  clojure.lang.IMeta] []
	(invoke [& args] (apply function args))
	(meta [] (merge (meta function) (merge {:ns ns-from} meta))))))

  (defn- val-of [a] (if (var? a) (var-get a) a)) 
  ;;TODO: add log to this
  (defn- apply-fn [a args]
    (try (apply (val-of a) args)
	 (catch Exception e
	   (println (format "error in hook %s %s: %s" a (val-of a) e)))))
  (defmacro- run-fn [a & args]
    `(let [a# ~a]
       (try ((val-of a#) ~@args)
	    (catch Exception e# (println 
				 (format "error in hook %s %s: %s" a# (val-of a#) e#))))))

  (defn- as-ns [a]
    (condp = (class a)
	String (find-ns (symbol a))
	clojure.lang.Symbol (find-ns a)
	a))
  (defn ns-metas
    ([fn] (ns-metas *ns* fn))
    ([ns fn]
       (is (as-ns ns) "%s is not a ns, or cant find it" ns)
       (let [vars (filter fn (vals (ns-interns (as-ns ns))))]
	 (apply hash-map (interleave vars (map var-get vars))))))
  (defn ns-vars
    ([] (ns-vars *ns*))
    ([ns]
       (is (as-ns ns) "%s is not an ns, or cant find it" ns)
       (let [vars (filter #(:var (meta  %)) (vals (ns-interns (as-ns ns))))]
	 (apply hash-map (interleave vars (map var-get vars))))))

  (defmacro defvar
    ([name]
       (let [new-name (with-meta name (assoc (meta name) :var true))]
	 `(defonce ~new-name nil)))
    ([name init]
       (let [new-name (with-meta name (assoc (meta name) :var true))]
	 `(defonce ~new-name ~init))))
  (defmacro defhook [& args] `(defvar ~@args)) 
  (defmacro setq [& args]
    `(do ~@(map
	    (fn [[var val]]
	      `(alter-var-root #'~var (fn [a#] ~val)))
	    (group args))))


  (defn- member
    ([value list] (member value list =))
    ([value list test]
       (some #(test % value) list)))

  (defn- pushnew* [hook arg id replace] 
    (if replace 
      (alter-var-root hook (fn [old]
			     (doall (concat
				     (list arg)
				     (filter #(and (if id (not (= (:id (meta %)) id)) true)
						  (not (= % arg))) old)))))
      (alter-var-root hook (fn [old] 
			     (doall (if (empty? (take 1 (filter #(or (when id (= (:id (meta %)) id)) (= % arg)) old)))
				      (concat (list arg) old)
				      old))))))
  (defmulti pushnew (fn [a b & args] [(if (fn? a) ::fn (type a)) (if (fn? b) ::fn (type b))]))
  (defmethod pushnew [clojure.lang.Var ::fn]
    ([hook function] (pushnew hook function *ns* true))
    ([hook function id] (pushnew hook function id true))
    ([hook function id replace] 
       (let [new-function (if (:id (meta function)) function (if id (fn-meta function {:id id}) function))]
	 (pushnew* hook new-function id replace))))
  (defmethod pushnew [clojure.lang.Var clojure.lang.Var]
    ([hook var] (pushnew hook var nil false))
    ([hook var id] (pushnew hook var id false)) 
    ([hook var id replace] (pushnew* hook var id replace)))


  (defn- add-to-list* [hook arg id replace] 
    (if replace 
      (alter-var-root hook (fn [old]
			     (doall (concat
				     (filter #(and (if id (not (= (:id (meta %)) id)) true)
						  (not (= % arg))) old)
				     (list arg)))))
      (alter-var-root hook (fn [old]
			     (doall (if (empty? (take 1 (filter #(or (when id (= (:id (meta %)) id)) (= % arg)) old)))
				      (concat old (list arg))
				      old))))))
  (defmulti add-to-list (fn [a b & args] [(if (fn? a) ::fn (type a)) (if (fn? b) ::fn (type b))]))
  (defmethod add-to-list [clojure.lang.Var ::fn]
    ([hook function] (add-to-list hook function *ns* true))
    ([hook function id] (add-to-list hook function id true))
    ([hook function id replace] 
       (let [new-function (if (:id (meta function)) function (if id (fn-meta function {:id id}) function))]
	 (add-to-list* hook new-function id replace))))
  (defmethod add-to-list [clojure.lang.Var clojure.lang.Var]
    ([hook var] (add-to-list hook var nil false))
    ([hook var id] (add-to-list hook var id false)) 
    ([hook var id replace] (add-to-list* hook var id replace)))

  (comment
    (defn push [var val]
      (alter-var-root var (fn [it] (concat (list val) it))))) 

  (defn add-hook [hook function] (pushnew hook function))
  (defn add-hooks [hook functions] (doall (map #(pushnew hook %) functions)))

  ;;RUNNING hooks
  (defn run-hooks [& hooks]
    (mapc (fn [hook] (mapc #(run-fn %) hook)) hooks))

  (defn run-hook-with-args [hook & args]
    (mapc #(apply-fn % args) hook))


  (defn run-hook-with-args-until-success [hook & args]
    (is (sequence? hook) "hook %s isnt a list" hook)
    (loop [funcs hook]
      (cond
	(empty? funcs) nil
	true (if-let [it (apply-fn (first funcs) args)]
	       it
	       (recur (rest funcs)))))) 

  (defn run-hook-with-args-until-failure [hook & args]
    (is (sequence? hook) "hook %s isnt a list" hook)
    (loop [funcs hook]
      (cond
	(empty? funcs) true
	true (when (apply-fn (first funcs) args)
	       (recur (rest funcs))))))


  ;;(run-hook-with-args-until-success 'a 3)
#+end_src
*** Spawn
#+srcname:forex-util-spawn
#+begin_src clojure :tangle src/forex/util/spawn.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.spawn
       (:clone clj.core)   
       (:use forex.util.general forex.util.zmq)
       (:import forex.util.zmq.Poller)
       (:require [forex.util.fiber.spawn :as s]))

  (def- *pid* (atom []))

  (defalias pid? s/pid?)
  (defalias self s/self)
  (def kill-all s/kill-all)
  (defalias spawn-in-repl s/spawn-in-repl) ;;TODO: add socket for this one

  (defalias ? s/?)

  (defalias make-tag s/make-tag)
  (defn ! [pid msg]
    (with-open [local (doto (new-socket +push+)
			(.connect (format "inproc://%s" pid)))] 
      (s/! pid msg)
      (.snd local "REQUEST" +noblock+)))
  (defn  stop-all []
    (swap! *pid*
	   (fn [old]
	     (map #(if (pid? %)
		     (! % "STOP")) @*pid*))))


  (defrecord LocalSocket [socket]
    PSocket
    (raw [this] (.raw socket)) 
    (recv [this flags] 
	  (when (.recv socket flags)      
	    (s/?)))  
    (recv [this] (recv this 0))
    (close [this] (.close socket))
    (hasMore [this] false))


  (defonce- *local* (ThreadLocal.))
  (defn- self-get [key]
    (let [map (.get *local*)]
      (when map 
	(map key))))
  (defn- self-assoc [key obj]
    (let [map (.get *local*)]
      (if map 
       (.set *local* (assoc map key obj)))))
  (def local nil)
  (defn spawn
    ([thunk] (spawn thunk nil))
    ([thunk name] 
       (let [pid (s/spawn
		  (fn [] 
		    (.set *local* {})
		    (with-open
			[local-socket (LocalSocket. 
				       (doto
					   (new-string-socket +pull+)
					 (.bind  (str "inproc://" (self)))))]        
		      (binding [local local-socket]
			(thunk))))
		  name)]
	 (swap! *pid* concat [pid])
	 pid)))

  (comment
    (defn te []
      (def pid (spawn #(let [seq (event-seq [local])]
			 (pr (format "local %s %s%n"
				     (first seq)
				     (second seq))))))))




  (defn recv-multi
    ([sock] (recv-multi sock 0))
    ([sock flags] 
       (let [first-msg (.recv sock flags)]
	 (when first-msg 
	   (if (.hasMore sock)
	     (loop [msg [(String. (.recv sock)) first-msg]]
	       (if (.hasMore sock)
		 (recur (cons (String. (.recv sock)) msg))
		 msg))
	     first-msg)))))

  (defn recv-all
    ([sock] (recv-all sock 0))
    ([sock flags]
       (let [first-msg (recv-multi sock flags)]
	 (when first-msg
	   (loop [messages [[sock first-msg]]]
	     (if-let [new-msg (recv-multi sock +noblock+)]
	       (recur (conj messages [sock new-msg]))
	       messages))))))

  ;;TODO: fair queue? prevent too much messages hogging sequence? who knows! ...

  (defn- event-seq* [p]
    (lazy-seq
     (let [amount (.poll p)]
       (concat
	;;TODO: memory overflow with getting all messsages? probably not ....
	(doall
	 (mapcat #(when (or (.pollin p %) (.pollout p %)) (recv-all (.getSocket p %))) 
		 (range 0 (.getSize p))))
	(event-seq* p))))) 


  (defmulti event-seq class)
  (defmethod event-seq clojure.lang.IPersistentVector [v]
    (event-seq (new-poller v)))
  (defmethod event-seq Poller [p] (event-seq* p)) 

  ;;? with multiple sources or change to poll
  ;;!? (timeout)
  ;;?? (filter)
#+end_src
*** ZMQ
#+srcname:forex-util-zmq
#+begin_src clojure :tangle src/forex/util/zmq.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.zmq
    (:clone clj.core)
    (:import (org.zeromq ZMQ))
    (:use forex.util.general))
  (def +noblock+ 1)

  (def +p2p+ 0)
  (def +pub+ 1)
  (def +sub+ 2)
  (def +req+ 3)
  (def +rep+ 4)
  (def +xreq+ 5)
  (def +xrep+ 6)
  (def +pull+ 7) 
  (def +push+ 8)

  (def +hwm+ 1)
  (def +lwm+ 2)
  (def +swap+ 3)
  (def +affinity+ 4)
  (def +identity+ 5)
  (def +subscribe+ 6)
  (def +unsubscribe+ 7)
  (def +rate+ 8)
  (def +recovery-ivl+ 9)
  (def +mcast-loop+ 10)
  (def +sndbuf+ 11)
  (def +rcvbuf+ 12)

  (def +pollin+ 1)
  (def +pollout+ 2)
  (def +pollerr+ 4)
  (def +more+ 2)

  ;;Context
  (defn new-context [io-threads]
    (ZMQ/context io-threads))
  (defonce *context* (new-context 1))

  (defprotocol PSocket
    (raw [this])
    (recv [this flags] [this])
    (bind [this address])
    (connect [this address])
    (hasMore [this])
    (close [this])
    (snd [this msg] [this msg flags])) 
  (defprotocol PPoller
    (setTimeout [this timeout])
    (poll [this])
    (register [this socket])
    (getSocket [this i])
    (getSize [this])
    (pollin [this i])
    (pollout [this i])) 
  (defrecord Poller [poll sockets] 
    PPoller 
    (getSize [_] (.getSize poll))
    (pollin [_ i] (.pollin poll i))
    (pollout [_ i] (.pollout poll i))
    (setTimeout [_ timeout] (.setTimeout poll timeout))
    (poll [_] (.poll poll))
    (register [_ socket]
	      (.register poll
			 ;;TODO: what if we reload? wont work?
			 (if (extends? PSocket (class socket))
			   (.raw socket)
			   socket))
	      (swap! sockets conj socket))
    (getSocket [_ i] (nth @sockets i)))

  (defn new-poller
    ([sockets] (new-poller *context* sockets))
    ([context sockets]
       (let [p (Poller. (.poller context (count sockets)) (atom []))]
	 (.setTimeout p -1)
	 (on [sock sockets]
	     (.register p sock))
	 p)))

  ;;TODO: now just a string socket!
  (defrecord StringSocket [socket]
    PSocket 
    (raw [this] socket)
    (snd [this msg] (.snd this msg 0))
    (snd [this msg flags]
	 (if (string? msg)
	   (.send socket (.getBytes msg) flags)
	   (.send socket msg flags))) 
    (recv [this flags] (when-let [it (.recv socket flags)] (String. it)))
    (recv [this] (recv this 0)) 
    (close [this] (.close socket))
    (bind [this address] (.bind socket address))
    (connect [this address] (.connect socket address))
    (hasMore [this] (.hasReceiveMore socket))) 
  (defrecord Socket [socket]
    PSocket 
    (raw [this] socket)
    (snd [this msg] (.snd this msg 0))
    (snd [this msg flags]
	 (if (string? msg)
	   (.send socket (.getBytes msg) flags)
	   (.send socket msg flags))) 
    (recv [this flags]  (.recv socket flags))
    (recv [this] (recv this 0)) 
    (close [this] (.close socket))
    (bind [this address] (.bind socket address))
    (connect [this address] (.connect socket address))
    (hasMore [this] (.hasReceiveMore socket)))

  (defn new-socket
    ([type] (new-socket *context* type))
    ([context type] (Socket. (.socket context type))))
  (defn new-string-socket
    ([type] (new-socket *context* type))
    ([context type] (StringSocket. (.socket context type))))

  (comment
    (defn new-poll
      ([sockets] (new-poll *context* sockets))
      ([context sockets]
	 (let [p (.poller context (count sockets))]
	   (.setTimeout p -1)
	   (on [sock sockets]
	       (.register p (.socket sock)))
	   p)))

    (defn new-socket
      ([socket-type]
	 (new-socket *context* socket-type))
      ([context socket-type ]
	 (.socket context socket-type))))
#+end_src
*** GUI
#+srcname:forex-util-gui
#+begin_src clojure :tangle src/forex/util/gui.clj
  (ns forex.util.gui
    (:require swank.swank)
    (:use forex.util.general clojure.contrib.miglayout forex.util.emacs forex.util.log)
    (:import 
     (java.awt Dimension Font event.MouseListener
	       event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
     (javax.swing JComboBox JPopupMenu JMenuItem
		  ImageIcon
		  table.AbstractTableModel
		  JScrollPane JTable
		  JFrame JPanel JTextField JLabel JButton
		  SwingUtilities)))

  (import javax.swing.JOptionPane)
  (defn inform [msg & args]
    (JOptionPane/showMessageDialog
     nil (apply format (str msg) args) "!" JOptionPane/INFORMATION_MESSAGE)) 
  (defn prompt
    ([msg & args]     
       (let [no-default true
	     p (if no-default 
		 (JOptionPane/showOptionDialog (JPanel.)
					       (apply format (str msg) args) "???"
					       JOptionPane/YES_NO_OPTION
					       JOptionPane/QUESTION_MESSAGE
					       nil
					       (into-array  ["Yes" "No"])
					       "No")
		 (JOptionPane/showConfirmDialog
		  nil (apply format (str msg) args)
		  "???" JOptionPane/YES_NO_OPTION))]
	 (if (= JOptionPane/YES_OPTION p)
	   true
	   false))))


  (defn create-image [path]
    (.getImage (Toolkit/getDefaultToolkit) path))
  (defn create-icon [path]
    (try
      (ImageIcon. (create-image path))
      (catch Exception e
	(warn "couldnt create image %s" path)
	nil)))

  (defn- get-fn [a] (if (var? a) (var-get a) a))
  (defn- call-fn [a & args]
    (thread
     (let [f (get-fn a)]
       (if (fn? f) 
	 (apply f args)
	 (warn "in listener, in var %s,val %s is not a function" a f)))))

  (defn add-key-listener [obj f]
    (when (fn? (get-fn f))
      (.addKeyListener obj (proxy [KeyListener] []
			     (keyReleased [e] (call-fn f e))
			     (keyPressed [e])
			     (keyTyped [e])))))

  (defn add-action-listener [item val]
    (when (or (and (var? val) (fn? (var-get val))) (fn? val))
      (let [f (bound-fn [e] (call-fn val e))]
	(.addActionListener item
			    (proxy [ActionListener] nil 
			      (actionPerformed [e]
					       (try
						 (f e)
						 (catch Exception e
						   (severe "error in action listener %s" e)))))))))
  (defn add-popup-listener [obj f]
    (when  (fn? (get-fn f))
      (let [f (bound-fn [e] (call-fn f e))]
       (.addMouseListener
	obj
	(proxy [MouseAdapter] nil
	  (mousePressed [e] (when (.isPopupTrigger e) (f e)))
	  (mouseReleased [e] (when (.isPopupTrigger e) (f e)))))))
    obj)
  ;;TODO; println stack trace
  (defmacro invoke-later [& args]
    `(SwingUtilities/invokeLater (bound-fn []
					   (try (do ~@args)

						(catch Exception e#
						  (.printStackTrace e#)
						  (println e#))))))
#+end_src

*** Devel
#+srcname:forex-util-mql-devel
#+begin_src clojure :tangle src/forex/util/mql_devel.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.mql-devel
       (:clone clj.core)
       (:use forex.util.general))


  (defmacro cond-out [& args]
    (apply str (map (fn [a]
		      (let [name (str a)]
			(format " else if (command==\"%s\") {\n\t   ret = process_%s(request);\n\t}" name name)))
		    args)))

  (cond-out
   AccountBalance
   AccountCredit
   AccountCompany
   AccountCurrency
   AccountEquity
   AccountFreeMargin
   AccountLeverage
   AccountMargin
   AccountName
   AccountNumber
   AccountServer
   AccountProfit
   OrderLots
   OrderDelete
   OrderCloseTime
   OrderType
   OrdersTotal
   OrderSend
   MarketInfo
   OrderClose
   OrderModify)
#+end_src

#+srcname:forex-util-indicator-devel
#+begin_src clojure :tangle src/forex/util/mql_indicator_devel.clj
  (clojure.core/use 'nstools.ns)
  ;;this file allows one to automatically produce binding code for metatrader custom indicators
  (ns+ forex.util.mql-indicator-devel
    (:clone clj.core)
    (:import java.io.File))

  (defmacro for+ [args & body]
    (let [a (partition-all 2 args)]
      `(map (fn ~(vec (map first a)) ~@body) ~@(map second a))))
  (defn throwf [msg & args]
    (throw (Exception. (apply format msg args))))

  (defn args [s]
    (map rest (re-seq #"extern\s+(\w+)\s+(\w+)" s)))
  (defn buffers [s]
    (count (re-seq #"SetIndexBuffer" s)))

  (defn extract [args]
    (let [type-to-fn (fn [type]
		       (condp = type
			   "int" "StrToInteger"
			   "double" "StrToDouble"
			   "string" nil
			   "color" "StrToInteger"
			   "bool" "StrToInteger"
			   (throwf "unknown type %s" type)))
	  user-extract (apply str
			      (interpose "\n"
					 (for+ [[type name] args index (iterate inc 6)]
					       (let [type-fn (type-to-fn type)]
						 (if type-fn
						   (format "%s %s = %s(command[%s]);" type name type-fn index)
						   (format "%s %s = command[%s];" type name index))))))
	  always (format "
  string symbol = command[2];
  int timeframe = StrToInteger(command[3]);
  int mode = StrToInteger(command[4]);
  int shift = StrToInteger(command[5]);")]
      (str always "\n" user-extract)))

  (defn extension [f] (let [e (second (.split (if (instance? File f) (.getName f) f) "\\."))] (if (string? e) (.trim e))))

  (defn to-test [all]
    (format "%nstring process_INDICATORS(string commands[]) {%nstring ret = \"\";string command=commands[1];%n%s%nreturn(ret);}"
	    (apply str
		   "if (command==\"0\") {\n}\n"
		   (map #(format "else if (command==\"%s\") {%nprotocol_found=true;%nret = %s(commands);%n}%n" (:function-name %) (:function-name %)) all))))


  (defn- listify [s] (if-not (empty? s) (str (apply str (interpose "," s)) ",") "" ))
  (defn name-of [f] (first (.split (.getName f) "\\.")))
  (defn iCustom
    "given a file, generate mql4 binding code to the indicator in the flie"
    [f]
    (let [name (.replaceAll (first (.split (.getName f) "\\.")) "( |-)+" "_")
	  s (slurp f)
	  args (map #(list (first %) (format "i_%s" (second %))) (args s))
	  buffers (buffers s)]
      (when (and s args buffers)
	(let [custom (format "double val = iCustom(symbol,timeframe,\"%s\",%smode,shift);" ;
					       (name-of f) (listify (map second args))) 
	      extract (extract args)

	      return (format
		      "
  int err = GetLastError();
  if(err!=0)
    return(\"error \" + err);
  return(val); 
  }")
	      function-name (format "Custom_%s" name)
	      function-header (format "string %s (string command[]) {" function-name)] 
	  {:file f :file-name name :function-name function-name :args args :buffers buffers
	   :code  (format "%s %s %s %s" function-header extract custom return)}))))

  (defn iCustom-all [dir out]
    (let [files (.listFiles (File. dir))
	  customs (for [f files :when (= (extension f) "mq4")] (iCustom f))]
      (spit out (format "bool protocol_found = false;%n%s\n%s" (apply str (interpose "\n\n" (map :code customs)))
			(to-test customs)))))


  ;;example usage - first param is custom indicator folder, second is output file
  (defn do-it []
    (iCustom-all
     "/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/indicators/"
     "/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/include/INDICATORS.mqh"))
#+end_src

** Backend
*** MQL Socket Service
#+srcname:mql-socket-service
#+begin_src clojure :tangle src/forex/backend/mql/socket_service.clj
  ;;forex.backend.mql.socket-service: provide background sockets which allow us to connect with metatrader. Provides functions to interact with the background socket

  ;;todo: bug with stopping all and then stopping again! so bug with stop..
  (clojure.core/use 'nstools.ns)
  (ns+ forex.backend.mql.socket-service
       (:clone clj.core) 
       (:require
	[forex.util.fiber.mbox :as m]
	[clojure.contrib.logging :as l]) 
       (:import (java.io DataInputStream ByteArrayInputStream))
       (:use
	forex.backend.mql.utils
	forex.util.emacs 
	forex.util.core forex.util.general
	forex.util.zmq forex.util.log
	forex.util.spawn))

  ;;TODO: 10ms or so per request, a little slow...
  ;;also, unfortunately, if we add more servers, speed doesn't increase linearly. so the bottleneck is in the clojure code ... a better designed socket service should really be made.
  ;; in addition, if servers drop out, we will be waiting forever for them. this is bad.

  (defvar mql-socket-recv-address "tcp://127.0.0.1:3010")
  (defvar mql-socket-send-address "tcp://127.0.0.1:3005")

  (defonce- *ids* (atom {}))
  (defrecord MqlError [e])

  ;;socket service
  (defn mql-recv [msg] 
    (catch-unexpected
     (let [[id type info] msg]
       (when id
	 (let [type (String. type)
	       msg-ask (get @*ids* id)
	       result (cond
		       (= type "long") (Long/parseLong (String. info))
		       (= type "boolean")
		       (let [a (Integer/parseInt (String. info))]
			 (condp = a
			     1 true
			     0 false
			     (Exception. (str "unkown boolean return result of " a))))
		       (= type "double[]") (into-doubles info)
		       (= type "double") (Double/parseDouble (String. info)) 
		       (= type "int") (Integer/parseInt (String. info))
		       (= type "string") (String. info) 
		       (= type "error") (MqlError. (parse-int (String. info)))
		       (= type "global") (String. info)
		       true (Exception. (str "Unkown type " type)))] 
	   (if msg-ask
	     (do (deliver msg-ask result) (swap! *ids* dissoc id))
	     (warn "msg-ask corresponding to id %s is nil" id))))))) 

  (defn- socket-service-match [events send receive]
    (let [event (first events)]
      (match
       event
       [local "STOP"] (do (info "closing ...") "STOP")  
       [local ["REQUEST" ?msg ?askin]]  
       (let [id (msg-id)  
	     result  (.snd send (str id " " msg) +noblock+)]
	 (if-not result  
	   (do  
	     (warn
	      "failed to queue request %s: are any metatrader scripts alive?"
	      msg)
	     (catch-unexpected
	      (deliver askin (Exception. "metatrader side of socket service is down"))))
	   (swap! *ids* assoc id askin)))  
       [receive ?msg] (mql-recv msg)   
       ?msg (warn "Ignoring invalid message %s" msg))))

  ;;TODO: weird bug when stopping everything with an ea.

  (defn spawn-mql-socket-service
    []  
    (debugging
     "MQL Socket Service: " 
     {:pid 
      (spawn-log  
       #(with-open [send (doto (new-socket +push+)
			   (.bind mql-socket-send-address))
		    receive (doto (new-socket +pull+)
			      (.bind mql-socket-recv-address))] 
	  (loop [events (event-seq [receive local])]
	    (when-not (= "STOP" (socket-service-match events send receive))
	      (recur (rest events)))))
       "MQL Socket Service")})) 

  ;;global socket service
  (defonce- *s* (atom nil)) 
  (defn alive? []
    (pid? (:pid @*s*))) 
  (defn start []
    (if (alive?)
      (warn "mql socket is already alive!")
      (do (reset! *ids* {}) (reset! *s* (spawn-mql-socket-service)))))
  (defn stop []
    (if (alive?)
      (! (:pid @*s*) "STOP")
      (warn "mql socket service is already stopped")))

  ;;interact with mql
  ;;TODO: if mql isnt alive and we retry/????
  (defn request [askin msg]
    (io!
     (if (pid? (:pid @*s*)) 
       (! (:pid @*s*) ["REQUEST" msg askin])
       (throwf "mql socket service is not alive"))))

  ;;TODO: we added a debug message
  ;;so when we get the really annoying failures to
  ;;stop we can examine this:)
  ;;ALSO, we can now apparently get the write lock! hmm...
  ;;ALL BECAUSE WE DONT USE INFINITE TIMEOUT?  
  (defn receive
    ([msg] (receive msg false))
    ([msg resend]
       (let [ask (promise)]
	 (request ask msg)
	 (loop [i 0]
	   (if (wait-for ask 5000)
	     (let [result @ask]
	       (cond 
		(instance? Exception result) (throw result)
		(or result (false? result)) result
		true (throwf "invalid result received %s" result))) 
	     (do (debug "too much time! for msg %s retry %s" msg i)
		 (if resend
		   (do (debug "resending request ...") (receive msg resend))
		   (recur (+ i 1)))))))))
#+end_src 
** Module 
*** Account
#+srcname:account-core
#+begin_src clojure :tangle src/forex/module/account/core.clj
  ;;forex.module.order.core - interface with mql backend
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.account.core
    (:clone clj.core)
    (:use forex.util.core
	  forex.util.emacs 
	  forex.util.general
	  forex.module.error))

  (def- order
    {:buy 0 :sell 1 :buy-limit 2 :sell-limit 3 :buy-stop 4 :sell-stop 5})

  (def- color
    {:red 230 :yellow 65535 :green 65280 :blue 13749760
     :purple  16711935 :white 16777215 :black 0})

  (defn- get! [hash key]
    (if-let [it (hash key)]
      it
      (throwf "invalid key %s in hash %s" key hash)))

  ;;the below can throw errors - how to handle this? 
  (defn order-modify
    ([ticket price sl tp]
       (order-modify ticket price sl tp :blue))
    ([ticket price sl tp color_of]
       (receive (format "OrderModify %s %s %s %s %s"
			ticket price sl tp (get! color color_of))))) 

  (defn order-send
    ([symbol cmd volume price] (order-send symbol cmd volume price 0 0))
    ([symbol cmd volume price sl tp] (order-send symbol cmd volume price sl tp 3))
    ([symbol cmd volume price sl tp slip]
       (receive
	(format "OrderSend %s %s %s %s %s %s %s"
		symbol (get! order cmd)
		volume price slip sl tp))))

  (defn order-close-time [ticket]
    (receive (format "OrderCloseTime %s" ticket)))

  (defn order-close [ticket lots price slippage color_of]
    (receive (format "OrderClose %s %s %s %s %s"
		     ticket lots price slippage (get! color color_of))))
  (defn order-delete [ticket]
    (receive (format "OrderDelete %s" ticket)))

  (defn market-info [symbol type]
     (receive (format "MarketInfo %s %s" symbol type)))

  (defn order-close-time [ticket]
    (receive (format "OrderCloseTime %s" ticket)))

  (defn order-type [ticket]
    (receive (format "OrderType %s" ticket)))

  (defn order-lots [ticket]
    (receive (format "OrderLots %s" ticket)))
#+end_src
 
#+srcname:account-utils
#+begin_src clojure :tangle src/forex/module/account/utils.clj
  (clojure.core/use 'nstools.ns)

  (ns+ forex.module.account.utils
    (:clone clj.core)
    (:use forex.util.core
	  forex.util.emacs  
	  forex.util.general
	  forex.module.error)
    (:require  [forex.module.account.core :as core]))


  ;;account common
  (defn- sym [a] (symbol (camel-to-dash a)))
  (defmacro- single [name] `(defn ~(sym name) [] (receive! ~name)))
  (defmacro- singles [& names] `(do ~@(map (fn [a] `(single ~a)) names)))


  ;;none of the below singles or double-singles should throw a mql error - therefore, it is a bug if they do
  (singles
   "AccountCurrency"
   "AccountCompany"
   "AccountServer" 
   "AccountName"
   "AccountNumber"
   "AccountCredit"
   "AccountBalance"
   "AccountEquity"
   "AccountFreeMargin"
   "AccountLeverage"
   "AccountMargin"
   "AccountProfit"
   "OrdersTotal")
  (defn demo? [] (receive "IsDemo"))
  (defn connected? [] (receive "IsConnected"))
  (defn trade? [] (receive "IsTradeAllowed"))

  ;;

  (defmacro- define-market-info [& args]
    `(do ~@(map (fn [[name num]]
		  `(defn ~(symbolicate "mode-" name)
		     ([] (~(symbolicate "mode-" name) (env :symbol)))
		     ([symbol#]
			(let [res# (core/market-info symbol# ~num)]
			  (if (e? res#)
			    (throwf "market-info error %s" (:e res#))
			    res#)))))
		(group args)))) 

  (define-market-info
    low 1
    high 2
    time 5
    bid 9
    ask 10
    point 11
    digits 12
    spread 13
    stoplevel 14
    lotsize 15
    tickvalue 16
    ticksize 17
    swaplong 18
    swapshort 19
    starting 20
    expiration 21
    trade-allowed 22
    minlot 23
    lotstep 24
    maxlot 25
    swaptype 26
    profitcalcmode 27
    margincalcmode 28
    margininit 29
    marginmaintenance 30
    marginhedged 31
    marginrequired 32
    freezelevel 33)

  (comment
    (defn demo? []
      (if (re-find #"(?i)demo" (account-server))
	true
	false)))

  (defn sell? [{type :type}]
    (or (= type :sell) (= type :sell-stop) (= type :sell-limit)))
  (defn buy? [{type :type}]
    (or (= type :buy) (= type :buy-stop) (= type :buy-limit)))
  (defn- to-big [num] (BigDecimal/valueOf (if (integer? num) (double num) num)))
  (defn lot 
    ([num] (lot num (env :symbol)))
    ([num symbol]
       (let [a (to-big num)
	     b (to-big (mode-minlot symbol))]
	 (* b (.intValue (/ a b))))))

  (defn- assert-order [order] (is? [(or (sell? order) (buy? order))]))

  (defn o-- [o & args]
    (assert-order o)
    (if (sell? o) (- (apply - args)) (apply - args)))

  (defn o+ [o & args]
    (assert-order o) 
    (if (sell? o) (apply - args) (apply + args)))
  (defn o- [o & args]
    (assert-order o)
    (if (sell? o) (apply + args) (apply - args)))

  (defn omax [order & args]
    (assert-order order)
    (let [args (filter #(not (zero? %)) args)]
      (if (empty? args)
	(or (:sl order) 0) 
	(apply (if (buy? order) max min) args))))

  (defn omin [order & args]
    (assert-order order)
    (let [args (filter #(not (zero? %)) args)]
      (if (empty? args)
	(or (:sl order) 0) 
	(apply (if (buy? order) min max)
	       args))))


  ;;TODO: change for 4 digit broker
  (defn digits []
    (mode-digits "EURUSD"))

  ;;TODO: check for valid symbol on all of this??
  (defn spread
    ([] (spread (env :symbol)))
    ([symbol]
       (let [d (digits) spread (mode-spread symbol)]
	 (cond
	  (= d 5) (/ spread 10)
	  (= d 4) spread))))

  (defn point
    ([pt] (/ pt (point)))
    ([]
       (let [d (digits)]  
	 (if (= d 5)
	   (* 10 (mode-point))
	   (mode-point)))))

  (defn pip [pt] (* (point) pt))
#+end_src

#+srcname:account-common
#+begin_src clojure :tangle src/forex/module/account.clj
  ;;TODO: unit test everything
  ;;TODO: create a new atom-hash on merging, etc????????
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.account
       (:clone clj.core)
       (:import forex.backend.mql.socket-service.MqlError)
       (:use forex.util.core
	     forex.util.emacs  
	     forex.util.general forex.util.log
	     forex.module.indicator
	     forex.module.error forex.module.account.utils)

       (:require  [forex.module.account.core :as core]))

  (defvar *account-warn-on-mql-error* true)

  (defn- account-warn
    ([err order] (account-warn err order ""))
    ([err order msg & args]
       (if *account-warn-on-mql-error* 
	 (do (warn "MQL error %s on order %s - %s" (:e err)
		   order (apply format msg args)) err)
	 err)))
  (defmacro- with-order [order & body]
    `(let [o# ~order]
       (if-not (= (:lots o#) 0)
	 (do ~@body)
	 (do (warn "attempting to change order %s with zero lots" o#)
	     o#)))) 

  (defn- >? [a] (and (number? a) (>= a 0)))

  (comment
    (defmacro- default [& body] 
      `(binding [*default* @~#'err/*er*]
	 ~@body)))

  ;;TODO: do we need all of these assertions?
  (def- value-to-order-type
    {0 :buy 1 :sell 2 :buy-limit
     3 :sell-limit 4 :buy-stop
     5 :sell-stop}) 

  (defprotocol POrder
    (order-close-time [this])
    (order-type [this])
    (delete! [this] )
    (close! [this] [this new-lots])
    (modify! [this sl-tp-map])
    (order! [this])
    (open? [this]) (close? [this])
    (order? [this]) 
    (market? [this]) (entry? [this]))

  (defn- order-close-time* [{id :id}]
    (is? (string? id))
    ;;we dont need to know mql4 error codes for order close time
    (aif (core/order-close-time id) it -1)) ;;TODO: return 0 instead?
  (defn- order-type*  [order]
    (is? (string? (:id order)))
    (aif (core/order-type (:id order))
	 (value-to-order-type (int it))))

  (defn- delete!* [{id :id lots :lots :as o}]
    (with-order o
      (if-not (= lots 0)
	(aif (core/order-delete id) (merge o {:lots 0}) it)
	o)))


  (defn- close!*
    ([o] (close! o 0))
    ([{:keys [price lots slip id symbol] :as order} new-lots]
       (with-order order
	 (is? [(string? id) (string? symbol) 
	       [price (pos? price)]
	       [(number? lots) (>= lots 0)]])
	 (is? (>= (- lots new-lots) 0))
	 (if-not (= new-lots lots)
	   (aif (core/order-close id (- lots new-lots)
				  (if (sell? order)
				    (ask symbol)
				    (bid symbol))
				  slip :blue)
		(merge order {:lots new-lots})
		(account-warn it order "invalid new lots %s" new-lots))
	   order))))

  ;;TODO: normalize so we dont get mql error 1?
  ;;TODO: act as a regular modify if we dont pass in sl,tp,or price 
  (defn- modify!* [order {:keys [sl tp] :as mod}]
    (with-order order
      (let [sl (or sl (:sl order))
	    tp (or tp (:tp order)) 
	    price (:price order)] 
	(if (or (number? sl) (number? tp))
	  (do  
	    (is? [sl tp price (>? sl) (>? tp) (pos? price)]) 
	    (if-not (and (= sl (:sl order))
			 (= tp (:tp order)))
	      (aif (core/order-modify (:id order) (:price order) sl tp)
		   (merge order (merge mod {:sl sl :tp tp}))
		   (if (= (:e it) 1)
		     (merge order mod)
		     (account-warn it order "sl %s tp %s" sl tp)))
	      (merge order mod)))
	  (merge order mod)))))   

  ;;TOODOs: how do we get map with defaults?
  (defn- verify-order [{:keys [slip symbol type price tp sl lots]
			:or {slip 3 sl 0 tp 0}}]
    (is? [(number? slip) (> slip 0) (integer? slip)]
	 "invalid order slip %s" slip)
    (is? [ (keyword? type) (number? lots)
	   (number? tp) (number? sl) (number? price)]) 
    (is? [ (string? symbol) (> lots 0)
	   (>= tp 0) (>= sl 0) (>= price 0)])  
    (cond
     (or (= type :sell) (= type :sell-limit) (= type :sell-stop))
     (is? (or (and (zero? sl) (zero? tp))
	      (and (zero? sl) tp (< tp price))
	      (and (zero? tp) sl (> sl price))
	      (and (< tp sl) (< tp price) (> sl price)))
	  "invalid %s order with sl/tp %s/%s with price of %s" type sl tp price)
     (or (= type :buy) (= type :buy-limit) (= type :buy-stop))
     (is? (or (and (zero? sl) (zero? tp))
	      (and (zero? sl) tp (> tp price))
	      (and (zero? tp) sl (< sl price))
	      (and (> tp sl) (> tp price) (< sl price)))
	  "invalid %s order with sl/tp %s/%s with price of %s" type sl tp price)
     true (throwf "invalid %s order with sl/tp %s/%s with price of %s"
		  type sl tp price))) 
  ;;TODO: change to make reliable and to work for ECN brokers and such
  ;;see http://forum.mql4.com/36608
  ;;TODO: what happens if second modify fails? how can programmer find this out?

  (defn- order!* [{:keys [symbol type price tp sl lots slip]
		   :as order
		   :or { symbol (env :symbol) sl 0 tp 0 slip 3}}]
    (let [price (or price (if (sell? order) (bid symbol) (ask symbol)))
	  order (merge 
		 {:symbol symbol
		  :slip slip}
		 (merge order {:sl 0 :tp 0 :id "" :price price}))]
      (with-order order    
	(verify-order order)
	(aif (core/order-send symbol type lots price 0 0 slip)
	     (let [result
		   (let [o (merge order {:id it})]
		     ;;now, use modify to change sl and tp
		     (aif (modify!* o {:sl sl :tp tp})
			  (merge o {:sl sl :tp tp})
			  o))
		   spread (spread)]
	       (merge result {:spread spread :break (o+ result price (pip spread))})) 
	     (account-warn it order))))) 

  (defn- open?* [order] 
    (= (order-close-time order) 0))
  (defn- close?* [order]
    (not (open? order)))
  (defn- order?* [order]
    (not (nil? (order-type order))))   
  (defn- market?*
    "determine if order is market order"
    [order]
    (let [type (order-type order)]
      (or (= type :sell) (= type :buy)))) 
  (defn- entry?*
    "determine if order is entry order"
    [order]
    (let [type (order-type order)]
      (and type (not (or (= type :sell) (= type :buy))))))

  (extend clojure.lang.IPersistentMap
    POrder {:order-close-time order-close-time*
	    :order-type order-type*
	    :delete! delete!*
	    :close! close!*
	    :modify! modify!*
	    :order! order!*

	    :open? open?*
	    :close? close?*
	    :order? order?*
	    :market? market?*
	    :entry? entry?*})

  (extend-type MqlError
    POrder
    (order! [this] this)
    (delete! [this] this)
    (close! [this] this)
    (modify! [this] this))

  (extend-type forex.util.core.AtomHash ;;clojure.lang.Atom
    POrder
    (order-close-time [this] (order-close-time @this))
    (order-type [this] (order-type @this))
    ;;(order! [this] (aif (order! @this) (do (reset! (.val this) it) this) it))
    (delete! [this] (aif (delete! @this) (do (reset! (.val this) it) this) it))  
    (close!
     ([this new-amount] (aif (close! @this new-amount) (do (reset! (.val this) it) this) it))
     ([this] (close! this 0)))
    (modify! [this sl-tp] (aif (modify! @this sl-tp) (do (reset! (.val this) it) this) it))
    (open? [this] (open? @this))
    (close? [this] (not (open? @this)))
    (order? [this] (order? @this))
    (market? [this] (market? @this))
    (entry? [this] (entry? @this)))
#+end_src
*** Ea
#+srcname:ea-common
#+begin_src clojure :tangle src/forex/module/ea.clj
  ;;TODO: it would be awesome if we could directly modify vars of an ea. but we cant, we can only stop , merge, start. TOOD: lookup how set! works!

  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.ea 
       (:clone clj.core) 
       (:use forex.util.core
	     forex.util.general 
	     forex.util.spawn forex.util.emacs
	     clojure.contrib.core)
       (:import clojure.lang.Atom)
       (:require [clj-time.core :as t])
       (:use  
	forex.util.emacs
	forex.util.log  
	forex.module.error 
	forex.module.indicator 
	forex.module.account)
       (:import forex.util.core.AtomHash  java.util.concurrent.TimeUnit))
  (defvar save-file nil) 
  (defvar ea-on-exit-hook)
  (defvar ea-on-start-hook)
  (defonce *ea-registry* (atom []))
  (defn register-ea []
    (swap! *ea-registry*
	   (fn [old]
	     (filter #(find-ns (symbol %))
		     (if (some #(= % (str *ns*)) old)
		       old
		       (conj old (str *ns*)))))))

  ;;saving objects to strings and going back -slow, but it works
  (import (java.io ByteArrayOutputStream ObjectOutputStream
		   ByteArrayInputStream ObjectInputStream)
	  org.apache.commons.codec.binary.Base64)
  (defn bytes-to-obj
    "convert bytes to object"
    [obj]
    (.readObject
     (ObjectInputStream.
      (ByteArrayInputStream. obj))))
  (defn obj-to-bytes
     "convert object to bytes"
     [obj]
     (with-open [bos (ByteArrayOutputStream.)
		 stream (ObjectOutputStream. bos)]
       (.writeObject stream obj)
       (.flush stream) 
       (.toByteArray bos))) 
  (defn encode [o]
    (Base64/encodeBase64String (obj-to-bytes o)))
  (defn decode [o]
    (bytes-to-obj (Base64/decodeBase64 o)))
  (defmethod print-dup :default [o w]
    (.write w (str "#=(forex.module.ea/decode \"" (encode o) "\")")))  
  ;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;;;; 


  (defn- get-fn [a] (if (var? a) (var-get a) a)) 
  (defonce *ea* nil)
  (defonce *args* nil) 
  (defmacro with-ea [[ea & name] & body]
    `(let [ea# ~ea]
       (debugging (format "%s %s:" ~(or (first name) "") (:name ea#))
		  (binding [*ea* ea# *args* (:args ea#)]
		    (wenv {:symbol (:symbol ea#) :period (:period ea#)}
			  ~@body)))))
  (defmacro locking-read[lock & body]
    `(let [l# (.readLock ~lock)]
       (try (do (.lock l#) ~@body)
	    (finally (.unlock l#)))))
  ;;TODO: for some reason, write lock never can lock
  (defmacro locking-write [lock & body]
    `(let [l# (.writeLock ~lock)]
       (try (do (.lock l#) ~@body)
	    (finally (.unlock l#)))))
  (defmacro locking-write-timeout [[ lock timeout] & body]
    `(let [l# (.writeLock ~lock)]
       (if (.tryLock l# ~timeout TimeUnit/MILLISECONDS)
	 (try (do  ~@body)
	      (finally (.unlock l#))))))


  (deferror *ea-stop* [*clj-forex-error*] [message]
    {:msg (str "ea stop: " message)})


  (defn exit
    ([msg] (raise *ea-stop* msg))
    ([msg & args] (raise *ea-stop* (if (string? msg)
				     (apply format msg args)
				     (concat [msg] args)))))



  ;;TODO: do we really want to copy these objects? yes, in most cases perhaps
  ;;but we should add an option to the ea definition (we will do that later, before first release)
  (defmulti copy-ea-obj class)
  (defmethod copy-ea-obj :default [o] o)
  (defmethod copy-ea-obj clojure.lang.Atom [o] (atom (copy-ea-obj @o)))
  (defmethod copy-ea-obj clojure.lang.Ref [o] (ref (copy-ea-obj @o)))
  (defmethod copy-ea-obj forex.util.core.AtomHash [o] (atom-hash (copy-ea-obj @o)))

  (defn- copy-ea-objs [map]
    (apply hash-map
	   (mapcat (fn [[key val]]
		     (list key (copy-ea-obj val)))
		   map)))

  ;;##ea implementation
  (defonce *eas* (atom []))
  (import java.util.concurrent.locks.ReentrantReadWriteLock)
  ;;TODO: lock orphaning
  (defonce *ea-pre-lock*
    (java.util.concurrent.locks.ReentrantReadWriteLock. true))

  (defn every [pred coll]
    (if (empty? coll)
      false
      (loop [a coll]
	(if (empty? a)
	  true
	  (if (not (pred (first a)))
	    false
	    (recur (rest a)))))))

  (defn query [m]
    (let [a (filter
	     (fn [ea]
	       (if (every (fn [[key val]]
			    (= val (get ea key)))
			  m) 
		 ea))
	     @*eas*)]
      (if (= (count a) 1) (first a) a)))
  (defn alive? [ea] (pid? (:pid ea)))

  (defmacro- catch-unexpected [prefix & body]
    `(try (do ~@body)
	  (catch Exception e#
	    (severe "%s - caught unexpected error %s" ~prefix e#))))


  (require 'clojure.contrib.error-kit)
  ;;TODO; how to create unbound var for error-kit???
  (defn ping [a] (! (:pid a) "PING"))
  (defn ping-all [] (doall (map ping @*eas*)))
  ;;TODO: we need a monitor which pings and then sets something.... like in erlang

  (defn run-by-tick [{:keys [deinit init start] :as ea}]
    (with-ea [ea]   
      (try
	(run-hooks ea-on-start-hook)
	(clojure.contrib.error-kit/with-handler
	  (loop [prev-close nil]
	    (sleep 1) 
	    (when-not
		(match (? 0) 
		       "STOP" true
		       "PING" (do (out "ping") nil)) 
	      (let [new-close (close)]  
		(when-not (= new-close prev-close)
		  (let [func (get-fn start)]
		    (if (fn? func)
		      (locking-read *ea-pre-lock*
				    (func (:args ea)))
		      (warn "%s is not a function. start cannot be called" func))))
		(recur new-close))))
	  (clojure.contrib.error-kit/handle *ea-stop* [message] (out "stopping ea ... %s" message)))  
	(catch Exception e 
	  (severe "stopping ea... caught exception %s" e)
	  (reset! (:exit ea) e)
	  (.printStackTrace e))
	(finally
	 (when-not @(:exit ea) (reset! (:exit ea) true))
	 (info "running deinit ...")
	 (catch-unexpected
	  "deinit" 
	  (let [de (get-fn deinit)]
	    (if (fn? de)
	      (de)
	      (warn "deinit %s is not a function. ignoring ...." de))))))
      (run-hooks ea-on-exit-hook)))

  (defn- timeframe? [a] (number? a))
  (defrecord EA [name type ns init deinit start symbol period args
		 pid run vars exit]) 

  (defn- constant-map [& args] {})
  (defn- constant-true [& args] {})
  (defn new-ea
    ([] (new-ea {}))
    ([{:keys [ns symbol period run args vars] :or {symbol (env :symbol)
						   run run-by-tick
						   vars {}
						   period (env :period)}}]
       (let [ns (cond
		 (nil? ns) *ns*
		 (symbol? ns) (find-ns ns)
		 (string? ns) (find-ns (symbol ns))
		 true ns)]
	 (is? (ns? ns))
	 (is? [(map? vars) (every? var? (keys vars))])
	 (let [name (str (ns-name ns))
	       start (ns-symbol 'start ns)
	       init (or (let [fn (ns-symbol 'init ns)]
			  (if (get-fn fn) fn))
			constant-map)
	       deinit (or (let [fn (ns-symbol 'deinit ns)]
			    (if (get-fn fn) fn))
			  constant-true)] 
	   (is? [(fn? (get-fn init)) (fn? (get-fn deinit)) (string? name)
		 (string? symbol) (fn? run) (timeframe? period)])
	   (EA. (format "%s %s, %s" name symbol period) (last (.split name "\\."))
		ns
		init deinit start symbol period (or args {})
		nil run
		(merge (copy-ea-objs (ns-vars ns)) vars)
		(atom 0)))))) 

  ;;how to get it to access actual var? as long as we dont use set!
  (defmethod clojure.core/print-method EA [o w]
    (.write w  (format "<EA \"%s\" %s %s |%s|>"
		       (:name o) (pid? (:pid o))
		       (:args o) (:vars o))))

  ;;TODO: pid without spawn!!

  (defn run-start [ea]
    (let [ea (merge ea {:exit (atom false)})]
     (with-ea [ea "START"] 
       (with-bindings (:vars ea)
	 (let [new-ea (merge ea {:pid (spawn
				     #((:run ea) ea)
				     (:name ea))})]
	   (swap! *eas* conj new-ea) 
	   new-ea)))))


  (defn restart [ea]  
    (when (not (alive? ea))
      ;;TODO: for some reason, if we change it to (hash old), it screws up! what!
      (let [old (swap! *eas*
		       (fn [old] (doall (filter #(not (= (hash ea) (hash %))) old))))]
	(try
	  (run-start ea)
	  (catch Exception e (swap! *eas* conj ea)
		 (.printStackTrace e)
		 (out "caught exception when running start %s" e))))))

   ;;TODO: check return type
  (defn run-init [ea]
    (with-ea [ea "INIT"]
      (let [result ((get-fn (:init ea)) (:args ea))]
	(if (map? result)
	  (merge ea {:vars (merge (:vars ea) result)})))))

  (defn run-all [ea]
    (try
      (with-ea [ea "ALL"]
	(let [new-ea (run-init ea)]
	  (if (instance? EA new-ea)
	    (run-start new-ea)))
	(catch Exception e
	  (out "caught exception %s" e)))))

  (defn- filter-map [f map]
    (let [vals (mapcat identity (filter (fn [[key val]]
					  (f key)) map))]
      (if (empty? vals) {} (apply hash-map vals))))

  (defn run
    ([] (run *ns* {}))
    ([args] (run *ns* args))
    ([ns args] 
       ;;todo: not default, no nil
       (run-all (new-ea {:ns ns 
			 :args (filter-map #(and (not (var? %))
						 (not (#{:symbol :period} %))) args)
			 :vars (filter-map var? args)
			 :symbol (or (:symbol args) (env :symbol))
			 :period (or (:period args) (env :period))}))))

  (defn sym [] (:symbol *ea*))
  (defn period [] (:period *ea*))
  ;;TODO: wait till it stops and delete
  (defn stop [ea]
    (let [stop-it (fn [e]
		    (if (pid? (:pid e))
		      (do (! (:pid e) "STOP") 
			  true)))]
      (if (map? ea)
	(stop-it ea)
	(map stop-it ea))))

  (defn clear-eas [] (count (reset! *eas* (filter alive? @*eas*))))
  ;;SAVE/LOAD
  (defn save-eas
    ([] (save-eas save-file 1000))
    ([save-file] (save-eas save-file 1000))
    ([save-file timeout]
       (debugging "Save EA:"
	(try
	  (locking-write-timeout [*ea-pre-lock* (or timeout 1000)] 
				 (info "saving ...")
				 (frm-save save-file @*eas*)
				 (count @*eas*))
	  (catch Exception e
	    (warn "failed to save eas %s" e))))))

  (defn load-eas 
    ([] (load-eas save-file false))
    ([append] (load-eas save-file append))
    ([file append]
       (debugging "Load EA:"
	(try
	  (let [eas (frm-load file)]
	    (is? [(or (empty? eas) (every #(instance? EA %) eas))])
	    (if append (do (swap! *eas* concat eas) (count eas)) (vec eas)))
	  (catch Exception e
	    (warn "failed to load eas %s %s: %s" file append e))))))
#+end_src
*** Error
#+srcname:error-common 
#+begin_src clojure :tangle src/forex/module/error.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.error
       (:clone clj.core)
       (:require forex.backend.mql.socket-service)
       (:require [forex.backend.mql.socket-service :as s])
       (:use forex.util.general
	     forex.util.core
	     forex.util.emacs 
	     forex.util.general))

  (defn e? [a]
    (instance? forex.backend.mql.socket-service.MqlError a))

  (defmacro aif
    ([test then] `(aif ~test ~then nil))
    ([test then else]
       `(let [~'it ~test] 
	  (if (and ~'it (not (e? ~'it)))
	    ~then
	    ~else)))) 
  (defmacro awhen [test & body] `(aif ~test (do ~@body)))
  (defmacro aif-not 
    ([test then] `(aif-not ~test ~then nil))
    ([test then else]
       `(let [~'it ~test]
	  (if (not (and ~'it (not (e? ~'it))))
	    ~then
	    ~else)))) 
  (defmacro awhen-not [test & body] `(aif-not ~test (do ~@body)))

  ;;receive with errors
  (defn receive!
    ([msg] (receive! msg nil))
    ([msg try]
       (loop [retries 0]
	 (let [result (s/receive msg)]
	   (if (e? result)
	     (let [e (:e result)]
	      (cond 
	       (and try (< retries try) (or (= e 4066) (= e 4054))) (do (Thread/sleep 300) (recur (inc retries)))
	       true (throwf "MQL error %s" e)))
	     result)))))

  ;;receive with default instead of errors, returns error object for errors
  ;;is customizable to default to errors!

  (defonce- *er* (gensym)) 
  (def *default* *er*)

  (defn receive
    ([msg] (receive msg *default*))
    ([msg default]
       (let [result (s/receive msg)]
	 (if (e? result)
	   (if (= default *er*)
	     result
	     (if (fn? default) (default result) default))
	   result))))
#+end_src
*** Indicator
#+srcname:indicator-common
#+begin_src clojure :tangle src/forex/module/indicator.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.indicator
    (:clone clj.core)
    (:use
     forex.util.core
     forex.util.general
     forex.module.account.utils
     forex.module.error)   
    (:require [forex.module.error :as s]))

  (def +m1+ 1)
  (def +m5+ 5)
  (def +m15+ 15)
  (def +h1+ 60)
  (def +h4+ 240)
  (def +d1+ (* 24 +h1+))
  (defn cross?
    ([signal main] (cross? signal main 0))
    ([signal main i]
       (let [i1 (+ i 1) i2 (+ i 2)
	     a1 (signal i1) a2 (signal i2)
	     b1 (main i1) b2 (main i2)] 
	 (or (and (> a1 b1) (< a2 b2) [:buy i])
	     (and (< a1 b1) (> a2 b2) [:sell i])
	     nil))))

  ;;high low open close

  (defn- off [a] (+ (or (env :i) 0) a))
  (defn- receive-double!
    ([a] (receive-double! a 3))
    ([a retries] (double (first (receive! a retries))))) 
  (defn high
    ([] (high 0))    
    ([i] (receive-double! (format "iHigh %s %s %s 1" (env :symbol) (env :timeframe) (off i)))))
  (defn open  
    ([] (open 0)) 
    ([i] (receive-double! (format "iOpen %s %s %s 1" (env :symbol) (env :timeframe) (off i)))))
  (defn low
    ([] (low 0))
    ([i] (receive-double! (format "iLow %s %s %s 1" (env :symbol) (env :timeframe) (off i)))))
  (defn close
    ([] (close 0))
    ([i] (receive-double! (format "iClose %s %s %s 1" (env :symbol) (env :timeframe) (off i)))))

  ;;TODO: change
  (defn ask
    ([] (ask (env :symbol)))
    ([symbol] (aif (mode-ask symbol) it (throwf "MQL error %s" (:e it)))))
  ;;bid==close 
  (defn bid
    ([] (bid (env :symbol)))
    ([symbol] (aif (mode-bid symbol) it (throwf "MQL error %s" (:e it)))))

  (defn- env? [] (and (string? (env :symbol)) (integer? (env :period))))
  (defn- >? [a] (or (zero? a) (pos? a)))
  ;;an example of acessing a custom ea


  (defn moving-averages
    ([method] (fn
		([period] (moving-averages method period))
		([period offset] (moving-averages method period offset))))
    ([method period] (moving-averages method period 0))
    ([method period offset]
       {:pre [(env?)  (>? offset)
	      (number? method) (>? period)]}
       (receive-double! 
	(format "Default_Moving_Averages %s %s %s %s 1 %s 0 %s"
		(env :symbol) (env :period) ;;period/method
		0 (off offset) period method)
	3))) 
  (def sma (moving-averages 0))
  (def ema (moving-averages 1))
  (def smma (moving-averages 2))
  (def lwma (moving-averages 3))

  ;;todo - check for valif params - above 1?
  (defn psar
    "step (0.02), maximum 0.2"
    ([params] (psar params 0))
    ([params offset]
       {:pre [(env?) (>? offset)  (= (count params) 2)]}
       (receive-double!
	(format "Default_Parabolic %s %s %s %s 1 %s %s"
		(env :symbol) (env :period)
		0 (off offset) (first params) (second params))
	3)))
  (defn cci
    ([period] (cci period 0))
    ([period offset]
       {:pre [(env?) (>? offset)  (number? period)]}
       (receive-double!
	(format "Default_CCI %s %s %s %s 1 %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))


  (defn momentum
    ([period] (momentum period 0))
    ([period offset]
       {:pre [(env?) (>? offset)  (number? period)]}
       (receive-double!
	(format "Default_Momentum %s %s %s %s 1 %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))


  (defn rsi
    ([period] (rsi period 0))
    ([period offset]
       {:pre [(env?) (>? offset) (number? period)]}
       (receive-double! 
	(format "Default_RSI %s %s %s %s 1 %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))

  (defn vma
    ([params] (vma params 0))
    ([params offset]
       {:pre [(env?)  (>? offset) (= (count params) 4)]}
       (receive-double! 
	(format "Custom_FantailVMA3 %s %s %s %s 1 %s"
		(env :symbol) (env :period)
		0 (off offset) (apply str (interpose " " params)))
	3)))


  (defmacro- indicator-fn [[params index] & body]
    `(fn a#
       ([~params] (a# ~params 0))
       ([~params ~index]
	  ~@body)))

  (defn rsi-black 
    ([params] (fn 
		([mode offset] (rsi-black params mode offset))
		([offset] (rsi-black params 0 offset))))
    ([params mode] (fn
		     ([offset] (rsi-black params mode offset))
		     ([] (rsi-black params mode  0))))
    ([params mode offset]
       {:pre [(env?) (>? offset) (>? mode) 
	      (= (count params) 5)]}
       (receive-double! 
	(format "Custom_Rsi_BlackFeet_modded %s %s %s %s 1 %s"
		(env :symbol) (env :period)
		mode (off offset) (apply str (interpose " " params)))
	3)))

  (def rsi-black-signal
    (indicator-fn [params index]
		  (rsi-black params 1
				 index)))
  (def rsi-black-main
    (indicator-fn [params index]
		  (rsi-black params 0 index)))


  (defn blazan-dynamic-stop
    ([params] (fn 
		([mode offset] (blazan-dynamic-stop params mode offset))
		([offset] (blazan-dynamic-stop params 0 offset))))
    ([params mode] (fn
		     ([offset] (blazan-dynamic-stop params mode offset))
		     ([] (blazan-dynamic-stop params mode  0))))
    ([params mode offset]
       {:pre [(env?) (>? offset) (>? mode) 
	      (= (count params) 4)]}
       (receive-double! 
	(format "Custom_Blazan_Dynamic_Stop %s %s %s %s 1 %s"
		(env :symbol) (env :period)
		mode (off offset) (apply str (interpose " " params)))
	3)))



  (defn hit? [order val]
    (cond
     (sell? order)
     (<= (close) val)
     (buy? order)
     (>= (close) val )
     true (throwf "invalid order type %s" order)))
#+end_src
** Interface
#+srcname:interface-ea-new
#+begin_src clojure :tangle src/forex/interface/ea_new.clj
  ;;TODO: still a work in progress. for now, lets just execute a function in user
  ;;ea ns, and that function will prompt user and run ea!

  (ns forex.interface.ea-new
    (:use forex.util.log clojure.contrib.with-ns
	  forex.module.ea
	  clojure.contrib.miglayout forex.util.emacs 
	  forex.util.gui)
    (:use forex.interface.gui) 
    (:import 
     (java.awt Dimension Font event.MouseListener
	       event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
     (javax.swing JComboBox JPopupMenu JMenuItem
		  ImageIcon
		  table.AbstractTableModel 
		  JScrollPane JTable
		  JFrame JPanel JTextField JLabel JButton
		  SwingUtilities)))

  (defn ns-args [ns]
    (ns-metas ns (fn [s] (:arg (meta s)))))

  (defn ea-new-gui []
    (when-let [it (and (:selector gui)
		       (.getSelectedItem (:selector gui)))]
      (when-let [ns (find-ns (symbol it))]
	(println "selection is " ns))))
  (defn var-name [a]
    (last (.split (str a) "/")))
  ;;TODO: throw slot value not working!s + add metadata to jlabel,etc
  (defn read-eval [a]
    (let [a (try (read-string (.getText a))
		 (catch Exception e (.getText a)))]
      (if (or (string? a) (symbol? a)) (str a) (eval a))))

  (defn on-start [frame panel]
    (println "result is " (keys (components panel))))

  (defn generate-ea-gui [ns] 
    (let [args (ns-args ns)
	  panel (JPanel.) frame (jframe (str (ns-name ns)))]
      (doto frame
	(.add (apply miglayout panel
		     (concat
		      (mapcat (fn [[key val]]
				(let [label (JLabel. (var-name key))]
				  [label (JTextField. 30)         
				   :wrap]))
			      args)
		      [(doto (JButton. "start")
			 (add-action-listener (fn [e] (on-start frame panel))))
		       "push,growx,span,center"])))
	(.pack)
	(.setVisible true)))) 

  (defn run-init-gui []
    (let [ns (symbol (.getSelectedItem (:selector gui)))]
     (if-let [it (get (ns-map ns) 'init-gui)]
       (if (fn? (var-get it))
	 (binding [*ns* (the-ns ns)]
	   ((var-get it))) 
	 (inform "symbol init-gui in namespace %s is not a function" ns ))
       (inform "%s does not have an init-gui function" ns)))) 

  (alter-var-root
   #'forex.interface.gui/gui-key-map
   merge {\n #'run-init-gui})
#+end_src
 
#+srcname:interface-ea-table
#+begin_src clojure :tangle src/forex/interface/ea_table.clj
  (ns forex.interface.ea-table
    (:require swank.swank) 
    (:use forex.util.log 
	  clojure.contrib.miglayout forex.util.emacs 
	  forex.util.gui forex.interface.tray)
    (:use forex.module.ea forex.interface.gui)
    (:import
     (java.awt
      Dimension Font event.MouseListener
      event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
     (javax.swing JComboBox JPopupMenu JMenuItem
		  ImageIcon
		  table.AbstractTableModel 
		  JScrollPane JTable
		  JFrame JPanel JTextField JLabel JButton
		  SwingUtilities))) 

  (defonce ea-table-gui  nil)
  (defn- italic [a] (format "<html><i>%s</i><html>" a))
  (defn- color [a color]
    (format "<html><color=%s><b>%s</b></color><html>" color a))

  (defn add-watcher [var key f]
    (add-watch var key
	       (bound-fn [& args]
			 (try (apply f args)
			      (catch Exception e

				(severe "caught exception in watcher %s: %s"
					[var key] e)
				(.printStackTrace e))))))


  (defn table-model [titles data]
    (proxy [AbstractTableModel] []
      (getRowCount [] (count data))
      (getColumnCount [] (count titles))
      (getValueAt [row column] (nth (nth data  row) column))
      (getColumnClass [_] String)
      (getColumnName [col] (nth titles col))))


  (defn ea-table-model [eas] 
    (table-model
     [(italic "Name") (italic "Symbol") (italic "Period") (italic "Running?") (italic "Args")]
     (map (fn [ea] 
	    [(:type ea) (:symbol ea) (:period ea)
	     (let [exit @(:exit ea)]
	       (cond
		(and (alive? ea) (= exit false)) (color true "blue")
		true  (if-not (= true  exit)
			(color false "red")
			false)))
	     (:args ea)
	     ea])
	  eas)))

  (defn update-table [table eas]
    (locking table
     (.setModel table (ea-table-model eas))))

  (defn update-ea-table
    ([] (update-ea-table false))
    ([force]
       (let [{:keys [table frame]} ea-table-gui]
	 (when (and table frame (or force (.isVisible frame))) 
	   (update-table table @*eas*)))))

  (defn add-ea-table-watch []
    (add-hook #'ea-on-start-hook #'update-ea-table)
    ;;TODOD: better add-to-list, not repeat, maybe per *ns*?
    (add-hook #'ea-on-exit-hook #'update-ea-table)
    (add-watcher *eas* "table update" (fn [& args]
					(update-ea-table))))

  ;;
  (defn gui-new-table [frame]
    (let [eas @*eas*
	  table (JTable. (ea-table-model eas))
	  panel
	  (miglayout (JPanel.)
		     (JScrollPane. table) 
		     "span,grow" :wrap 
		     (doto  (JButton. "refresh")
		       (add-action-listener
			(fn [e] (update-table table @*eas*))))
		     ;;TODO: technically, is thread safe, oh well, do we care?
		     (doto (JButton. "stop")
		       (add-action-listener
			(fn [e] 
			  (locking table 
			    (let [i (.getSelectedRow table)
				  ea (when (>= i 0) (.getValueAt (.getModel table)
								 i (.getColumnCount table)))]
			      (when (and (>= i 0)
					 (prompt "do you really want to stop ea %s" i))
				(stop ea))))))) 
		     (doto (JButton. "clear")
		       (add-action-listener
			(fn [e]
			  (when (prompt "Do you really want to clear stopped eas?" true)
			    (update-table
			     table
			     (swap! *eas* (fn [old]
					    (filter alive? old)))))))))]
      (alter-var-root  #'ea-table-gui (constantly {:table table :frame frame}))
      panel))

  (defn display-ea-table []
    (if-not (:frame ea-table-gui)
      (let [frame (jframe "expert advisors")]
	(doto frame 
	  (.add (gui-new-table frame))
	  (.pack)
	  (.setVisible true))
	(add-ea-table-watch))
      (do (update-ea-table true) 
	  (.setVisible (:frame ea-table-gui) true))))

  (alter-var-root
   #'forex.interface.gui/gui-key-map
   merge {\v #'display-ea-table})
#+end_src

#+srcname:interface-gui
#+begin_src clojure :tangle src/forex/interface/gui.clj
  ;;(clojure.core/use 'nstools.ns)
  (ns forex.interface.gui
    (:require swank.swank)  
    (:use
     forex.util.general
     forex.util.log
     forex.module.ea forex.util.general
     clojure.contrib.miglayout forex.util.emacs 
     forex.util.gui forex.interface.tray)
    (:import 
     (java.awt Dimension Font event.MouseListener
	       event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
     (javax.swing JComboBox JPopupMenu JMenuItem
		  ImageIcon SwingConstants
		  table.AbstractTableModel 
		  JScrollPane JTable
		  JFrame JPanel JTextField JLabel JButton JFileChooser
		  SwingUtilities)))
  ;;TODO: all action listeners should be vars for maximum flexibility - because sometimes it all goes away!

  ;;Useful User Vars
  (defonce gui nil) 
  (defonce toplevel nil)
  (defn message [msg & args]
    (when-let [it (:status gui)]
      (.setText it (apply format msg args))))

  ;;LOADING EAS
  (defonce prev-load-file (atom nil))
  (defn on-load-eas []
    (let [fileopen (if @prev-load-file (JFileChooser. @prev-load-file) (JFileChooser.))
	  ret (.showDialog fileopen nil "Load")] 
      (if (= ret JFileChooser/APPROVE_OPTION)
	(let [file (.getSelectedFile fileopen)]
	  (with-out-str+ out (if-let [it (load-eas file true)] (message "loaded %s eas" it) (inform (str out))))
	  (reset! prev-load-file (.getParentFile file))))))

  ;;SAVING EAS
  (defonce prev-save-file (atom nil))
  (defn on-save-eas []
    (message "saving ...")
    (let [fileopen
	  (if @prev-save-file (JFileChooser. @prev-save-file) (JFileChooser.))
	  ret (.showDialog fileopen nil "Save")]
      (if (= ret JFileChooser/APPROVE_OPTION)
	(let [file (.getSelectedFile fileopen)]
	  (reset! prev-save-file (.getParentFile file))
	  (if-let [it (save-eas file)]
	    (message "saved %s eas" it)
	    (inform "unable to acquire ea write lock in order to save all eas")))))) 
  (defn on-log []
    (message "open log file @ %s/.forex/" (System/getProperty "user.home"))) 
  ;;User Customization
  (defhook gui-on-exit-hooks) 
  (defhook gui-create-pre-hook)
  (defhook gui-create-post-hook)
  (defvar swank-port 4005) 
  (defvar gui-image "pictures/clojure.gif")
  (defvar gui-icon-image "pictures/clojure.gif")
  (defvar gui-window-image "pictures/clojure.gif")

  (defvar gui-key-map 
    {\l #'on-log  
     \s 
     #(do
	(swank.swank/start-repl swank-port)
	(message "started swank on port %s" swank-port))})
  (defn on-restart-eas []
    (dorun (map restart @*eas*))
    (message "restarted %s eas" (count @*eas*))) 
  (defvar
    gui-menu-items
    [{:name "new ea" :key \n}
     {:name "save eas" :action #'on-save-eas}
     {:name "load eas" :action #'on-load-eas}
     {:name "view eas" :key \v} 
     {:name "log" :key \l :action #'on-log}
     {:name "start swank" :key \s}
     {:name "restart eas" :key \r :action #'on-restart-eas} 
     {:name "load forex-user" 
      :action #(try       
		 (message "loading ...")
		 (require :reload 'forex-user)
		 (message "loaded forex-user")
		 (catch Exception e
		   (message "failed to load forex-user")
		   (inform "failed to load forex-user %s" e)))}
     {:name "preferences" :key \p}])
  (defvar gui-frame-title "clj-forex")
  (defvar gui-reminder-visible true) 
  ;;;;
  ;;;
  (defn jframe [title]
    (doto
	(JFrame. title)
      (.setIconImage (create-image gui-window-image))))

  (defn- get-fn [a] (if (var? a) (var-get a) a))
  (defn on-key [e] 
    (when-let [it (get-fn (get gui-key-map (.getKeyChar e)))]
      (try (when (fn? it) (it))
	   (catch Exception e
	     (.printStackTrace e)
	     (severe e))))) 
  (defn add-menu-item [parent {:keys [name key action]}]
    (let [item (JMenuItem. (str name " (" key ")"))]
      (add-action-listener 
       item (or (and (not action) (bound-fn
				   [e]
				   (let [key-map-fn (get-fn (get gui-key-map key))]
				     (when (fn? key-map-fn) (key-map-fn)))))
		(bound-fn [e] (thread (action))))) ;;no e
      (.add parent item)
      item)) 
  (defn on-popup [e] 
    (try
      (let [menu (JPopupMenu.)]
	(dorun (map #(add-menu-item menu %) gui-menu-items))
	(.show menu
	       (.getComponent e)
	       (.getX e) (.getY e)))
      (catch Exception e (println e))))
  (defn on-exit [icon] 
    (if (empty? gui-on-exit-hooks)
      (remove-system-icon icon)
      (run-hook-with-args gui-on-exit-hooks icon)))
  (defn on-click [icon]
    (.setVisible (:frame toplevel) true))
  (defn gui-make-icon []
    (system-icon
     {:image gui-icon-image
      :on-click  on-click 
      :on-exit on-exit}))

  (defn new-gui []
    (alter-var-root #'gui (constantly nil))
    (alter-var-root #'toplevel (constantly nil))
    (run-hooks gui-create-pre-hook)
    (let [icon (gui-make-icon)
	  image (if (string? gui-image) (create-icon gui-image))
	  panel
	  (doto (miglayout  
		 (JPanel.)  :column "center" 
		 (JLabel. (if image image ""))  "width 245!" "span,growx,pushx" :wrap 
		 (JComboBox. (into-array String @*ea-registry*))
		 {:id :selector} "span,growx,pushx"  :wrap
		 (doto (JLabel. "<html>n = new ea<br>v = view eas<br>l = log<br>s = start swank<html>") (.setHorizontalAlignment SwingConstants/CENTER))

		 {:id :reminder} :wrap
		 (doto (JLabel. "")
		   (.setFont (Font. "SansSerif" Font/ITALIC 12)))
		 {:id :status} "h 20!" "growx,align left,span"))  
	  frame (doto (jframe gui-frame-title)
		  (.setDefaultCloseOperation JFrame/HIDE_ON_CLOSE) 
		  (.add panel)
		  (.pack)) 
	  {:keys [selector reminder view]} (components panel)] 
      (when-not gui-reminder-visible (.setVisible reminder false))
      ;; (add-action-listener selector (bound-fn* on-selector))
      (dorun (map (fn [obj]
		    (add-key-listener obj #'on-key)
		    (add-popup-listener obj #'on-popup))
		  (conj (vals (components panel)) panel)))
      (alter-var-root  #'gui (constantly (components panel)))
      (alter-var-root #'toplevel (constantly {:frame frame :panel panel
					      :icon icon}))
      (run-hooks gui-create-post-hook)
      frame))


  (defn add-ea-registry-watch []
    (add-watch
     *ea-registry* "registry-add"
     (bound-fn [key ref old new] 
       (when-let [it (:selector gui)]
	 (.removeAllItems it)
	 (dorun (map #(.addItem it %) new))))))

  (defn invoke-new-gui
    ([] (invoke-new-gui ""))
    ([msg] 
       (invoke-later
	(when (:icon toplevel)
	  (remove-system-icon (:icon toplevel)))
	(when (:frame toplevel)
	  (.setVisible (:frame toplevel) false))
	(new-gui)
	(.setVisible (:frame toplevel) true) 
	(add-system-icon (:icon toplevel)) 
	(when msg (message msg))
	(add-ea-registry-watch))))
#+end_src
 
#+srcname:interface-main
#+begin_src clojure :tangle src/forex/interface/main.clj
  (ns forex.interface.main
    (:require swank.swank)
    (:use forex.interface.gui forex.interface.ea-table forex.interface.ea-new)
    (:use forex.util.emacs forex.util.gui forex.interface.tray))

  (defn on-system-exit [icon]
    (when (prompt (format "Do you really want to exit %s?
  This will stop all running expert advisors." gui-frame-title))
      (System/exit 0)))

  (defn -main [& args]
    (let [user-exception 
	  (try
	    (require 'forex-user) 
	    nil
	    (catch Exception e 
	      (.printStackTrace e)
	      e))] 
      (add-to-list  
       #'gui-on-exit-hooks on-system-exit)
      (invoke-new-gui (when user-exception 
			"error when loading forex-user: check log"))))
#+end_src

#+srcname:interface-tray
#+begin_src clojure :tangle src/forex/interface/tray.clj
  (ns forex.interface.tray
    (:use forex.util.gui)
    (:import                        
     (javax.swing JFrame)
     (java.awt Toolkit SystemTray  EventQueue TrayIcon TrayIcon$MessageType PopupMenu MenuItem)
     (java.awt.event ActionListener)))

  (defn remove-system-icon [icon] (.remove (SystemTray/getSystemTray) icon))
  (defn- setup-popup-menu
    ([menu icon] (setup-popup-menu menu icon (constantly true)))
    ([menu icon on-exit]
       (let [exit (MenuItem. "Exit")]
	 (add-action-listener
	  exit (if on-exit
		 (bound-fn [e] (try
				 (on-exit icon)
				 (catch Exception e
				   (.printStackTrace e)
				   (println "ERROR IN ON-EXIT %s" e))))
		 (fn [e] (remove-system-icon icon))))
	 (.add menu exit)
	 menu)))

  (defn system-icon [{:keys [image on-exit on-click on-exit]}]
    {:pre [(string? image)]}
    (let [menu (PopupMenu.)
	  tray-icon
	  (doto (TrayIcon. (.getImage (Toolkit/getDefaultToolkit) image)
			   nil menu)
	    (.setImageAutoSize true))]
      (setup-popup-menu menu tray-icon on-exit) 
      (when on-click (add-action-listener tray-icon (bound-fn [e] (try (on-click tray-icon) (catch Exception e (println "ERROR IN ON-CLICK %s" e))))))  
      tray-icon)) 
  (defn add-system-icon [icon] (.add (SystemTray/getSystemTray) icon) icon)

  (defn icon-info
    ([icon txt] (icon-info icon "info" txt))
    ([icon caption txt] (.displayMessage icon caption txt TrayIcon$MessageType/INFO)))
  (defn icon-warning
    ([icon txt] (icon-warning icon "warning" txt))
    ([icon caption txt] (.displayMessage icon caption txt TrayIcon$MessageType/WARNING)))
  (defn icon-error
    ([icon txt] (icon-error icon "error" txt))
    ([icon caption txt] (.displayMessage icon caption txt TrayIcon$MessageType/ERROR)))

  ;;(def icon (add-system-icon (system-icon {:image  "/home/seth/Desktop/clojure.gif" :on-click (fn [_] (println "HI"))})))
#+end_src
  
** User 
#+srcname:forex_user
#+begin_src clojure :tangle src/forex_user.clj
  ;;forex_user is the ns in which customization will occur

  (clojure.core/use 'nstools.ns)
  (ns+ forex-user 
       (:clone forex.default)
       (:use forex.interface.gui forex.util.log clj.io))
  (require :reload 'forex.examples.timeout-ea.timeout-ea)
  ;;(require :reload-all 'forex.interface.main)
  (when-not (backend/alive?)
    (backend/start))

  (when-not log-file
    (setq forex.util.log/log
	  (new-logger (.replaceAll
		       (format "log_%s.txt" (now)) ":" "_"))))


  ;;ALL ABOUT AUTOSAVING
  (defvar ea-auto-save-minutes  5)
  (defvar ea-auto-save-file
    (let [file (format "%s/.forex/auto/ea-auto-save"
		       (System/getProperty "user.home"))]
      (make-parents file)
      file))  
  (defonce ea-auto-save-thread (doto (thread
				      (loop []
					(sleep (* 60 ea-auto-save-minutes))
					(when-not (empty? @*eas*)
					  (save-eas ea-auto-save-file))
					(recur)))
				 (.setName "ea auto save")))

  (add-to-list #'ea-on-exit-hook #(when-not (empty? @*eas*) (save-eas ea-auto-save-file)))
  (add-to-list #'ea-on-start-hook #(when-not (empty? @*eas*) (save-eas ea-auto-save-file)))

  (defonce ea-shutdown-hook (Thread. #(save-eas ea-auto-save-file 500)))
  (add-shutdown-hook ea-shutdown-hook)
  ;;;



  (comment 
    (setq gui-frame-title "MINE!"
	  gui-reminder-visible true))
#+end_src

** Templates
#+source: template
#+begin_src clojure :tangle src/forex/default.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.default
       (:clone clj.core)
       (:use forex.util.general)
       (:use forex.util.core
	     forex.util.emacs
	     forex.util.log) 
       (:use forex.module.error
	     forex.module.ea
	     forex.module.indicator
	     forex.module.account forex.module.account.utils
	     [clj-time.core :exclude [extend start]])
       (:require
	[forex.backend.mql.socket-service :as backend]))
#+end_src

#+source: gui-template
#+begin_src clojure :tangle src/forex/gui.clj 
  (clojure.core/use 'nstools.ns)
  (ns+ forex.gui 
       (:clone clj.core)
       (:import (javax.swing JScrollPane JFrame JPanel JTextArea
			     JLabel JButton SwingUtilities))
       (:use forex.util.general forex.util.gui clojure.contrib.miglayout)
       (:use forex.util.core
	     forex.util.emacs
	     forex.util.log)  
       (:use forex.module.error
	     forex.module.ea
	     forex.module.indicator
	     forex.module.account forex.module.account.utils
	     [clj-time.core :exclude [extend start]])
       (:require
	[forex.backend.mql.socket-service :as backend]))
#+end_src

** Examples
Notice that examples are right now just examples, they arent particularly
profitable, they are examples of using clj-forex. I decided to release
them without thoroughly testing so that one can see an early look of how to
use clj-forex....

#+source: timeout-ea
#+begin_src clojure :tangle src/forex/examples/timeout_ea/timeout_ea.clj
  ;;forex.examples.timeout-ea : ea which manages the orders of a trade
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.timeout-ea.timeout-ea
       (:clone forex.gui) 
       (:use forex.examples.timeout-ea.utils
	     forex.interface.gui)
       (:import (javax.swing JScrollPane)))
  (register-ea)
   ;;ea vars   
  (defvar state (atom :timeout))
  (defvar end-time)
  (defvar order) 
  ;; 
  (declare timeout break-even trail)

  ;;TODO: when we order, and modify fails, how do we get the error? later :)...
  (defn init [{:keys [type sl price hour]}]
    (aif (order! {:type type :sl sl :price price
		  :lots (* (mode-minlot) 2)})
	 {#'end-time (plus (now) (hours hour))
	  #'order (atom-hash it)} 
	 (:e it))) 

  (defn start [args]
    (cond
     (close? order) (exit "order is now closed")
     (= @state :timeout) (timeout args)
     (= @state :break-even) (break-even args)
     (= @state :trail) (trail))) 

  (defn timeout [_]
    (cond
     ;;changed to market
     (market? order)
     (do (reset! state :break-even) (out "changed to break even"))
     ;;entry order reach sl 
     (if (sell? order) (> (close) (:sl order)) (< (close) (:sl order)))
     ;;TODO: reliable delete????
     (awhen (delete! order) (exit "entry order reached sl. deleting ..."))
     ;;timed out
     (after? (now) end-time)
     (awhen (delete! order) (exit "order timed out"))))

  (defn break-even [{:keys [sl tp2 tp1]}]
    (if (hit? order tp1)
      (do (out "closing to half ...")
	  (awhen (-> (modify! order {:sl (:price order) :tp tp2})
		     (close! (lot (/ (:lots order) 2))))
		 (out "setting to trail") (reset! state :trail)))
      (modify! order {:sl sl})))

  (defn hh [a]
    (apply max (map high (range 1 (inc a)))))
  (defn ll [a]
    (apply min (map low (range 1 (inc a)))))
  (defn trail []
    (modify! order {:sl (omax order (:sl order) (if (sell? order) (hh 3) (ll 3)))})) 
  ;;;GUI
  (defn init-gui [] 
    (let [panel (JPanel.) text (JTextArea. 20 30)
	  frame (jframe "timeout ea")]
      (doto frame
	(.add (miglayout
	       panel :layout "center" :column "center" :row "center"
	       (JLabel. "paste email text") :wrap
	       (JScrollPane. text) "span,grow" :wrap
	       (doto (JButton. "ok")
		 (add-action-listener
		  (fn [e] 
		    (let [parsed (match-method (.getText text))]
		      (if parsed
			(when (prompt "is order %s ok?" parsed)
			  (with-out-str+ out
			    (if-not (run parsed) 
			      (inform "failed to run ea %s" (str out))
			      (.setVisible frame false)))) 
			(inform "failed to match input text"))))))
	       "w 50%"
	       (doto (JButton. "cancel")
		 (add-action-listener (fn [_] (.setVisible frame false))))
	       "w 50%"))
	(.pack)
	(.setVisible true))))
#+end_src
  
#+source: timeout-ea-utils
#+begin_src clojure :tangle src/forex/examples/timeout_ea/utils.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.timeout-ea.utils
       (:clone forex.default)
       (:use forex.util.general)) 

  (defn price
    ([val] (price val (env :symbol)))
    ([val symbol] 
       (* (mode-tickvalue symbol) (point val)))) 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (def method-regex
    (re-pattern (.replaceAll
		 (str "(?i)\\s*(Propulsion|Pip Reactor|Impulse|Spring)\\s+Method"
		      ".+running on (\\w+/\\w+)"
		      ".+generated a (Buy|Sell) Signal @ (\\d{0,15}\\.\\d{0,15})"
		      ".+Stop @ (\\d{0,15}\\.\\d{0,15})"
		      ".+(?:1st|First) Limit @ (\\d{0,15}\\.\\d{0,15})"
		      ".+(?:2nd|Second) Limit @ (\\d{0,15}\\.\\d{0,15})") 
		 "\\s+" "\\\\s+")))

  (defmacro catch-un [& body]
    `(try (do ~@body) (catch Exception e# (warn "caught unexpected error: %s" e#))))

  (defn match-method [s]
    (when s 
      (debugging "Matching Profit Multiplier Trade: "
		 (catch-un 
		  (when-let [it (first (re-seq method-regex (.replaceAll s "[\\r\\n]+" " ")))]
		    (let [[method-type symbol type price stop tp1 tp2] (rest it)
			  method (.toLowerCase method-type)]
		      {:method method
		       :hour (if (= method "spring") 4 12)
		       :symbol (.replaceAll symbol "/" "")
		       :type (condp = (.toLowerCase type)
				 "buy" :buy-stop
				 "sell" :sell-stop)
		       :price (Double/parseDouble price)
		       :sl (Double/parseDouble stop)
		       :tp1 (Double/parseDouble tp1)
		       :tp2 (Double/parseDouble tp2)}))))))
#+end_src
 
#+source: renko
#+begin_src clojure :tangle src/forex/examples/renko/renko.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.renko.renko
       (:clone forex.default) 
       (:use forex.util.general)) 
  (register-ea) 
  ;;TODO: *ea-stop* already refers to: #'forex.module.ea/*ea-stop* in namespace: forex.default 
  ;;TODO: on GBP/JPY, why did it enter so late???? 
  ;;TODO!!!: speed up ns+ by alot! and dont have it automatically reload it, please!!!

  ;;TODO: test reusing of account.utils
  ;;TODO: defaults per currency
  (def ^{:var true} state (atom :monitor)) 
  (def ^{:var true} order (atom-hash))
  (def ^{:var true} trail-time-period 5)

  (def main (partial vma [2 2 100 1]))
  (def signal (partial vma [2 2 1 1] ))
  (def middle (partial vma [2 2 26 1]))
  (def support (blazan-dynamic-stop [150 70 1 10000] 1))
  (def resistance (blazan-dynamic-stop [150 70 1 10000] 0))

  ;;UTILS
  (defn up? [signal i]
    (let [diff (- (signal i) (signal (+ i 1)))]
      (if (>= diff 0) 
	diff
	false))) 
  (defn down? [signal i]
    (let [diff (- (signal i) (signal (+ i 1)))]
      (if (<= diff 0)
	diff
	false)))    
  (defn reset []
    (reset! state :monitor) (reset! order nil) (out "order closed"))
  (defn calculate-lots [] (lot (* 0.01 (/ (account-balance) 100))))
  ;;TODO: use symbol in o for profit! 
  (defn profit
    ([o] (wenv {:symbol (or (:symbol o) (env :symbol))} (profit o (close) (:break o))))
    ([o a] (profit o a (:break o)))
    ([o a b] (point (o-- o a b))))

  ;;TODO: exit half when cross middle? enter half more when recross? 
  ;;OPEN CONDITION 
  (defn open-condition [i]  
    (if-let [[dir i] (cross? signal main i)]
      (or (and (= dir :buy) (> (signal i) (middle i)) {:type :buy :i i :category  :long :state :init})
	  (and (= dir :sell) (< (signal i) (middle  i)) {:type :sell :i i :category :long :state :init}))
      (when-let [[dir i] (cross? signal middle i)]
	(or (and (= dir :buy) ;;TODO: better reentry , oui? slope? 
		 (or (and (< (middle i) (main i)) (> (middle (+ i 10)) (main (+ i 10)))
			  {:type :buy :i i :category :long :state :init}) ;;the dip
		     (and (<= (Math/abs (- (main i) (middle i))) (pip 20)) (or (up? main i) (up? main (+ i 1)))
			  (> (middle i) (main i)) 
			  ;;{:type :buy :i i :category :scalp}
			  nil
			  ))) ;;thin 
	    (and (= dir :sell)
		 (or (and (> (middle i) (main i)) (< (middle (+ i 10)) (main (+ i 10)))
			  {:type :sell :i i :category :long :state :init}) ;;the dip
		     (and (<= (Math/abs (- (main i) (middle i))) (pip 20)) (or (down? main i) (down? main (+ i 1)))
			  (< (middle i) (main i))
			  ;;{:type :sell :i i :category :scalp}
			  nil
			  )))))))   

  ;;ORDER MANAGEMENT
  (defmulti close-condition (fn [o & args] (:category o)))
  (defmulti check (fn [o & args] (:category o)))
  ;;;SCALP ORDER MANAGEMENT
  (defn should-close? [{:keys [type] :as o}] 
    (cond
     (= type :buy)
     (or (< (signal 1) (main 1)) (< (signal 1) (middle 1)))
     (= type :sell)
     (or (> (signal 1) (main 1)) (> (signal 1) (middle 1)))))

  ;;;LONG ORDER MANAGEMENT
  ;;TODO: take profit via price action !!!!; if GBPJPY is owning, why not trail on 1 minute level? basically, alot of this take profit stuff and entering
  ;;and exiting is based on a variety of conditions! Im sensing some AI like programming taking place! doesn't need to be ai, but how about using
  ;;programming which takes into account the context? see http://web.media.mit.edu/~push/ and the phd thesis EM-ONE: An Architecture for Reflective Commonsense Thinking

  (defn cci-close?
    "This is a tight virtual stop on the five minute level. 
     For buy, if cci>100, set cross-sl to previous middle value.
     If signal(1) is less than cross-sl, then exit. Opposite for sell"
    [{:keys [type state] :as o} period] 
    (when (= state :trail) 
      (wenv {:period period}    
	    ;;modify cross-sl 
	    (when (or (> (cci 30 1) 100) (< (cci 30 1) -100))
	      ;;we will not update the cross-sl so that it will generate  a close signal, this would be bad!
	      (when (or (and (buy? o) (> (signal 1) (middle 1)))
			(and (sell? o) (< (signal 1) (middle 1))))
		(modify! o {:cross-sl (middle 1)})))  
	    ;;check close condition
	    (when-let [cross-sl (:cross-sl o)]
	      (or (and (buy? o) (<= (signal 1) cross-sl)) 
		  (and (sell? o) (>= (signal 1) cross-sl))))))) 

  (defmethod close-condition :long [{:keys [type state] :as o}] 
    (if (= state :init)
      (and (should-close? o)
	   (do (out "init close") true)) ;;TODO: GBPUSD screwed up for -30 pips how to effectively close this? how bout pick better entry poitns? or dont pick exhaustion
      (or (and (cond
		(= type :buy)
		(< (signal 1) (main 1))
		(= type :sell)
		(> (signal 1) (main 1)))
	       (do (out "cross close") true))
	  (and (cci-close? o trail-time-period) (do (out "cci close") true))))) 

  (defmethod check :long [o]
    (when (and (>= (profit o) 20) (not (= (:state o) :trail))) (modify! o {:state :trail}) (out "changed to trail"))
    ;;actual sl the server sees. this is a safety stop, in case our ea gets screwed up, turns off, etc.
    (when (or (= (:sl o) 0) (= (:state o) :trail))
      (modify! o {:sl (omax o (:sl o) (o- o (main 1) (pip 20)))})))  
  ;;(run)
  ;;MAIN  
  (defn gobble [o] 
    (if (close? o) 
      (reset)
      (awhen-not (and (close-condition o) (close! o))
		 (check o))))

  (defn monitor []  
    (when-let [{:keys [type category] :as o} (open-condition 0)] 
      (awhen (order! (merge o  {:type type :lots (calculate-lots)})) 
	     (reset! order it)
	     (reset! state :gobble)   
	     (out "entered %s %s order" type category))))

  (defn start [args] 
    (cond
     (= @state :monitor) (monitor)
     (= @state :gobble) (gobble order)))

  (defn vars [ea] (:vars ea))
  (defn getv [vvar ea] (get (:vars ea) vvar))
#+end_src
 
