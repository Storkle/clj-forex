#+TITLE: CLJ-FOREX
#+Author: Seth Burleigh
#+Babel: :comments link :noweb yes :mkdirp yes
       
* Introduction
** What is forex?
Forex is a currency trading market. But you probably know all about forex, since you're here! If not, read up on it! \\
+ [[http://en.wikipedia.org/wiki/Foreign_exchange_market][Wiki article - OK]]
+ [[http://www.fxcm.com/metatrader.jsp][FXCM Retail Broker Free Metatarder Terminal -  get demo account and see what forex trading is first hand!]]
** What is clj-forex?
Clj-forex is an in progress effort to create a non-graphical backend to various forex trading backends. Right now Metatrader is the focus. 
The ultimate goal of clj-forex is to create a robust library to allow the creation of EA (expert advisors) in the scripting language clojure. Expert advisors
are programs which automatically trade the market, performing sell/buy orderes, changing stoplosses, using technical indicators, etc. They are useful for
both automating parts of manual trading systems (performing trailing stops, expiration of market orders) and also for full out automated trading.

Indicators will be calculated java side using price bars retrieved from the backends. Integration of indicator data to various gui backends (i.e. at this time,
Metatrader) will be supported. The only purpose of the forex backend is to allow access to spreads, current price, ability to buy/sell, etc. 
** The Difference
Im not sure why noone has done this before, but integration of a scripting language to create eas is, in my opinion, vital. 
Integration of a lisp-like dialect, like clojure, will allow much more rapid creation and prototyping of eas. 
This combined with easy access to any java library (clojure is implemented on the java virtual machine) makes for a winning combination! 
Things like neural networks, database, and other such ‘advanced’ concepts can now be much more easily integrated than if we had used [[http://book.mql4.com/][mql4]].

Its like an artist! Give an artist more efficient tools in the toolbox and who knows what can be created! [And clojure is fun to learn anyways!]
** Where's the code??
This file is the code (clojure, anyways). The code is untangled using the
keystroke C-c C-v t in emacs when this file is open. While currently most
of the code is simply in the Code section, it will all eventually be explained
in the [[http://groups.google.com/group/clojure/browse_thread/thread/664a1d305f32ab90][literate programming]] manner.
* Development Tools
org-mode in emacs + babel is used. Currently code is one ns per one code block
format. Therefore, i use the below code, along with the latest git repository
for org-mode (needed!). I then hit f8 to detangle all my changes to my org file.
f9 can be used to jump from source code to location in org file. 
#+begin_src emacs-lisp
  ;;change to location of your clj-forex.org
  (defvar clj-forex-file "/home/seth/Dropbox/.rep/clj-forex/clj-forex.org")
  
  (defmacro with-file (file &rest body)
    "open up file in a buffer, and set current buffer to it"
    `(with-current-buffer (find-file-noselect ,file t) ,@body))
  
  (defun out-files (org-file)
    (let (args)
      (org-babel-map-src-blocks org-file
        (let ((tangle-file (with-temp-buffer
                             (insert header-args)
                             (goto-char (point-min))
                             (if (re-search-forward ":tangle[ ]+\\([^ ]+\\)" nil t)
                                 (match-string 1)
                               nil))))
          (when tangle-file (push tangle-file args))))
      args))
  
  (defmacro with-cd (dir &rest body)
    (let ((current (gensym)))
      `(let ((,current default-directory))
         (cd ,dir)
         (unwind-protect (progn ,@body) (cd default-directory)))))
  
  (defun detangle ()
    (interactive)
    (save-excursion
      (let* ((org-file clj-forex-file)
             (out (out-files org-file))
             (amount 0))
        (with-cd (file-name-directory org-file)
                 (dolist (file out)
                   (with-file
                    file
                    (goto-char (truncate (/ (+ (point-min) (point-max)) 2)))       
                    (incf amount (org-babel-detangle)))))
        (message "Detangled %s source blocks" amount))))
  (global-set-key (kbd "<f8>") 'detangle)
  (global-set-key (kbd "<f9>") 'org-babel-tangle-jump-to-org)
  (setq org-src-fontify-natively t)
#+end_src

Given the tangled output of the source files, which basically tags the
code so that it can detangle it and jump back to the org file, we can
technically work in something other than emacs if we have a clojure tool
to detangle and tangle. However, this is not yet implemented. Also, it is planned
to give noweb support for babel so that i can break up the blocks.

Yes, currently it is not very development start friendly. That will change!
* From Ideas to Implementation - Metatrader Backend
* Code
** Backend
*** MQL Socket Service
#+srcname:mql-socket-service
#+begin_src clojure :tangle src/forex/backend/mql/socket_service.clj
  ;;forex.backend.mql.socket-service: provide background sockets which allow us to connect with metatrader. Provides functions to interact with the background socket

  ;;todo: bug with stopping all and then stopping again! so bug with stop..
  (clojure.core/use 'nstools.ns)
  (ns+ forex.backend.mql.socket-service
       (:clone clj.core) 
       (:require
	[utils.fiber.mbox :as m]
	[clojure.contrib.logging :as l])
       (:use
	emacs 
	forex.util.general forex.util.zmq forex.util.log
	forex.util.spawn utils.general))

  ;;TODO: 3ms or so per request, a little slow...
  ;;also, unfortunately, if we add more servers, speed doesn't increase linearly. so the bottleneck is in the clojure code ... a better designed socket service should really be made.
  ;; in addition, if servers drop out, we will be waiting forever for them. this is bad.

  (defvar mql-socket-recv-address "tcp://127.0.0.1:3000")
  (defvar mql-socket-send-address "tcp://127.0.0.1:3005")
  (defvar mql-socket-pub-address "tcp://127.0.0.1:3010")

  ;;utils
  (defonce- *msg-id* (atom 0))
  (defn- msg-id []
    (str (swap! *msg-id* inc)))
  (defmacro catch-unexpected [& body]
    `(try (do ~@body)
	  (catch Exception e# (.printStackTrace e#) (warn e#))))

  ;;socket service
  ;;TODO: send id then message
  (defn- mql-recv [ids msg] 
    (catch-unexpected   
     (let [key (first msg)
	   msg-ask (@ids key)]
       (if-not (satisfies? PWait msg-ask)
	 (warn "Ignoring invalid msg: %s" msg)
	 (do 
	   (deliver msg-ask (second msg))
	   (swap! ids dissoc key))))))
  (defvar *ids* (atom {}))
  (comment
    (defn unblock []
      (doall (map #(deliver % (Exception. "unblock")) (keys *ids*)))))


  (defn- socket-service-match [events send receive]
    (match  
     (first events)
     [local "STOP"] (do (info "closing ...") "stop")  
     [local ["REQUEST" ?msg ?askin]]  
     (if-not (satisfies?  PWait askin)
       (warn "Ignoring invalid REQUEST which does not contain a PWait argument %s %s" 
	     msg askin) 
       (let [id (msg-id)  
	     result  (.snd send (str id " " msg) +noblock+)]
	 (if-not result  
	   (do  
	     (warn "failed to queue request %s: are any metatrader scripts alive?"
		   msg)
	     (catch-unexpected
	      (deliver askin (Exception. "socket service down"))))
	   (swap! *ids* assoc id askin))))  
     [receive ?msg] (mql-recv *ids* msg) 
     ?msg (warn "Ignoring invalid message %s" msg)))

  ;;TODO: weird bugwhen stopping everything with an ea.

  (defn spawn-mql-socket-service
    []  
    (debugging
     "MQL Socket Service: " 
     {:pid 
      (spawn-log  
       #(with-open [send (doto (new-socket +push+)
			   (.bind mql-socket-send-address))
		    receive (doto (new-socket +pull+)
			      (.bind mql-socket-recv-address))]
	  (loop [events (event-seq [receive local])]
	    (when-not (= "stop" (socket-service-match events send receive))
	      (recur (rest events))))))})) 

  ;;global socket service
  (defonce- *s* (atom nil))
  (defn alive? []
    (pid? (:pid @*s*))) 
  (defn start []
    (if (alive?)
      (warn "mql socket is already alive!")
      (reset! *s* (spawn-mql-socket-service))))
  (defn stop []
    (if (alive?)
      (! (:pid @*s*) "STOP")
      (warn "mql socket service is already stopped")))

  ;;interact with mql 
  (defn request [askin msg]
    (io!
     (if (pid? (:pid @*s*)) 
       (! (:pid @*s*) ["REQUEST" msg askin])
       (throwf "mql socket service is not alive"))))

  (defn receive
    ([msg] (receive msg nil))
    ([msg timeout]
       (let [askin (promise)]
	 (request askin msg)
	 (let [result (if (wait-for askin timeout) @askin)]
	   (cond
	    (instance? Exception result) (throw result)
	    result result
	    true (throwf "invalid result received %s" result))))))
#+end_src 
** Module 
*** Account
#+srcname:account-core
#+begin_src clojure :tangle src/forex/module/account/core.clj
  ;;forex.module.order.core - interface with mql backend
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.account.core
    (:clone clj.core)
    (:use utils.general emacs utils.fiber.spawn
	  forex.util.general
	  forex.module.error))

  (def- order
    {:buy 0 :sell 1 :buy-limit 2 :sell-limit 3 :buy-stop 4 :sell-stop 5})

  (def- color
    {:red 230 :yellow 65535 :green 65280 :blue 13749760
     :purple  16711935 :white 16777215 :black 0})

  (defn- get! [hash key]
    (if-let [it (hash key)]
      it
      (throwf "invalid key %s in hash %s" key hash)))

  ;;the below can throw errors - how to handle this? 
  (defn order-modify
    ([ticket price sl tp]
       (order-modify ticket price sl tp :blue))
    ([ticket price sl tp color_of]
       (receive
	(format "OrderModify %s %s %s %s %s"
		ticket price sl tp (get! color color_of)))
       ;;{:id ticket :price price :sl sl :tp tp :color color_of}
       ))

  (defn order-send
    ([symbol cmd volume price] (order-send symbol cmd volume price 0 0))
    ([symbol cmd volume price sl tp] (order-send symbol cmd volume price sl tp 3))
    ([symbol cmd volume price sl tp slip]
       (receive
	(format "OrderSend %s %s %s %s %s %s %s"
		symbol (get! order cmd)
		volume price slip sl tp))))

  (defn order-close-time [ticket]
    (receive-int (format "OrderCloseTime %s" ticket)))

  (defn order-close [ticket lots price slippage color_of]
    (receive  
     (format "OrderClose %s %s %s %s %s"
	     ticket lots price slippage (get! color color_of))))
  (defn order-delete [ticket]
    (receive (format "OrderDelete %s" ticket)))

  (defn market-info [symbol type]
     (receive-double (format "MarketInfo %s %s" symbol type)))

  (defn order-close-time [ticket]
    (receive-double (format "OrderCloseTime %s" ticket)))

  (defn order-type [ticket]
    (receive-double (format "OrderType %s" ticket)))

  (defn order-lots [ticket]
    (receive-double (format "OrderLots %s" ticket)))
#+end_src
 
#+srcname:account-utils
#+begin_src clojure :tangle src/forex/module/account/utils.clj
  (clojure.core/use 'nstools.ns)

  (ns+ forex.module.account.utils
    (:clone clj.core)
    (:use utils.general emacs  
	  forex.util.general
	  forex.module.error)
  ;;  (:require forex.module.error [forex.module.error :as err])
    (:require  [forex.module.account.core :as core]))


  ;;account common
  (defn- sym [a] (symbol (camel-to-dash a)))
  (defmacro- single [name] `(defn ~(sym name) [] (receive! ~name)))
  (defmacro- double-single [name] `(defn ~(sym name) [] (receive-double! ~name)))
  (defmacro- singles [& names] `(do ~@(map (fn [a] `(single ~a)) names)))
  (defmacro- double-singles [& names] `(do ~@(map (fn [a] `(double-single ~a)) names)))

  ;;none of the below singles or double-singles should throw a mql error - therefore, it is a bug if they do
  (singles 
   "AccountCurrency"
   "AccountCompany"
   "AccountServer" 
   "AccountName"
   "AccountNumber")

  (double-singles
   "AccountCredit"
   "AccountBalance"
   "AccountEquity"
   "AccountFreeMargin"
   "AccountLeverage"
   "AccountMargin"
   "AccountProfit"
   "OrdersTotal")
  ;;

  (defmacro- define-market-info [& args]
    `(do ~@(map (fn [[name num]]
		  `(defn ~(symbolicate "mode-" name)
		     ([] (~(symbolicate "mode-" name) (env :symbol)))
		     ([symbol#]
			(let [res# (core/market-info symbol# ~num)]
			  (if (e? res#)
			    (throwf "market-info error %s" (:e res#))
			    res#)))))
		(group args)))) 

  (define-market-info
    low 1
    high 2
    time 5
    bid 9
    ask 10
    point 11
    digits 12
    spread 13
    stoplevel 14
    lotsize 15
    tickvalue 16
    ticksize 17
    swaplong 18
    swapshort 19
    starting 20
    expiration 21
    trade-allowed 22
    minlot 23
    lotstep 24
    maxlot 25
    swaptype 26
    profitcalcmode 27
    margincalcmode 28
    margininit 29
    marginmaintenance 30
    marginhedged 31
    marginrequired 32
    freezelevel 33)

  (defn demo? []
    (if (re-find #"(?i)demo" (account-server))
      true
      false))

  (defn sell? [{type :type}]
    (or (= type :sell) (= type :sell-stop) (= type :sell-limit)))
  (defn buy? [{type :type}]
    (or (= type :buy) (= type :buy-stop) (= type :buy-limit)))
  (defn- to-big [num] (BigDecimal/valueOf (if (integer? num) (double num) num)))
  (defn lot 
    ([num] (lot num (env :symbol)))
    ([num symbol]
       (let [a (to-big num)
	     b (to-big (mode-minlot symbol))]
	 (* b (.intValue (/ a b))))))


  (defn- assert-order [order] (is? [(or (sell? order) (buy? order))]))

  (defn o-- [o & args]
    (assert-order o)
    (if (sell? o) (- (apply - args)) (apply - args)))

  (defn o+ [o & args]
    (assert-order o) 
    (if (sell? o) (apply - args) (apply + args)))
  (defn o- [o & args]
    (assert-order o)
    (if (sell? o) (apply + args) (apply - args)))

  (defn omax [order & args]
    (assert-order order)
    (let [args (filter #(not (zero? %)) args)]
      (if (empty? args)
	(or (:sl order) 0) 
	(apply (if (buy? order) max min) args))))

  (defn omin [order & args]
    (assert-order order)
    (let [args (filter #(not (zero? %)) args)]
      (if (empty? args)
	(or (:sl order) 0) 
	(apply (if (buy? order) min max)
	       args))))


  ;;TODO: change for 4 digit broker
  (defn digit []
    (let [pt (mode-point "EURUSD")]
      (cond
       (= pt 0.00001) 5
       (= pt 0.0001) 4
       true (throwf
	     "unexpected broker digits given mode-point of % on EURUSD" pt))))

  ;;TODO: check for valid symbol on all of this??
  (defn spread
    ([] (spread (env :symbol)))
    ([symbol]
       (let [d (digit) spread (mode-spread symbol)]
	 (cond
	  (= d 5) (/ spread 10)
	  (= d 4) spread))))

  (defn point
    ([pt] (/ pt (point)))
    ([]
       (let [d (digit)] 
	 (if (= d 5)
	   (* 10 (mode-point))
	   (mode-point)))))

  (defn pip [pt] (* (point) pt))
#+end_src

#+srcname:account-common
#+begin_src clojure :tangle src/forex/module/account.clj
  ;;TODO: unit test everything
  ;;TODO: create a new atom-hash on merging, etc????????
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.account
    (:clone clj.core)
    (:use utils.general emacs  
	  forex.util.general forex.util.log
	  forex.module.indicator
	  forex.module.error forex.module.account.utils)
    (:require forex.module.error [forex.module.error :as err])
    (:require  [forex.module.account.core :as core]))

  (defvar *account-warn-on-mql-error* true)

  (defn- account-warn
    ([err order] (account-warn err order ""))
    ([err order msg & args]
       (if *account-warn-on-mql-error* 
	 (do (warn "MQL error %s on order %s - %s" (:e err)
		   order (apply format msg args)) err)
	 err)))
  (defmacro- with-order [order & body]
    `(let [o# ~order]
       (if-not (= (:lots o#) 0)
	 (do ~@body)
	 (do (warn "attempting to change order %s with zero lots" o#)
	     o#)))) 

  (defn- >? [a] (and (number? a) (>= a 0)))

  (defmacro- default [& body] 
    `(binding [*default* @~#'err/*er*]
       ~@body))

  ;;TODO: do we need all of these assertions?
  (def- value-to-order-type
    {0 :buy 1 :sell 2 :buy-limit
     3 :sell-limit 4 :buy-stop
     5 :sell-stop}) 

  (defprotocol POrder
    (order-close-time [this])
    (order-type [this])
    (delete! [this] )
    (close! [this] [this new-lots])
    (modify! [this sl-tp-map])
    (order! [this])
    (open? [this]) (close? [this])
    (order? [this]) 
    (market? [this]) (entry? [this]))

  (defn- order-close-time* [{id :id}]
    (is? (string? id))
    ;;we dont need to know mql4 error codes for order close time
    (aif (core/order-close-time id) it -1)) ;;TODO: return 0 instead?
  (defn- order-type*  [order]
    (is? (string? (:id order)))
    (default
      (aif (core/order-type (:id order))
	   (value-to-order-type (int it)))))

  (defn- delete!* [{id :id lots :lots :as o}]
    (with-order o
      (if-not (= lots 0)
	(aif (core/order-delete id) (merge o {:lots 0}) it)
	o)))


  (defn- close!*
    ([o] (close! o 0))
    ([{:keys [price lots slip id symbol] :as order} new-lots]
       (with-order order
	 (is? [(string? id) (string? symbol) 
	       [price (pos? price)]
	       [(number? lots) (>= lots 0)]])
	 (is? (>= (- lots new-lots) 0))
	 (if-not (= new-lots lots)
	   (aif (core/order-close id (- lots new-lots)
				  (if (sell? order)
				    (ask symbol)
				    (bid symbol))
				  slip :blue)
		(merge order {:lots new-lots})
		(account-warn it order "invalid new lots %s" new-lots))
	   order))))

  ;;TODO: normalize so we dont get mql error 1?
  (defn- modify!* [order {:keys [sl tp] :as mod}]
    (with-order order
      (let [sl (or sl (:sl order) 0)
	    tp (or tp (:tp order) 0)
	    price (:price order)]
	(is? [sl tp price (>? sl) (>? tp) (pos? price)]) 
	(if-not (and (= sl (:sl order))
		     (= tp (:tp order)))
	  (aif (core/order-modify (:id order) (:price order) sl tp)
	       (merge order (merge mod {:sl sl :tp tp}))
	       (if (= (:e it) 1)
		 (merge order mod)
		 (account-warn it order "sl %s tp %s" sl tp)))
	  (merge order mod)))))  

  ;;TOODOs: how do we get map with defaults?
  (defn- verify-order [{:keys [slip symbol type price tp sl lots]
			:or {slip 3 sl 0 tp 0}}]
    (is? [(number? slip) (> slip 0) (integer? slip)]
	 "invalid order slip %s" slip)
    (is? [ (keyword? type) (number? lots)
	   (number? tp) (number? sl) (number? price)]) 
    (is? [ (string? symbol) (> lots 0)
	   (>= tp 0) (>= sl 0) (>= price 0)])  
    (cond
     (or (= type :sell) (= type :sell-limit) (= type :sell-stop))
     (is? (or (and (zero? sl) (zero? tp))
	      (and (zero? sl) tp (< tp price))
	      (and (zero? tp) sl (> sl price))
	      (and (< tp sl) (< tp price) (> sl price)))
	  "invalid %s order with sl/tp %s/%s with price of %s" type sl tp price)
     (or (= type :buy) (= type :buy-limit) (= type :buy-stop))
     (is? (or (and (zero? sl) (zero? tp))
	      (and (zero? sl) tp (> tp price))
	      (and (zero? tp) sl (< sl price))
	      (and (> tp sl) (> tp price) (< sl price)))
	  "invalid %s order with sl/tp %s/%s with price of %s" type sl tp price)
     true (throwf "invalid %s order with sl/tp %s/%s with price of %s"
		  type sl tp price))) 
  ;;TODO: change to make reliable and to work for ECN brokers and such
  ;;see http://forum.mql4.com/36608
  ;;TODO: what happens if second modify fails? how can programmer find this out?

  (defn- order!* [{:keys [symbol type price tp sl lots slip]
		   :as order
		   :or { symbol (env :symbol) sl 0 tp 0 slip 3}}]
    (let [price (or price (if (sell? order) (bid symbol) (ask symbol)))
	  order (merge 
		 {:symbol symbol
		  :slip slip}
		 (merge order {:sl 0 :tp 0 :id "" :price price}))]
      (with-order order    
	(verify-order order)
	(aif (core/order-send symbol type lots price 0 0 slip)
	     (let [result
		   (let [o (merge order {:id it})]
		     ;;now, use modify to change sl and tp
		     (aif (modify!* o {:sl sl :tp tp})
			  (merge o {:sl sl :tp tp})
			  o))
		   spread (spread)]
	       (merge result {:spread spread :break (o+ result price (pip spread))})) 
	     (account-warn it order))))) 

  (defn- open?* [order] 
    (default (= (order-close-time order) 0)))
  (defn- close?* [order]
    (not (open? order)))
  (defn- order?* [order]
    (not (nil? (order-type order))))   
  (defn- market?*
    "determine if order is market order"
    [order]
    (let [type (order-type order)]
      (or (= type :sell) (= type :buy)))) 
  (defn- entry?*
    "determine if order is entry order"
    [order]
    (let [type (order-type order)]
      (and type (not (or (= type :sell) (= type :buy))))))

  (extend clojure.lang.IPersistentMap
    POrder {:order-close-time order-close-time*
	    :order-type order-type*
	    :delete! delete!*
	    :close! close!*
	    :modify! modify!*
	    :order! order!*

	    :open? open?*
	    :close? close?*
	    :order? order?*
	    :market? market?*
	    :entry? entry?*})

  (extend-type forex.module.error.MqlError
    POrder
    (order! [this] this)
    (delete! [this] this)
    (close! [this] this)
    (modify! [this] this))

  (extend-type forex.util.general.AtomHash ;;clojure.lang.Atom
    POrder
    (order-close-time [this] (order-close-time @this))
    (order-type [this] (order-type @this))
    ;;(order! [this] (aif (order! @this) (do (reset! (.val this) it) this) it))
    (delete! [this] (aif (delete! @this) (do (reset! (.val this) it) this) it))  
    (close!
     ([this new-amount] (aif (close! @this new-amount) (do (reset! (.val this) it) this) it))
     ([this] (close! this 0)))
    (modify! [this sl-tp] (aif (modify! @this sl-tp) (do (reset! (.val this) it) this) it))
    (open? [this] (open? @this))
    (close? [this] (not (open? @this)))
    (order? [this] (order? @this))
    (market? [this] (market? @this))
    (entry? [this] (entry? @this)))
#+end_src
*** Ea
#+srcname:ea-common
#+begin_src clojure :tangle src/forex/module/ea.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.ea 
    (:clone clj.core)
    (:use utils.general forex.util.general
	  utils.fiber.spawn clojure.contrib.core)
    (:import clojure.lang.Atom)
    (:require [clj-time.core :as t])
    (:use emacs
     forex.util.log  
     forex.module.error 
     forex.module.indicator 
     forex.module.account))  
  (defn- get-fn [a] (if (var? a) (var-get a) a)) 
  (defonce *ea* nil)
  (defonce *args* nil) 
  (defmacro with-ea [[ea & name] & body]
    `(let [ea# ~ea]
       (debugging (format "%s %s:" ~(or (first name) "") (:name ea#))
		  (binding [*ea* ea# *args* (:args ea#)]
		    (wenv {:symbol (:symbol ea#) :period (:period ea#)}
			  ~@body)))))

  (deferror *ea-stop* [*clj-forex-error*] [message]
    {:msg (str "ea stop: " message)})


  (defn exit
    ([msg] (raise *ea-stop* msg))
    ([msg & args] (raise *ea-stop* (if (string? msg)
				     (apply format msg args)
				     (concat [msg] args)))))


  (defn- copy-atoms [map]
    (apply hash-map
	   (mapcat (fn [[key val]]
		     (list key
			   (if (instance? clojure.lang.Atom val)
			     (atom @val)
			     val)))
		   map)))
  ;;##ea implementation
  (defonce *eas* (atom []))
  (defn every [pred coll]
    (if (empty? coll)
      false
      (loop [a coll]
	(if (empty? a)
	  true
	  (if (not (pred (first a)))
	    false
	    (recur (rest a)))))))

  (defn query [m]
    (let [a (filter
	     (fn [ea]
	       (if (every (fn [[key val]]
			    (= val (get ea key)))
			  m) 
		 ea))
	     @*eas*)]
      (if (= (count a) 1) (first a) a)))
  (defn alive? [ea] (pid? (:pid ea)))

  (defmacro- catch-unexpected [prefix & body]
    `(try (do ~@body)
	  (catch Exception e#
	    (severe "%s - caught unexpected error %s" ~prefix e#))))

  (require 'clojure.contrib.error-kit)
  ;;TODO; how to create unbound var for error-kit???
  (defn ping [a] (! (:pid a) "ping"))
  ;;TODO: we need a monitor which pings and then sets something.... like in erlang
  (defn run-by-tick [{:keys [deinit init start] :as ea}]
    (with-ea [ea]
      (try
	(clojure.contrib.error-kit/with-handler
	  (loop [prev-close nil]
	    (sleep 1)
	    (when-not (match (? 0) "stop"  true "ping" (do (out "ping") nil)) 
	      (let [new-close (close)]
		(when-not (= new-close prev-close)
		  (let [func (get-fn start)]
		    (if (fn? func)
		      (func (:args ea))
		      (warn "%s is not a function. start cannot be called" func))))
		(recur new-close))))
	  (clojure.contrib.error-kit/handle *ea-stop* [message] (out "stopping ea ... %s" message))) 
	(catch Exception e 
	  (severe "stopping ea... caught exception %s" e)
	  (.printStackTrace e))
	(finally
	 (info "running deinit ...")
	 (catch-unexpected
	  "deinit" 
	  (let [de (get-fn deinit)]
	    (if (fn? de)
	      (de)
	      (warn "deinit %s is not a function. ignoring ...." de))))))))

  (defn- timeframe? [a] (number? a))
  (defrecord EA [name type ns init deinit start symbol period args pid run vars])

  (defn- constant-map [& args] {})
  (defn- constant-true [& args] {})
  (defn new-ea
    ([] (new-ea {}))
    ([{:keys [ns symbol period run args] :or {symbol (env :symbol)
						 run run-by-tick
						 period (env :period)}}]
       (let [ns (cond
		 (nil? ns) *ns*
		 (symbol? ns) (find-ns ns)
		 (string? ns) (find-ns (symbol ns))
		 true ns)]
	 (is? (ns? ns)) 
	 (let [name (str (ns-name ns))
	       start (ns-symbol 'start ns)
	       init (or (let [fn (ns-symbol 'init ns)]
			  (if (get-fn fn) fn))
			constant-map)
	       deinit (or (let [fn (ns-symbol 'deinit ns)]
			    (if (get-fn fn) fn))
			   constant-true)]
	   (is? [(fn? (get-fn init)) (fn? (get-fn deinit)) (string? name)
		 (string? symbol) (fn? run) (timeframe? period)])
	   (EA. (format "%s %s, %s" name symbol period) name ns
		init deinit start symbol period (or args {})
		nil run
		(copy-atoms (ns-vars ns))))))) 

  ;;how to get it to access actual var? as long as we dont use set!
  (defmethod clojure.core/print-method EA [o w]
    (.write w  (format "<EA \"%s\" %s %s |%s|>"
		       (:name o)
		       (if (pid? (:pid o)) true false)                 
		       (:args o) (:vars o))))

  ;;TODO: pid without spawn!!

  (defn run-start [ea]
    (with-ea [ea "START"]
      (with-bindings (:vars ea)
	(let [new-ea (merge ea {:pid (spawn #((:run ea) ea))})]
	  (swap! *eas* conj new-ea)
	  new-ea))))

  ;;TODO: check return type
  (defn run-init [ea]
    (with-ea [ea "INIT"]
      (let [result ((get-fn (:init ea)) (:args ea))]
	(if result
	  (merge ea {:vars (merge (:vars ea) result)})))))

  (defn run-all [ea]
    (with-ea [ea "ALL"]
      (let [new-ea (run-init ea)]
	(if (instance? EA new-ea)
	  (run-start new-ea) 
	  (warn "failed to start - returned nil from init" (:name ea))))))

  (defn run
    ([] (run *ns* {}))
    ([args] (run *ns* args))
    ([ns args]
       ;;todo: not default, no nil
       (run-all (new-ea {:ns ns :args args
			 :symbol (or (:symbol args) (env :symbol))
			 :period (or (:period args) (env :period))}))))

  (defn sym [] (:symbol *ea*))
  (defn period [] (:period *ea*))
  ;;TODO: wait till it stops and delete
  (defn stop [ea]
    (let [stop-it (fn [e]
		    (if (pid? (:pid e))
		      (do (! (:pid e) "stop") 
			  true)))]
      (if (map? ea)
	(stop-it ea)
	(map stop-it ea))))

  (defn clear-eas [] (count (reset! *eas* (filter alive? @*eas*))))
#+end_src
*** Error
#+srcname:error-common 
#+begin_src clojure :tangle src/forex/module/error.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.error
    (:clone clj.core)
    (:require [forex.backend.mql.socket-service :as s])
    (:use utils.general emacs 
	  forex.util.general))

  ;;raw receive
  (defn raw-receive [msg]
    (s/receive msg))
  (defn raw-receive-lst [msg]
    (split (raw-receive msg) #" +"))


  ;;receive with errors
  ;;TODO: error 4054 also occurs when we pass in invalid symbol
  ;;distinguish from loading???
  (defn receive-lst!
    ([msg] (receive-lst! msg nil))
    ([msg try]
       (loop [retries 0]
	 (let [spl (raw-receive-lst msg)] 
	   (if (= (first spl) "error")
	     (let [err (try (Integer/parseInt (second spl))
			    (catch Exception e (second spl)))]
	       (cond
		(and try (< retries try) (or (= err 4066) (= err 4054))) (do (Thread/sleep 300) (recur (inc retries)))
		true (throwf "MQL error %s" (second spl))))
	     spl)))))

  (defn receive!
    ([msg] (receive! msg nil))
    ([msg try]
       (join " " (receive-lst! msg try))))

  (defn receive-double!
    ([msg] (receive-double! msg nil))
    ([msg try] (Double/parseDouble (receive! msg try))))

  ;;receive with default instead of errors, returns error object for errors
  ;;is customizable to default to errors!
  (defrecord MqlError [e])
  (defonce- *er* (gensym)) 
  (def *default* *er*)

  (defn e? [a] (instance? MqlError a))

  (defmacro aif
    ([test then] `(aif ~test ~then nil))
    ([test then else]
       `(let [~'it ~test]
	  (if (and ~'it (not (e? ~'it)))
	    ~then
	    ~else)))) 
  (defmacro awhen [test & body] `(aif ~test (do ~@body)))
  (defmacro aif-not 
    ([test then] `(aif-not ~test ~then nil))
    ([test then else]
       `(let [~'it ~test]
	  (if (not (and ~'it (not (e? ~'it))))
	    ~then
	    ~else)))) 
  (defmacro awhen-not [test & body] `(aif-not ~test (do ~@body)))

  (defn- parse-int [a] (try (Integer/parseInt a) (catch Exception e a)))

  (defn receive
    ([msg] (receive msg *default*))
    ([msg default]
       (let [spl (raw-receive-lst msg)]
	 (if (and (= (first spl) "error"))
	   (let [err (parse-int  (second spl))] 
	     (if (= default *er*)
	       (MqlError. err) 
	       (if (fn? default) (default (MqlError. err)) default)))
	   (join "" spl)))))

  (defn receive-double
    ([msg] (receive-double msg *default*))
    ([msg default]
       (let [spl (raw-receive-lst msg)]
	 (if (= (first spl) "error")
	   (if (= default *er*)
	     (MqlError. (Integer/parseInt (second spl)))
	     (if (fn? default) (default (MqlError. (Integer/parseInt (second spl)))) default))
	   (Double/parseDouble (join " "  spl))))))

  (defn receive-int [s]
    (aif (receive-double s)
	 (int it)
	 it))
#+end_src
*** Indicator
#+srcname:indicator-common
#+begin_src clojure :tangle src/forex/module/indicator.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.indicator
    (:clone clj.core)
    (:use
     utils.general 
     forex.util.general
     forex.module.account.utils
     forex.module.error)   
    (:require [forex.module.error :as s]))

  (def +m1+ 1)
  (def +m5+ 5)
  (def +m15+ 15)
  (def +h1+ 60)
  (def +h4+ 240)
  (def +d1+ (* 24 +h1+))
  (defn cross?
    ([signal main] (cross? signal main 0))
    ([signal main i]
       (let [i1 (+ i 1) i2 (+ i 2)
	     a1 (signal i1) a2 (signal i2)
	     b1 (main i1) b2 (main i2)] 
	 (or (and (> a1 b1) (< a2 b2) [:buy i])
	     (and (< a1 b1) (> a2 b2) [:sell i])
	     nil))))

  ;;high low open close
  (defn get-rel-data [^String symbol ^Integer period ^Integer from ^Integer to]
    (is?  (>= to from) "in get-data, from/to is invalid")
    (loop [dat nil retries 0]
      (if (> retries 3) (throwf "MQL error %s" (second dat)))
      (let [data (s/raw-receive-lst (format "bars_relative %s %s %s %s"
					symbol period from to))]
	(if (= (first data) "error") 
	  (do (sleep 0.4) (recur data (+ retries 1)))
	  data)))) 

  (defn- rel [i]
    (let [sym (env :symbol)
	  period (env :period)]
      (is? (and (string? sym) (integer? period)))
      (get-rel-data sym period i i)))
  (defn- off [a] (+ (or (env :i) 0) a))
  (defn high
    ([] (high 0)) 
    ([i] (Double/parseDouble (nth (rel (off i)) 1))))
  (defn open 
    ([] (open 0)) 
    ([i] (Double/parseDouble (nth (rel (off i)) 3))))
  (defn low
    ([] (low 0))
    ([i] (Double/parseDouble (nth (rel (off i)) 2))))
  (defn close
    ([] (close 0))
    ([i] (Double/parseDouble (nth (rel (off i)) 4))))

  ;;TODO: change
  (defn ask
    ([] (ask (env :symbol)))
    ([symbol] (aif (mode-ask symbol) it (throwf "MQL error %s" (:e it)))))
  ;;bid==close 
  (defn bid
    ([] (bid (env :symbol)))
    ([symbol] (aif (mode-bid symbol) it (throwf "MQL error %s" (:e it)))))

  (defn- env? [] (and (string? (env :symbol)) (integer? (env :period))))
  (defn- >? [a] (or (zero? a) (pos? a)))
  ;;an example of acessing a custom ea


  (defn moving-averages
    ([method] (fn
		([period] (moving-averages method period))
		([period offset] (moving-averages method period offset))))
    ([method period] (moving-averages method period 0))
    ([method period offset]
       {:pre [(env?)  (>? offset)
	      (number? method) (>? period)]}
       (receive-double! 
	(format "Custom_Moving_Averages %s %s %s %s %s 0 %s"
		(env :symbol) (env :period) ;;period/method
		0 (off offset) period method)
	3))) 
  (def sma (moving-averages 0))
  (def ema (moving-averages 1))
  (def smma (moving-averages 2))
  (def lwma (moving-averages 3))

  ;;todo - check for valif params - above 1?
  (defn psar
    "step (0.02), maximum 0.2"
    ([params] (psar params 0))
    ([params offset]
       {:pre [(env?) (>? offset)  (= (count params) 2)]}
       (receive-double! 
	(format "Custom_Parabolic %s %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) (first params) (second params))
	3)))
  (defn cci
    ([period] (cci period 0))
    ([period offset]
       {:pre [(env?) (>? offset)  (number? period)]}
       (receive-double! 
	(format "Custom_CCI %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))


  (defn momentum
    ([period] (momentum period 0))
    ([period offset]
       {:pre [(env?) (>? offset)  (number? period)]}
       (receive-double! 
	(format "Custom_Momentum %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))


  (defn rsi
    ([period] (rsi period 0))
    ([period offset]
       {:pre [(env?) (>? offset) (number? period)]}
       (receive-double! 
	(format "Custom_RSI %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))

  (defn vma
    ([params] (vma params 0))
    ([params offset]
       {:pre [(env?) (>? offset) (= (count params) 4)]}
       (receive-double! 
	(format "Custom_FantailVMA3 %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) (apply str (interpose " " params)))
	3)))


  (defmacro- indicator-fn [[params index] & body]
    `(fn a#
       ([~params] (a# ~params 0))
       ([~params ~index]
	  ~@body)))



  (defn rsi-black 
    ([params] (fn 
		([mode offset] (rsi-black params mode offset))
		([offset] (rsi-black params 0 offset))))
    ([params mode] (fn
		     ([offset] (rsi-black params mode offset))
		     ([] (rsi-black params mode  0))))
    ([params mode offset]
       {:pre [(env?) (>? offset) (>? mode) 
	      (= (count params) 5)]}
       (receive-double! 
	(format "Custom_Rsi_BlackFeet_modded %s %s %s %s %s"
		(env :symbol) (env :period)
		mode (off offset) (apply str (interpose " " params)))
	3)))

  (def rsi-black-signal
    (indicator-fn [params index]
		  (rsi-black params 1
				 index)))
  (def rsi-black-main
    (indicator-fn [params index]
		  (rsi-black params 0 index)))


  (defn blazan-dynamic-stop
    ([params] (fn 
		([mode offset] (blazan-dynamic-stop params mode offset))
		([offset] (blazan-dynamic-stop params 0 offset))))
    ([params mode] (fn
		     ([offset] (blazan-dynamic-stop params mode offset))
		     ([] (blazan-dynamic-stop params mode  0))))
    ([params mode offset]
       {:pre [(env?) (>? offset) (>? mode) 
	      (= (count params) 4)]}
       (receive-double! 
	(format "Custom_Blazan_Dynamic_Stop %s %s %s %s %s"
		(env :symbol) (env :period)
		mode (off offset) (apply str (interpose " " params)))
	3)))



  (defn hit? [order val]
    (cond
     (sell? order)
     (<= (close) val)
     (buy? order)
     (>= (close) val )
     true (throwf "invalid order type %s" order)))
#+end_src

** Util
*** General
#+srcname:forex-util-general
#+begin_src clojure :tangle src/forex/util/general.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.general
    (:clone clj.core)
    (:use emacs utils.general forex.util.spawn forex.util.log)
    (:require clojure.contrib.error-kit)
    (:import java.io.File (org.joda.time DateTime DateTimeZone Instant)))
  ;;TODO: memoize pow?
  ;;used from http://groups.google.com/group/clojure/browse_thread/thread/cb5246d07142a3dc?fwc=2&pli=1
  (defn frm-save 
   "Save a clojure form to file." 
    [file form] 
    (with-open [w (java.io.FileWriter.
		   (if (instance? File file) file (File. file)))] 
      (binding [*out* w *print-dup* true] (prn form))))

  (defn frm-load 
    "Load a clojure form from file." 
    [file] 
    (with-open [r (java.io.PushbackReader. 
       (java.io.FileReader. (if (instance? File file) file (File. file))))] 
       (let [rec (read r)] 
	 rec)))

  (defn round [num places]
    (let [multiplier (Math/pow 10 places)]
      (/ (int (* num multiplier)) multiplier)))
  (defn ns? [a] (instance? clojure.lang.Namespace a))
  (defn decimal-places [num]
    (let [^String s (reverse (second (.split (str (double num)) "\\.")))
	  c (count s)]
      (loop [c (nth s 0) i 0]
	(cond
	 (or (= i c) (not (= c \0)))
	 (- (count s) i)
	 true
	 (recur (nth s (inc i)) (inc i))))))

  (defn ns-symbol
    ([symbol] (ns-symbol symbol *ns*))
    ([symbol ns] (ns-symbol symbol ns nil))
    ([symbol ns default]
       (let [var ((ns-interns ns) symbol)]
	 (if (and (var? var) (var-get var)) var default))))

  (deftype AtomHash [val]
    Object
    (toString [this] (str "<AtomHash " @val ">"))
    clojure.lang.IPersistentMap
    ;;ILookup
    (valAt [this key] (get @val key))
    (valAt [this key notfound] (get @val key notfound))
    ;;IPersistentCollection
    (count [this] (.count @val))
    (empty [this]  {})
    (cons [this e]  (.cons @val e))
    (equiv [this gs] (or (identical? this gs)
			 (when (identical? (class this) (class gs))
			   (.equiv @val) gs)))
    (containsKey [this k] (or (and (get @val k) true) false))
    (entryAt [this k] (get @val k))
    ;;Seqable
    (seq [this] (seq @val))
    ;;Associative
    (assoc [this k g] (assoc @val k g))
    (assocEx [this k g] (assoc this k g))
    (without [this k] (.without @val k))
    clojure.lang.IDeref
    (deref [this] @val))

  (defmethod clojure.core/print-method AtomHash [o w]
    (.write w (.toString o)))
  ;;TODO: make into protocol method! not multimethod!
  (defmethod swap!  forex.util.general.AtomHash [a & args]
    (apply swap! (.val a) args))
  (defmethod reset!  forex.util.general.AtomHash [a & args]
    (apply reset! (.val a) args))

  (defn atom-hash
    ([] (atom-hash {}))
    ([val]
       (is (map? val))
       (AtomHash. (atom val))))

  (defn symbolicate
    "symbolicate symbols together. ignores things like whitespaces, just drops them!"
    [& args]
    (symbol (apply str args)))

  (defmacro naive-var-local-cache-strategy [var] 
   `(let [cache# (atom {})]
      (reify PCachingStrategy
	(retrieve [_ item#] (get @cache# item#))
	(cached? [_ item#] (contains? @cache# item#))
	(hit [this# _] this#)
	(miss [this# item# result#]
	      (reset! cache# (swap! ~var assoc item# result#))
	      this#))))

  (defmacro constants [& args]
    `(do ~@(map (fn [[name val]] `(def ~name ~val)) (group args 2))))

  (defmacro spawn-log [func]
    `(spawn (fn [] (try (~func) (catch Exception e#
				  (.printStackTrace e#) (severe e#))))))

  (defonce *env* (atom {:period 240 :symbol "EURUSD"})) ;default +H4+, EURUSD
  (defn env
    ([] @*env*)
    ([key] (get @*env* key)))
  (defn env! [map] 
    (swap! *env* #(merge % map))
    map)

  (defmacro wenv [map & body] 
    `(binding [forex.util.general/*env*
	       (atom (merge @@~#'*env* ~map))]
       ~@body))

  ;;aliases for error kit
  (defn ns-export [from-ns]  
    (count (doall (map (fn [[sym var]]
			 (let [var-obj (if (.hasRoot var)
					 (intern *ns* sym (var-get var))
					 (intern *ns* sym))]
			   (when var-obj
			     (alter-meta! var-obj
					  (fn [old] (merge (meta var) old)))
			     var-obj)))
		       (ns-publics from-ns)))))

  (defmacro eval-when [& args]
    (eval `(do ~@args)) nil)

  (eval-when
   (require 'clojure.contrib.error-kit)
   (ns-export (find-ns 'clojure.contrib.error-kit)))

  (deferror *clj-forex-error* [] [message] 
    {:msg (str "clj-forex error: " message) 
     :unhandled (throw-msg Exception)})

  (defn throwf [msg & args] (raise *clj-forex-error* (apply format  msg args)))

  (defmacro is?
    [val & message]
    (if (vector? val)
      `(do ~@(map (fn [test] `(is? ~test ~@message)) val))
      `(let [result# ~val]
	 (if (not result#)
	   (throwf  ~(or (and (first message)
			      `(format ~@message))
			 (format "assertion %s failed"
				 (str val))))
	   result#))))
#+end_src 
*** Log
#+srcname:forex-util-log 
#+begin_src clojure :tangle src/forex/util/log.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.log
    (:clone clj.core)
    (:import [java.util.logging Logger Level LogManager Handler
	      FileHandler SimpleFormatter ConsoleHandler])
    (:require [clojure.contrib.duck-streams :as f])
    (:use emacs utils.general))

  ;;TODO: minor mode
  (defvar log-dir "%h/.forex")

  (defn- formatter []
    (let [d (java.util.Date.)]
      (proxy [java.util.logging.Formatter] []
	(format [r] 
		(clojure.core/format "%s%n%s: %s%n%n"
				     (do (.setTime d (.getMillis r)) d)
				     (.getLevel r)
				     (.getMessage r))))))

  ;;wrap the PrintWriter *out* in an OutputStream to be used in ConsoleHandler
  (defn- new-out-stream [out]
    (proxy [java.io.OutputStream] []
      (close [] (.close out))
      (flush [] (.flush out))
      (write ([b] (.print out (String. b)))
	     ([b off len] (.print out (String. b off len))))))

  ;;TODO: if user deletes log file, it will not be recreated
  ;;this will create a logger which logs to /home/dir/.forex/log.log and will output to System/out (in emacs+slime, this is in the *inferior-lisp* buffer
  ;;or in the *shell* if you do lein swank

  (defn- new-logger [file]
    (f/make-parents
     (java.io.File. (format "%s/.forex/%s" (System/getProperty "user.home") file)))
    (let [l (java.util.logging.Logger/getLogger (str *ns*))]
      (mapc #(.removeHandler l %) (.getHandlers l))
      (.addHandler l (doto (ConsoleHandler.) (.setFormatter (formatter))) ;;(new-out-stream *out*) = to *out*, but sort of clutters everything
		   )
      (.addHandler l (doto (FileHandler. (str log-dir "/" file))
		       (.setFormatter (formatter))))
      (.setUseParentHandlers l false)
      l))

  (defonce- log (java.util.logging.Logger/getLogger (str *ns*)))

  ;;TODO: only use one log file!!! eh?
  (defn init-logger []
    (if-not log
     (def- log (new-logger "log"))))
  (init-logger)
  ;;TODO: set filtering levels
  ;;fine,finer,finest wont log

  (def- *debug-info* "")
  (defmacro debugging [str & args] `(binding [*debug-info* ~str] ~@args))

  (defn info [msg & args]
    (.info log (apply format (str *debug-info* " " msg) args)))
  (defn out [msg & args]
    (println (apply format (str "INFO: " *debug-info* " " msg) args))
    (apply info msg args)
    nil)

   (defn fine [msg & args]
     (.fine log (apply format  (str *debug-info* " " msg) args)))
   (defn finer [msg & args]
     (.finer log (apply format (str *debug-info* " " msg) args)))
   (defn finest [msg & args]
     (.finest log (apply format (str *debug-info* " " msg) args)))
  (defn severe [msg & args]
    (let [s (apply format (str *debug-info* " " msg) args)]
      (.severe log s)
      (print (format "SEVERE: %s%n" s))))
  (defn warn [msg & args]
    (let [s (apply format (str *debug-info* " " msg) args)]
      (.warning log s) 
      (print (format "WARNING: %s%n" s))))
#+end_src
*** Spawn
#+srcname:forex-util-spawn
#+begin_src clojure :tangle src/forex/util/spawn.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.spawn
    (:clone clj.core)
    (:use utils.general forex.util.zmq)
    (:require [utils.fiber.spawn :as s]))

  (def- *pid* (atom []))

  (defalias pid? s/pid?)
  (defalias self s/self)
  (def kill-all s/kill-all)
  (defalias spawn-in-repl s/spawn-in-repl) ;;TODO: add socket for this one

  (defalias ? s/?)

  (defalias make-tag s/make-tag)
  (defn ! [pid msg]
    (with-open [local (doto (new-socket +push+)
			(.connect (format "inproc://%s" pid)))]
      (s/! pid msg)
      (.snd local "REQUEST" +noblock+)))
  (defn  stop-all []
    (swap! *pid*
	   (fn [old]
	     (map #(if (pid? %)
		     (! % "STOP")) @*pid*))))


  (defrecord LocalSocket [socket]
    PSocket
    (raw [this] (.raw socket)) 
    (recv [this flags] 
	  (let [r (.recv socket flags)]
	    (s/?)))
    (recv [this] (recv this 0))
    (close [this] (.close socket))
    (hasMore [this] false))


  (comment
    (defn te []
     (def pid (spawn #(do (pr "BEFORE") (pr local)
			  (pformat "local %s%n" (first (event-seq [local])))
			  (pr "AFTER"))))))


  (defonce- *local* (ThreadLocal.))
  (defn- self-get [key]
    (let [map (.get *local*)]
      (when map 
	(map key))))
  (defn- self-assoc [key obj]
    (let [map (.get *local*)]
      (if map 
       (.set *local* (assoc map key obj)))))
  (def local nil)
  (defn spawn [thunk]
    (let [pid (s/spawn (fn [] 
			 (.set *local* {})
			 (with-open
			     [local-socket (LocalSocket. 
				     (doto
					 (new-socket +pull+)
				       (.bind  (str "inproc://" (self)))))]        
			   (binding [local local-socket]
			     (thunk)))))]
      (swap! *pid* concat [pid])
      pid))

  (defmulti event-seq class)
  (defmethod event-seq clojure.lang.IPersistentVector [v]
    (event-seq (new-poller v)))
  (defmethod event-seq forex.util.zmq.Poller [p]
    ((fn the-seq [p] 
       (lazy-seq
	(let [amount (.poll p)] 
	  (concat (for [i (range 0 (.getSize p)) :when (.pollin p i)]
		    (let [sock (.getSocket p i)
			  msg 
			  (loop [msg [(.recv sock 0)]]                    
			    (if (.hasMore sock)
			      (recur (cons (String. (.recv sock 0)) msg))
			      msg))]
		      [sock (if (= (count msg) 1) (first msg) (vec msg))]))
		  (the-seq p)))))
     p)) 

  ;;? with multiple sources or change to poll
  ;;!? (timeout)
  ;;?? (filter)
#+end_src
*** ZMQ
#+srcname:forex-util-zmq
#+begin_src clojure :tangle src/forex/util/zmq.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.zmq
    (:clone clj.core)
    (:import (org.zeromq ZMQ))
    (:use utils.general))
  (def +noblock+ 1)

  (def +p2p+ 0)
  (def +pub+ 1)
  (def +sub+ 2)
  (def +req+ 3)
  (def +rep+ 4)
  (def +xreq+ 5)
  (def +xrep+ 6)
  (def +pull+ 7) 
  (def +push+ 8)

  (def +hwm+ 1)
  (def +lwm+ 2)
  (def +swap+ 3)
  (def +affinity+ 4)
  (def +identity+ 5)
  (def +subscribe+ 6)
  (def +unsubscribe+ 7)
  (def +rate+ 8)
  (def +recovery-ivl+ 9)
  (def +mcast-loop+ 10)
  (def +sndbuf+ 11)
  (def +rcvbuf+ 12)

  (def +pollin+ 1)
  (def +pollout+ 2)
  (def +pollerr+ 4)
  (def +more+ 2)

  ;;Context
  (defn new-context [io-threads]
    (ZMQ/context io-threads))
  (defonce *context* (new-context 1))

  (defprotocol PSocket
    (raw [this])
    (recv [this flags] [this])
    (bind [this address])
    (connect [this address])
    (hasMore [this])
    (close [this])
    (snd [this msg] [this msg flags])) 
  (defprotocol PPoller
    (setTimeout [this timeout])
    (poll [this])
    (register [this socket])
    (getSocket [this i])
    (getSize [this])
    (pollin [this i])) 
  (defrecord Poller [poll sockets] 
    PPoller 
    (getSize [this] (.getSize (:poll this)))
    (pollin [this i] (.pollin (:poll this) i))
    (setTimeout [this timeout] (.setTimeout (:poll this) timeout))
    (poll [this] (.poll (:poll this)))
    (register [this socket]
	      (.register (:poll this)
			 (if (extends? PSocket (class socket))
			   (.raw socket)
			   socket))
	      (swap! (:sockets this) conj socket))
    (getSocket [this i] (nth @(:sockets this) i)))

  (defn new-poller
    ([sockets] (new-poller *context* sockets))
    ([context sockets]
       (let [p (Poller. (.poller context (count sockets)) (atom []))]
	 (.setTimeout p -1)
	 (on [sock sockets]
	     (.register p sock))
	 p)))

  ;;TODO: now just a string socket!
  (defrecord Socket [socket]
    PSocket 
    (raw [this] socket)
    (snd [this msg] (.snd this msg 0))
    (snd [this msg flags]
	 (if (string? msg)
	   (.send socket (.getBytes msg) flags)
	   (.send socket msg flags))) 
    (recv [this flags] (when-let [it (.recv socket flags)] (String. it)))
    (recv [this] (recv this 0)) 
    (close [this] (.close socket))
    (bind [this address] (.bind socket address))
    (connect [this address] (.connect socket address))
    (hasMore [this] (.hasReceiveMore socket))) 

  (defn new-socket
    ([type] (new-socket *context* type))
    ([context type] (Socket. (.socket context type))))

  (comment
    (defn new-poll
      ([sockets] (new-poll *context* sockets))
      ([context sockets]
	 (let [p (.poller context (count sockets))]
	   (.setTimeout p -1)
	   (on [sock sockets]
	       (.register p (.socket sock)))
	   p)))

    (defn new-socket
      ([socket-type]
	 (new-socket *context* socket-type))
      ([context socket-type ]
	 (.socket context socket-type))))
#+end_src
*** Devel
#+srcname:forex-util-mql-devel
#+begin_src clojure :tangle src/forex/util/mql_devel.clj
  (clojure.core/use 'nstools.ns)
  (ns forex.utils.mql-devel
    (:clone clj.core)
    (:use utils.general))


  (defmacro cond-out [& args]
    (apply str (map (fn [a]
		      (let [name (str a)]
			(format " else if (command==\"%s\") {\n\t   ret = process_%s(request);\n\t}" name name)))
		    args)))

  (cond-out
   AccountBalance
   AccountCredit
   AccountCompany
   AccountCurrency
   AccountEquity
   AccountFreeMargin
   AccountLeverage
   AccountMargin
   AccountName
   AccountNumber
   AccountServer
   AccountProfit
   OrderLots
   OrderDelete
   OrderCloseTime
   OrderType
   OrdersTotal
   OrderSend
   MarketInfo
   OrderClose
   OrderModify)
#+end_src

#+srcname:forex-util-indicator-devel
#+begin_src clojure :tangle src/forex/util/mql_indicator_devel.clj
  (clojure.core/use 'nstools.ns)
  ;;this file allows one to automatically produce binding code for metatrader custom indicators
  (ns+ forex.utils.mql-indicator-devel
    (:clone clj.core)
    (:import java.io.File))

  (defmacro for+ [args & body]
    (let [a (partition-all 2 args)]
      `(map (fn ~(vec (map first a)) ~@body) ~@(map second a))))
  (defn throwf [msg & args]
    (throw (Exception. (apply format msg args))))

  (defn args [s]
    (map rest (re-seq #"extern\s+(\w+)\s+(\w+)" s)))
  (defn buffers [s]
    (count (re-seq #"SetIndexBuffer" s)))

  (defn extract [args]
    (let [type-to-fn (fn [type]
		       (condp = type
			   "int" "StrToInteger"
			   "double" "StrToDouble"
			   "string" nil
			   "color" "StrToInteger"
			   "bool" "StrToInteger"
			   (throwf "unknown type %s" type)))
	  user-extract (apply str
			      (interpose "\n"
					 (for+ [[type name] args index (iterate inc 6)]
					       (let [type-fn (type-to-fn type)]
						 (if type-fn
						   (format "%s %s = %s(command[%s]);" type name type-fn index)
						   (format "%s %s = command[%s];" type name index))))))
	  always (format "
  string symbol = command[2];
  int timeframe = StrToInteger(command[3]);
  int mode = StrToInteger(command[4]);
  int shift = StrToInteger(command[5]);")]
      (str always "\n" user-extract)))

  (defn extension [f] (let [e (second (.split (if (instance? File f) (.getName f) f) "\\."))] (if (string? e) (.trim e))))

  (defn to-test [all]
    (format "%nstring process_INDICATORS(string commands[]) {%nstring ret = \"\";string command=commands[1];%n%s%nreturn(ret);}"
	    (apply str
		   "if (command==\"0\") {\n}\n"
		   (map #(format "else if (command==\"%s\") {%nprotocol_found=true;%nret = %s(commands);%n}%n" (:function-name %) (:function-name %)) all))))


  (defn- listify [s] (if-not (empty? s) (str (apply str (interpose "," s)) ",") "" ))
  (defn name-of [f] (first (.split (.getName f) "\\.")))
  (defn iCustom
    "given a file, generate mql4 binding code to the indicator in the flie"
    [f]
    (let [name (.replaceAll (first (.split (.getName f) "\\.")) "( |-)+" "_")
	  s (slurp f)
	  args (map #(list (first %) (format "i_%s" (second %))) (args s))
	  buffers (buffers s)]
      (when (and s args buffers)
	(let [custom (format "double val = iCustom(symbol,timeframe,\"%s\",%smode,shift);" ;
					       (name-of f) (listify (map second args))) 
	      extract (extract args)

	      return (format
		      "
  int err = GetLastError();
  if(err!=0)
    return(\"error \" + err);
  return(val); 
  }")
	      function-name (format "Custom_%s" name)
	      function-header (format "string %s (string command[]) {" function-name)] 
	  {:file f :file-name name :function-name function-name :args args :buffers buffers
	   :code  (format "%s %s %s %s" function-header extract custom return)}))))

  (defn iCustom-all [dir out]
    (let [files (.listFiles (File. dir))
	  customs (for [f files :when (= (extension f) "mq4")] (iCustom f))]
      (spit out (format "bool protocol_found = false;%n%s\n%s" (apply str (interpose "\n\n" (map :code customs)))
			(to-test customs)))))


  ;;example usage - first param is custom indicator folder, second is output file
  (defn do-it []
    (iCustom-all
     "/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/indicators/"
     "/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/include/INDICATORS.mqh"))
#+end_src
** User 
#+srcname:forex_user
#+begin_src clojure :tangle src/forex_user.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex-user
       (:like forex.default)
       (:use utils.general))
  ;;TODO: mql error 146

  ;;forex_user is the ns in which customization will occur
#+end_src

** Templates
#+source: template
#+begin_src clojure :tangle src/forex/default.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.default
       (:clone clj.core)
       (:use forex.util.general emacs
	     forex.util.log) 
       (:use forex.module.error
	     forex.module.ea
	     forex.module.indicator
	     forex.module.account forex.module.account.utils
	     [clj-time.core :exclude [extend start]])
       (:require
	[forex.backend.mql.socket-service :as backend]))
#+end_src

#+source: template
#+begin_src clojure :tangle src/clj/core.clj
  (ns clj.core
    (:refer-clojure :exclude [promise swap! reset!])
    (:import clojure.lang.APersistentMap java.io.Writer))
  ;;TODO: serializable records and atoms and refs!
  (defn record? [a] 
    (and (map? a) (not (instance? clojure.lang.APersistentMap a))))
  ;;this will affect all code!! i do not know how to make it not so. oh well, this is good anyways, maybe ill change later!
  
  (defmethod print-dup clojure.lang.IPersistentMap [m, ^Writer w]
    (if (record? m)
      (print-dup `(new ~(class m) ~@(map second (seq m))) w)
      (do 
        (#'clojure.core/print-meta m w)
        (.write w "#=(")
        (.write w (.getName (class m)))
        (.write w "/create ")
        (#'clojure.core/print-map m print-dup w)
        (.write w ")"))))
  
  (defn unuse [ns]
    (doseq [[n v] (ns-refers *ns*)]
      (if (= (.. v ns name) ns)
        (ns-unmap *ns* n))))
  (defn reuse [ns]
    (unuse ns) 
    (remove-ns ns)
    (use :reload-all ns))
  
  (defmulti swap! (fn [a & args] (class a)))
  (defmethod swap! clojure.lang.Atom [& args]
    (apply clojure.core/swap! args))
  (defmulti reset! (fn [a & args] (class a)))
  (defmethod reset! clojure.lang.Atom [& args]
    (apply clojure.core/reset! args))
  (defprotocol PWait 
    (wait-for [this timeout units] [this timeout]))
  ;;copied from clojure source, but adding timeout wait-for
  (defn promise
    "Alpha - subject to change.
    Returns a promise object that can be read with deref/@, and set,
    once only, with deliver. Calls to deref/@ prior to delivery will
    block. All subsequent derefs will return the same delivered value
    without blocking."
    {:added "1.1"}
    []
    (let [d (java.util.concurrent.CountDownLatch. 1)
          v (atom nil)]
      (reify 
        clojure.lang.IDeref
        (deref [_] (.await d) @v)
        PWait
        (wait-for [this timeout]
                  (wait-for this timeout
                            java.util.concurrent.TimeUnit/MILLISECONDS))
        (wait-for [this timeout units]
                  (if timeout
                    (.await d timeout units)
                    (do (.await d) true)))
        clojure.lang.IFn
        (invoke [this x] 
                (locking d
                  (if (pos? (.getCount d))
                    (do (reset! v x)
                        (.countDown d)
                        x)
                    (throw
                     (IllegalStateException.
                      "Multiple deliver calls to a promise"))))))))
  
  (defmethod print-dup clojure.lang.Atom [o w]
    (.write w "#=(atom ") (print-dup @o w) (.write w ")"))
  (defmethod print-dup clojure.lang.Ref [o w]
    (.write w "#=(ref ") (print-dup @o w) (.write w ")"))
  
  
#+end_src
** Examples
#+source: timeout-ea
#+begin_src clojure :tangle src/forex/examples/timeout_ea.clj
  ;;forex.examples.timeout-ea : ea which manages the orders of a trade
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.timeout-ea
       (:like forex.default)
       (:use utils.general
	     forex.examples.timeout-ea.utils))
   ;;ea vars   
  (defvar state (atom :timeout))
  (defvar end-time)
  (defvar order) 
  ;;  
  ;;TODO: when we order, and modify fails, how do we get the error? later :)...
  (defn init [{:keys [type sl price]}]
    (aif (order! (atom-hash {:type type :sl sl :price price
			     :lots (* (mode-minlot) 2)}))
	 {#'end-time (plus (now) (hours 12))
	  #'order it} 
	 (out "MQL error %s" (:e it))))
  (declare timeout break-even trail)
  (defn start [args]
    (cond
     (close? order) (exit "order is now closed")
     (= @state :timeout) (timeout args)
     (= @state :break-even) (break-even args))) 


  (defn timeout [_]
    (cond
     ;;changed to market
     (market? order)
     (do (reset! state :break-even) (out "changed to break even"))
     ;;entry order reach sl 
     (if (sell? order) (> (close) (:sl order)) (< (close) (:sl order)))
					  ;TODO: reliable delete????
     (awhen (delete! order) (exit "entry order reached sl. deleting ..."))
     ;;timed out
     (after? (now) end-time)
     (awhen (delete! order) (exit "order timed out"))))

  (defn break-even [{:keys [tp2 tp1]}]
    (when (hit? order tp1)
      (out "closing to half ...")
      (awhen (-> (modify! order {:sl (:price order) :tp tp2})
		 (close! (lot (/ (:lots order) 2))))
	     (exit "finished break even"))))

  (defn hh [a]
    (apply max (map high (range 1 (inc a)))))
  (defn ll [a]
    (apply min (map low (range 1 (inc a)))))
  (defn trail [_]
    (modify! order 
	     {:sl (if (sell? order)
		    (min (:sl order) (hh 3))
		    (max (:sl order) (ll 3)))}))
#+end_src

#+source: timeout-ea-utils
#+begin_src clojure :tangle src/forex/examples/timeout_ea/utils.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.timeout-ea.utils
       (:like forex.default)
       (:use utils.general))
  (defn pip-price
    ([] (pip-price (env :symbol)))
    ([symbol] (mode-tickvalue symbol)))
  ;;TODO: mql err on point? no way! we should throw an error

  (defn point 
    ([] (point (env :symbol)))
    ([symbol]
       (* 10 (mode-point symbol))))
  (defn pips   
    ([price] (pips price (env :symbol)))
    ([price symbol] 
       (/ price (point symbol)))) 
  (defn price-of 
    ([val] (price-of val (env :symbol)))
    ([val symbol]
       (* (pip-price symbol) (pips val)))) 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (def method-regex
    (re-pattern (.replaceAll
		 (str "(?i)\\s*(Propulsion|Pip Reactor|Impulse|Spring)\\s+Method"
		      ".+running on (\\w+/\\w+)"
		      ".+generated a (Buy|Sell) Signal @ (\\d{0,15}\\.\\d{0,15})"
		      ".+Stop @ (\\d{0,15}\\.\\d{0,15})"
		      ".+(?:1st|First) Limit @ (\\d{0,15}\\.\\d{0,15})"
		      ".+(?:2nd|Second) Limit @ (\\d{0,15}\\.\\d{0,15})") 
		 "\\s+" "\\\\s+")))

  (defmacro catch-un [& body]
    `(try (do ~@body) (catch Exception e# (warn "caught unexpected error: %s" e#))))

  (defn match-method [s]
    (when s 
      (debugging "Matching Profit Multiplier Trade: "
		 (catch-un 
		  (when-let [it (first (re-seq method-regex (.replaceAll s "[\\r\\n]+" " ")))]
		    (let [[method-type symbol type price stop tp1 tp2] (rest it)]
		      {:method (.toLowerCase method-type)
		       :symbol (.replaceAll symbol "/" "")
		       :type (condp = (.toLowerCase type)
				 "buy" :buy-stop
				 "sell" :sell-stop)
		       :price (Double/parseDouble price)
		       :sl (Double/parseDouble stop)
		       :tp1 (Double/parseDouble tp1)
		       :tp2 (Double/parseDouble tp2)}))))))
#+end_src
 
