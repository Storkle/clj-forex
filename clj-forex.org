#+TITLE: CLJ-FOREX
#+Author: Seth Burleigh
#+Babel: :comments link :noweb yes :mkdirp yes
             
* Introduction
** What is forex?
Forex is a currency trading market. But you probably know all about forex, since you're here! If not, read up on it! \\
+ [[http://en.wikipedia.org/wiki/Foreign_exchange_market][Wiki article - OK]]
+ [[http://www.fxcm.com/metatrader.jsp][FXCM Retail Broker Free Metatarder Terminal -  get demo account and see what forex trading is first hand!]]
** What is clj-forex?
Clj-forex is an in progress effort to create a non-graphical backend to various forex trading backends. Right now Metatrader is the focus. 
The ultimate goal of clj-forex is to create a robust library to allow the creation of EA (expert advisors) in the scripting language clojure. Expert advisors
are programs which automatically trade the market, performing sell/buy orderes, changing stoplosses, using technical indicators, etc. They are useful for
both automating parts of manual trading systems (performing trailing stops, expiration of market orders) and also for full out automated trading.

Indicators will be calculated java side using price bars retrieved from the backends. Integration of indicator data to various gui backends (i.e. at this time,
Metatrader) will be supported. The only purpose of the forex backend is to allow access to spreads, current price, ability to buy/sell, etc. 
** The Difference
Im not sure why noone has done this before, but integration of a scripting language to create eas is, in my opinion, vital. 
Integration of a lisp-like dialect, like clojure, will allow much more rapid creation and prototyping of eas. 
This combined with easy access to any java library (clojure is implemented on the java virtual machine) makes for a winning combination! 
Things like neural networks, database, and other such ‘advanced’ concepts can now be much more easily integrated than if we had used [[http://book.mql4.com/][mql4]].

Its like an artist! Give an artist more efficient tools in the toolbox and who knows what can be created! [And clojure is fun to learn anyways!]
** Where's the code??
This file is the code (clojure, anyways). The code is untangled using the
keystroke C-c C-v t in emacs when this file is open. While currently most
of the code is simply in the Code section, it will all eventually be explained
in the [[http://groups.google.com/group/clojure/browse_thread/thread/664a1d305f32ab90][literate programming]] manner.
* Development Tools
org-mode in emacs + babel is used. Currently code is one ns per one code block
format. Therefore, i use the below code, along with the latest git repository
for org-mode (needed!). I then hit f8 to detangle all my changes to my org file.
f9 can be used to jump from source code to location in org file. 
#+begin_src emacs-lisp
  
  (defvar clj-forex-file "/home/seth/Dropbox/.rep/clj-forex/clj-forex.org")
  
  
  (defmacro with-file (file &rest body)
    "open up file in a buffer, and set current buffer to it"
    `(with-current-buffer (find-file-noselect ,file t) ,@body))
  
  (defun out-files (org-file)
    (let (args)
      (org-babel-map-src-blocks org-file
        (let ((tangle-file (with-temp-buffer
                             (insert header-args)
                             (goto-char (point-min))
                             (if (re-search-forward ":tangle[ ]+\\([^ ]+\\)" nil t)
                                 (match-string 1)
                               nil))))
          (when tangle-file (push tangle-file args))))
      args))
  
  (defmacro with-cd (dir &rest body)
    (let ((current (gensym)))
      `(let ((,current default-directory))
         (cd ,dir)
         (unwind-protect (progn ,@body) (cd default-directory)))))
  
  ;;TODO rever buffers when detangle/tangle?
  (defun detangle ()
    (interactive)
    (save-excursion
      (let* ((org-file clj-forex-file)
             (out (out-files org-file))
             (amount 0)) 
        (with-cd (file-name-directory org-file)
                 (dolist (file out)
                   (with-file
                    file
                    (goto-char (truncate (/ (+ (point-min) (point-max)) 2)))
                    (let ((detangled (org-babel-detangle)))
                      (if (= detangled 0) (progn (message "failed on %s" file)
                                                 (sleep-for 2)))
                      (incf amount detangled)))))
        (message "Detangled %s source blocks/ %s" amount (length out)))))
  (global-set-key (kbd "<f8>") 'detangle)
  (global-set-key (kbd "<f9>") 'org-babel-tangle-jump-to-org)
  (setq org-src-fontify-natively t)
#+end_src

Given the tangled output of the source files, which basically tags the
code so that it can detangle it and jump back to the org file, we can
technically work in something other than emacs if we have a clojure tool
to detangle and tangle. However, this is not yet implemented. Also, it is planned
to give noweb support for babel so that i can break up the blocks.

Yes, currently it is not very development start friendly. That will change!
* From Ideas to Implementation - Metatrader Backend
* Code
** Project
#+srcname:project
#+begin_src clojure :tangle project.clj
  (defproject clj-forex "0.1"
    :description "non graphical library for automated trading for forex market with various backends like metatrader"
    :dependencies [[org.clojure/clojure "1.2.0"]
		   [org.clojure/clojure-contrib "1.2.0"]           
		   [matchure "0.10.0"]
		   [clj-time "0.2.0-SNAPSHOT"]            
		   [mmemail "1.0.1"]
		   [nstools "0.2.4"]
		   [org.clojars.starry/clj-forex-indicators "0.1"]]   
    :dev-dependencies [[native-deps "1.0.5"]
		       [swank-clojure "1.3.0-SNAPSHOT"]] 
    :native-dependencies [[org.clojars.starry/jzmq-native-deps "2.0.10.1"]]
    ;; :jvm-opts      ["-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8030"]
    ;;:main forex.binding
    ;;:aot :all
    )
#+end_src 
   
** Util 
*** ThirdParty
#+source:defrecord2
#+begin_src clojure :tangle src/clj/third_party/defrecord2.clj
  ;;BY David McNeil
  ;;https://github.com/david-mcneil/defrecord2
  ;;modified defrecord2 macro so i could include protocols
  ;;got rid of print-method method

  (ns clj.third-party.defrecord2
    (:require [clojure.contrib.str-utils2 :as str2])
    (:use [clojure.contrib.core :only (seqable?)]
	  [clojure.set :only (difference)]
	  [clojure.string :only (join)]
	  [clojure.contrib.pprint :only (*simple-dispatch* use-method pprint-map)])
    (:import [clojure.lang IPersistentList IPersistentVector IPersistentMap ISeq]))

  ;;;; enhanced records

  ;; internal helpers for name conversion

  (defn take-even [x]
    (take-nth 2 x))

  (defn take-odd [x]
    (take-nth 2 (drop 1 x)))

  (defn is-upper? [s]
    (= (.toUpperCase s) s))

  (defn assemble-words [parts]
    (loop [remaining-parts parts result []]
      (if (seq remaining-parts)
	(let [part (first remaining-parts)]
	  (recur (rest remaining-parts)
		 (if (is-upper? part)
		   (conj result (.toLowerCase part))
		   (conj (if (seq result)
			   (pop result)
			   []) (str (last result) part)))))
	result)))

  (defn camel-to-dashed
    "Convert a name like 'BigBlueCar' to 'big-blue-car'."
    [s]
    (let [parts (remove #(= "" %) (str2/partition s #"[A-Z]"))
	  words (assemble-words parts)]
      (join "-" words)))

  ;; internal helpers for changing records via maps 

  (defn set-record-field
    "Set a single field on a record."
    [source [key value]]
    (assoc source key value))

  (defn set-record-fields
    "Set many fields on a record, from a map."
    [initial value-map]
    (reduce set-record-field initial value-map))

  ;; internal helper for generating constructor function

  (defn expected-keys? [map expected-key-set]
    (not (seq (difference (set (keys map)) expected-key-set))))

  (defmacro make-record-constructor
    "Define the constructor functions used to instantiate a record."
    [ctor-name type-name field-list default-record]
    `(defn ~ctor-name
       ([value-map#]
	  (~ctor-name ~default-record value-map#))
       ([initial# value-map#]
	  {:pre [(or (nil? initial#)
		     (isa? (class initial#) ~type-name))
		 (map? value-map#)
		 (expected-keys? value-map# ~(set (map keyword field-list)))]}
	  (set-record-fields (if (nil? initial#) ~default-record initial#) value-map#))))

  ;; internal helpers for printing

  (defn remove-nil-native-fields [native-keys record]
    (let [extra-keys (difference (set (keys record))
				 native-keys)]
      (apply array-map (reduce into (for [[k v] record]
				      (if (or (contains? extra-keys k)
					      (not (nil? v)))
					[k v]))))))

  (defmacro print-record
    "Low-level function to print a record to a stream using the specified constructor name in the print output and using the provided write-contents function to write out the contents of the record (represented as a map)."
    [ctor ctor-name native-keys record stream write-contents]
    `(do
       (.write ~stream (str "#=(" ~ctor-name " "))
       (~write-contents (remove-nil-native-fields ~native-keys ~record))
       (.write ~stream  ")")))

  (defn print-record-contents
    "Simply write the contents of a record to a stream as a string. Used for basic printing."
    [stream contents]
    (.write stream (str contents)))

  (defmacro setup-print-record-method [ctor ctor-name native-keys type-name method-name]
    `(defmethod ~method-name ~type-name [record# writer#]
       (print-record ~ctor ~ctor-name ~native-keys record# writer# (partial print-record-contents writer#))))

  (defmacro setup-print-record
    "Define the print methods to print a record nicely (so that records will print in a form that can be evaluated as itself)."
    [ctor ctor-name native-keys type-name]

    `(do ;(setup-print-record-method ~ctor ~ctor-name ~native-keys ~type-name print-method)
       (setup-print-record-method ~ctor ~ctor-name ~native-keys ~type-name print-dup)))

  (defn generate-record-pprint
    "Return a function that can be used in the pprint dispatch mechanism to handle a specific constructor name."
    [ctor ctor-name native-keys]
    (fn [record]
      (print-record ctor ctor-name native-keys record *out* pprint-map)))

  ;; internal helpers - walking data structures

  ;; w - walker function
  ;; f - mutator function
  ;; n - node in data tree being walked

  ;; helper - generating walking methods like this:
  (comment (defmethod prewalk2 Foo [f foo]
	     (if-let [foo2 (f foo)]
	       (new-foo foo2 {:a (prewalk2 f (:a foo2))
			      :b (prewalk2 f (:b foo2))})))

	   (defmethod postwalk2 Foo [f foo]
	     (f (new-foo foo {:a (postwalk2 f (:a foo))
			      :b (postwalk2 f (:b foo))}))))

  (defmulti walk2 (fn [w f n] (class n)))

  (defmethod walk2 :default [w f n]
    n)

  ;; TODO: handle sets

  (defmethod walk2 IPersistentVector [w f n]
    (apply vector (map (partial w f) n)))

  (defmethod walk2 IPersistentMap [w f n]
    ;; TODO: handle sorted maps
    (apply array-map (mapcat (partial walk2 w f) n)))

  (defmethod walk2 IPersistentList [w f n]
    (apply list (map (partial w f) n)))

  (prefer-method walk2 IPersistentList ISeq)

  (defmethod walk2 ISeq [w f n]
    (map (partial w f) n))

  (defmacro walking-helper-field
    ([w f n field]
       `[~(keyword field) (~w ~f (~(keyword field) ~n))])
    ([w f n field & more]
       `(concat (walking-helper-field ~w ~f ~n ~field) (walking-helper-field ~w ~f ~n ~@more))))

  (defmacro walking-helper-fields
    [w f n fields]
    `(apply array-map (walking-helper-field ~w ~f ~n ~@fields)))

  (defmacro make-prewalk2-method
    "Define the methods used to walk data structures."
    [ctor-name type-name field-list]
    `(defmethod prewalk2 ~type-name [f# n#]
       (if-let [n2# (f# n#)]
	 (~ctor-name n2# (walking-helper-fields prewalk2 f# n2# ~field-list)))))

  (defmacro make-postwalk2-method
    "Define the methods used to walk data structures."
    [ctor-name type-name field-list]
    `(defmethod postwalk2 ~type-name [f# n#]
       (f# (~ctor-name n# (walking-helper-fields postwalk2 f# n# ~field-list)))))

  ;; public entry points

  (defmulti prewalk2 (fn [f n] (class n)))

  (defmethod prewalk2 :default [f n]
    (walk2 prewalk2 f (f n)))

  (defmulti postwalk2 (fn [f n] (class n)))

  (defmethod postwalk2 :default [f n]
    (f (walk2 postwalk2 f n)))


  (defmacro defrecord2
    "Defines a record and sets up constructor functions, printing, and pprinting for the new record type."
    [type-name field-list & protocols]
    (let [type-name (if (seqable? type-name) (first type-name) type-name)
	  ctor-name (if (seqable? type-name) (second type-name) (symbol (str "new-" (camel-to-dashed (str type-name)))))] 
      `(do 
	 ;; define the record
	 (defrecord ~type-name ~field-list ~@protocols)
	 ;; define the constructor functions
	 (make-record-constructor ~ctor-name
				  ~type-name
				  ~field-list
				  (~(symbol (str type-name ".")) ~@(repeat (count field-list) nil)))
	 ;; setup tree walking methods
	 (make-prewalk2-method ~ctor-name ~type-name ~field-list)
	 (make-postwalk2-method ~ctor-name ~type-name ~field-list)

	 ;; setup printing
	 (let [empty-record# (~ctor-name {})
	       native-keys# (set (keys empty-record#))]
	   (setup-print-record ~ctor-name (quote ~ctor-name) native-keys# ~type-name)
	   ;; setup pprinting
	   (use-method *simple-dispatch* ~type-name (generate-record-pprint ~ctor-name (quote ~ctor-name) native-keys#))))))
#+end_src

*** CLJ
#+source:clj-core
#+begin_src clojure :tangle src/clj/core.clj
  (ns clj.core
    (:refer-clojure :exclude [promise swap! reset! defrecord])
    (:require clj.third-party.defrecord2)
    (:import clojure.lang.APersistentMap java.io.Writer))
  (defmacro defrecord [name fields & protocols]
    `(clj.third-party.defrecord2/defrecord2 ~name ~fields ~@protocols))

  ;;TODO: serializable records and atoms and refs 
  (defmulti swap! (fn [a & args] (class a)))
  (defmethod swap! clojure.lang.Atom [& args]
    (apply clojure.core/swap! args))
  (defmulti reset! (fn [a & args] (class a)))
  (defmethod reset! clojure.lang.Atom [& args]
    (apply clojure.core/reset! args))
  (defprotocol PWait 
    (wait-for [this timeout units] [this timeout]))
  ;;copied from clojure source, but adding timeout wait-for
  (defn promise
    "Alpha - subject to change.
    Returns a promise object that can be read with deref/@, and set,
    once only, with deliver. Calls to deref/@ prior to delivery will
    block. All subsequent derefs will return the same delivered value
    without blocking."
    {:added "1.1"}
    []
    (let [d (java.util.concurrent.CountDownLatch. 1)
	  v (atom nil)]
      (reify 
	clojure.lang.IDeref
	(deref [_] (.await d) @v)
	PWait
	(wait-for [this timeout]
		  (wait-for this timeout
			    java.util.concurrent.TimeUnit/MILLISECONDS))
	(wait-for [this timeout units]
		  (if timeout
		    (.await d timeout units)
		    (do (.await d) true)))
	clojure.lang.IFn
	(invoke [this x] 
		(locking d
		  (if (pos? (.getCount d))
		    (do (reset! v x)
			(.countDown d)
			x)
		    (throw
		     (IllegalStateException.
		      "Multiple deliver calls to a promise"))))))))

  (defmethod print-dup clojure.lang.Atom [o w]
    (.write w "#=(atom ") (print-dup @o w) (.write w ")"))
  (defmethod print-dup clojure.lang.Ref [o w]
    (.write w "#=(ref ") (print-dup @o w) (.write w ")"))
#+end_src

*** Core
#+srcname:forex-util-core
#+begin_src clojure :tangle src/forex/util/core.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.core
    (:clone clj.core)
    (:use forex.util.emacs forex.util.general forex.util.spawn forex.util.log)
    (:require clojure.contrib.error-kit)
    (:import java.io.File (org.joda.time DateTime DateTimeZone Instant)))
  ;;TODO: memoize pow?
  ;;used from http://groups.google.com/group/clojure/browse_thread/thread/cb5246d07142a3dc?fwc=2&pli=1
  (defn frm-save 
   "Save a clojure form to file." 
    [file form] 
    (with-open [w (java.io.FileWriter.
		   (if (instance? File file) file (File. file)))] 
      (binding [*out* w *print-dup* true] (prn form))))

  (defn frm-load 
    "Load a clojure form from file." 
    [file] 
    (with-open [r (java.io.PushbackReader. 
       (java.io.FileReader. (if (instance? File file) file (File. file))))] 
       (let [rec (read r)] 
	 rec)))

  (defn round [num places]
    (let [multiplier (Math/pow 10 places)]
      (/ (int (* num multiplier)) multiplier)))
  (defn ns? [a] (instance? clojure.lang.Namespace a))
  (defn decimal-places [num]
    (let [^String s (reverse (second (.split (str (double num)) "\\.")))
	  c (count s)]
      (loop [c (nth s 0) i 0]
	(cond
	 (or (= i c) (not (= c \0)))
	 (- (count s) i)
	 true
	 (recur (nth s (inc i)) (inc i))))))

  (defn ns-symbol
    ([symbol] (ns-symbol symbol *ns*))
    ([symbol ns] (ns-symbol symbol ns nil))
    ([symbol ns default]
       (let [var ((ns-interns ns) symbol)]
	 (if (and (var? var) (var-get var)) var default))))

  (deftype AtomHash [val]
    Object
    (toString [this] (str "<AtomHash " @val ">"))
    clojure.lang.IPersistentMap
    ;;ILookup
    (valAt [this key] (get @val key))
    (valAt [this key notfound] (get @val key notfound))
    ;;IPersistentCollection
    (count [this] (.count @val))
    (empty [this]  {})
    (cons [this e]  (.cons @val e))
    (equiv [this gs] (or (identical? this gs)
			 (when (identical? (class this) (class gs))
			   (.equiv @val) gs)))
    (containsKey [this k] (or (and (get @val k) true) false))
    (entryAt [this k] (get @val k))
    ;;Seqable
    (seq [this] (seq @val))
    ;;Associative
    (assoc [this k g] (assoc @val k g))
    (assocEx [this k g] (assoc this k g))
    (without [this k] (.without @val k))
    clojure.lang.IDeref
    (deref [this] @val))
  (defmethod print-dup AtomHash [o w]
    (.write w "#=(atom-hash ") (print-dup @o w) (.write w ")"))

  (defmethod clojure.core/print-method AtomHash [o w]
    (.write w (.toString o)))
  ;;TODO: make into protocol method! not multimethod!
  (defmethod swap!  forex.util.core.AtomHash [a & args]
    (apply swap! (.val a) args))
  (defmethod reset!  forex.util.core.AtomHash [a & args]
    (apply reset! (.val a) args))

  (defn atom-hash
    ([] (atom-hash {}))
    ([val]
       (is (map? val))
       (AtomHash. (atom val))))

  (defn symbolicate
    "symbolicate symbols together. ignores things like whitespaces, just drops them!"
    [& args]
    (symbol (apply str args)))

  (defmacro naive-var-local-cache-strategy [var] 
   `(let [cache# (atom {})]
      (reify PCachingStrategy
	(retrieve [_ item#] (get @cache# item#))
	(cached? [_ item#] (contains? @cache# item#))
	(hit [this# _] this#)
	(miss [this# item# result#]
	      (reset! cache# (swap! ~var assoc item# result#))
	      this#))))

  (defmacro constants [& args]
    `(do ~@(map (fn [[name val]] `(def ~name ~val)) (group args 2))))

  (defmacro spawn-log [func name]
    `(spawn (fn [] (try (~func) (catch Exception e#
				  (.printStackTrace e#) (severe e#))))
	    ~name)) 

  (defonce *env* (atom {:period 240 :symbol "EURUSD"})) ;default +H4+, EURUSD
  (defn env
    ([] @*env*)
    ([key] (get @*env* key)))
  (defn env! [map] 
    (swap! *env* #(merge % map))
    map)

  (defmacro wenv [map & body] 
    `(binding [forex.util.core/*env*
	       (atom (merge @@~#'*env* ~map))]
       ~@body))

  ;;aliases for error kit
  (defn ns-export [from-ns]  
    (count (doall (map (fn [[sym var]]
			 (let [var-obj (if (.hasRoot var)
					 (intern *ns* sym (var-get var))
					 (intern *ns* sym))]
			   (when var-obj
			     (alter-meta! var-obj
					  (fn [old] (merge (meta var) old)))
			     var-obj)))
		       (ns-publics from-ns)))))

  (defmacro eval-when [& args]
    (eval `(do ~@args)) nil)

  (eval-when
   (require 'clojure.contrib.error-kit)
   (ns-export (find-ns 'clojure.contrib.error-kit)))

  (deferror *clj-forex-error* [] [message] 
    {:msg (str "clj-forex error: " message) 
     :unhandled (throw-msg Exception)})

  (defn throwf [msg & args] (raise *clj-forex-error* (apply format  msg args)))

  (defmacro is?
    [val & message]
    (if (vector? val)
      `(do ~@(map (fn [test] `(is? ~test ~@message)) val))
      `(let [result# ~val]
	 (if (not result#)
	   (throwf  ~(or (and (first message)
			      `(format ~@message))
			 (format "assertion %s failed"
				 (str val))))
	   result#))))
#+end_src 
*** General 
#+srcname:forex-util-general 
#+begin_src clojure :tangle src/forex/util/general.clj
  (ns forex.util.general 
    (:require  [clojure.contrib.str-utils2 :as s] clojure.string)
    (:import java.lang.management.ManagementFactory)
    (:require [matchure :as m]
	      [clojure.contrib.def :as d])
    (:use clojure.contrib.macro-utils))

  (defn dump-threads []
    (let [info (.dumpAllThreads (ManagementFactory/getThreadMXBean) false false)]
     (doall
      (map println info))
     (count info)))


  (defn seq1 [s]
    (reify clojure.lang.ISeq
      (first [_] (.first s))
      (more [_] (seq1 (.more s)))
      (next [_] (let [sn (.next s)] (and sn (seq1 sn))))
      (seq [_] (let [ss (.seq s)] (and ss (seq1 ss))))
      (count [_] (.count s))
      (cons [_ o] (.cons s o))
      (empty [_] (.empty s))
      (equiv [_ o] (.equiv s o))))
  (d/defalias defalias d/defalias)

  (defn upper? [s]
    (= (.toUpperCase s) s))

  (def join clojure.string/join)
  (def split s/split)
  (defn atom? [a] (or (symbol? a) (number? a)))

  ;;camel case - gotten from defrecord2 on github
  (defn- assemble-words [parts]
    (loop [remaining-parts parts result []]
      (if (seq remaining-parts)
	(let [part (first remaining-parts)]
	  (recur (rest remaining-parts)
		 (if (upper? part)
		   (conj result (.toLowerCase part))
		   (conj (if (seq result)
			   (pop result)
			   []) (str (last result) part)))))
	result)))



  (defn camel-to-dash
    "Convert a name like 'BigBlueCar' to 'big-blue-car'."
    [s]
    (let [parts (remove #(= "" %) (s/partition s #"[A-Z]"))
	  words (assemble-words parts)]
      (join "-" words)))
  ;;;

  (defn classpath []
    (seq (.getURLs (java.lang.ClassLoader/getSystemClassLoader))))

  (defn sequence? [a] (or (list? a) (vector? a) (seq? a)))
  (defn var-root-set [var val]
    (alter-var-root var (constantly val)))

  ;;copied from 
  (defprotocol PCachingStrategy
    "A caching strategy implements the backend for memoize. It handles the
    underlying cache and might define different strategies to remove old
    items from the cache."
    (retrieve [cache item] "Get the requested cache item.")
    (cached?  [cache item] "Checks whether the given argument list is cached.")
    (hit      [cache item] "Called in case of a cache hit.")
    (miss     [cache item result] "Called in case of a cache miss."))

  (declare naive-cache-strategy)

  (defn mem
    "Returns a memoized version of a referentially transparent function.
    The memoized version of the function keeps a cache of the mapping from
    arguments to results and, when calls with the same arguments are repeated
    often, has higher performance at the expense of higher memory use.
    Optionally takes a cache strategy. Default is the naive safe all strategy."
    ([f] (mem f (naive-cache-strategy)))
    ([f strategy]
     (let [cache-state (atom strategy)
	   hit-or-miss (fn [cache item]
			 (if (cached? cache item)
			   (hit cache item)
			   (miss cache item (delay (apply f item)))))]
       (fn [& args]
	 (let [cs (swap! cache-state hit-or-miss args)]
	   @(retrieve cs args))))))

  (deftype ^{:private true} NaiveStrategy [cache]
    PCachingStrategy
    (retrieve
      [_ item]
      (get cache item))
    (cached?
      [_ item]
      (contains? cache item))
    (hit
      [this _]
      this)
    (miss
      [_ item result]
      (NaiveStrategy. (assoc cache item result))))

  (defn- naive-cache-strategy
    "The naive safe-all cache strategy for memoize."
    []
    (NaiveStrategy. {}))  2



  ;;;;;;;;;;;;;;;;;;
  ;;;;;;;;;;;;;;;;;

  (defmacro defonce-
    "Same as defonce but yields a private definition"
    ([name expr]
       (list `defonce (with-meta name (assoc (meta name) :private true)) expr))
    ([name expr doc]
       (list `defonce (with-meta name (assoc (meta name) :private true :doc doc)) expr)))
  (defmacro def-
    "Same as def but yields a private definition"
    [name & decls]
    (list* `def (with-meta name (assoc (meta name) :private true)) decls))
  (defmacro defmacro-
    "Same as defmacro but yields a private definition"
    [name & decls]
    (list* `defmacro (with-meta name (assoc (meta name) :private true)) decls))
  ;;WARNING: this can screw up protocols implemented on existing object - i.e. replace them, they no longer work! so you have to create new object. how to fix this???...
  (defn reload
    ([] (reload *ns*))
    ([n]
       (let [name (cond (symbol? n) n true (ns-name n))]
	 (require name :reload-all))))

  (def- *fake* (gensym))
  (defmacro defrecord+ 
    [record-name fields-and-values constructor-name & record-body] 
    (let [fields-and-values (map #(if (vector? %) % [% nil])
				 fields-and-values) 
	  fields            (vec (map first fields-and-values)) 
	  default-map       (into {} fields-and-values)
	  fn-name (symbol (or (and constructor-name (str constructor-name))
			      (str "new-" (name record-name))))] 
      `(do 
	 (defrecord ~record-name 
	     ~fields 
	   ~@record-body) 
	 (defn ~fn-name
	   ([] (~fn-name ~#'*fake* nil))
	   ([& {:keys ~fields :or ~default-map}] 
	      (new ~record-name ~@fields))))))


  (binding [*out* *out*] (defn- log [e] (.println *out* (str "ERROR!: " e))))

  ;;TODO: get rid of!
  (defmacro mapc [& args] `(dorun (map ~@args)))
  (defmacro thread [& body]
    `(let [thread# (Thread. (bound-fn [] (try (do ~@body) (catch Exception e# (log e#)))))]
       (.start thread#)
       thread#))

  (defmacro is [val & message]
    `(let [result# ~val]
       (if (not result#)
	 (throw (Exception. ~(or (and (first message) `(format ~@message)) (format "assert: %s" (str val)))))
	 result#)))
  ;;TODO: efficiency: timeout without throwing exception? and definitely a timeout with all that thread hastle!
  ;; this should be done in a thread pool!
  (defmacro pf [& args]
    `(print (format ~@args)))

  (comment
    (defmacro throwf [message & args]
     (if args
       `(throw (Exception. (format ~message ~@args)))
       `(throw (Exception. ~message)))))

  (defn group
    ([coll] (group coll 2))
    ([coll by] (partition-all by coll)))

  (defmacro do1 [a & body]
    `(let [ret# ~a]
       ~@body
       ret#))
  (defmacro mapc [& args] `(dorun (map ~@args)))
  (defn sleep [s] (Thread/sleep (* 1000 s)))


  (defmacro on [[& args] & body]
    (let [a (group args 2)
	  first-args (map first a)
	  second-args (map second a)]
      `(doseq [[~@first-args] (map vector ~@second-args)]
	 ~@body)))





  (defalias if-match m/if-match)
  (defalias when-match m/when-match)
  (defalias cond-match m/cond-match)
  (defmacro match
    "match item with caluses"
    [item & clauses] 
    (let [msg-gen (gensym)]
      `(let [~msg-gen ~item] 
	 (cond-match
	  ~@(mapcat (fn [[test body]]
		      `[[~test ~msg-gen] ~body]) (group clauses 2))))))
#+end_src

*** Log
#+srcname:forex-util-log 
#+begin_src clojure :tangle src/forex/util/log.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.log
    (:clone clj.core)
    (:import [java.util.logging Logger Level LogManager Handler
	      FileHandler SimpleFormatter ConsoleHandler])
    (:require [clojure.contrib.duck-streams :as f])
    (:use forex.util.emacs forex.util.general))

  ;;TODO: minor mode
  (defvar log-dir "%h/.forex")

  (defn- formatter []
    (let [d (java.util.Date.)]
      (proxy [java.util.logging.Formatter] []
	(format [r] 
		(clojure.core/format "%s%n%s: %s%n%n"
				     (do (.setTime d (.getMillis r)) d)
				     (.getLevel r)
				     (.getMessage r))))))

  ;;wrap the PrintWriter *out* in an OutputStream to be used in ConsoleHandler
  (defn- new-out-stream [out]
    (proxy [java.io.OutputStream] []
      (close [] (.close out))
      (flush [] (.flush out))
      (write ([b] (.print out (String. b)))
	     ([b off len] (.print out (String. b off len))))))

  ;;TODO: if user deletes log file, it will not be recreated
  ;;this will create a logger which logs to /home/dir/.forex/log.log and will output to System/out (in emacs+slime, this is in the *inferior-lisp* buffer
  ;;or in the *shell* if you do lein swank

  (defn- new-logger [file]
    (f/make-parents
     (java.io.File. (format "%s/.forex/%s" (System/getProperty "user.home") file)))
    (let [l (java.util.logging.Logger/getLogger (str *ns*))]
      (mapc #(.removeHandler l %) (.getHandlers l))
      (.addHandler l (doto (ConsoleHandler.) (.setFormatter (formatter))) ;;(new-out-stream *out*) = to *out*, but sort of clutters everything
		   )
      (.addHandler l (doto (FileHandler. (str log-dir "/" file))
		       (.setFormatter (formatter))))
      (.setUseParentHandlers l false)
      l))

  (defonce- log (java.util.logging.Logger/getLogger (str *ns*)))

  ;;TODO: only use one log file!!! eh?
  (defn init-logger []
    (if-not log
     (def- log (new-logger "log"))))
  (init-logger)
  ;;TODO: set filtering levels
  ;;fine,finer,finest wont log

  (def- *debug-info* "")
  (defmacro debugging [str & args] `(binding [*debug-info* ~str] ~@args))

  (defn info [msg & args]
    (.info log (apply format (str *debug-info* " " msg) args)))
  (defn out [msg & args]
    (println (apply format (str "INFO: " *debug-info* " " msg) args))
    (apply info msg args)
    nil)

   (defn fine [msg & args]
     (.fine log (apply format  (str *debug-info* " " msg) args)))
   (defn finer [msg & args]
     (.finer log (apply format (str *debug-info* " " msg) args)))
   (defn finest [msg & args]
     (.finest log (apply format (str *debug-info* " " msg) args)))
  (defn severe [msg & args]
    (let [s (apply format (str *debug-info* " " msg) args)]
      (.severe log s)
      (print (format "SEVERE: %s%n" s))))
  (defn warn [msg & args]
    (let [s (apply format (str *debug-info* " " msg) args)]
      (.warning log s) 
      (print (format "WARNING: %s%n" s))))
#+end_src

*** Fiber
#+srcname:forex-util-fiber-spawn
#+begin_src clojure :tangle src/forex/util/fiber/spawn.clj
  ;;inspired by gambit-c termite's syntax
  (ns forex.util.fiber.spawn
    (:use forex.util.general)
    (:require [forex.util.fiber.mbox :as m]))

  ;;TODO: will eventually integrate with zeromq and will be able to be 'reactive' so we avoid
  ;;java's thread pool limit (or somehow get kilim to work?)
  ;;TODO: also, should we allow functions like ?? to discard messages? Perhaps not?
  ;;TODO: user settable default return value?
  ;;TODO: linking, remote nodes
  ;;utils
  (defonce- *mailboxes* (atom {}))
  (defn- make-mailbox [tag]
    (let [mb (m/new-mbox)]
      (swap! *mailboxes* assoc tag mb)
      mb))
  (defonce- *threads* (atom {}))

  (defn- remove-pid [pid]
    (when pid (swap! *threads* dissoc pid) (swap! *mailboxes* dissoc pid)))
  (defn- get-mailbox [tag]
    (get @*mailboxes* tag))
  (defn pid? [pid]
    "test for valid pid"
    (and (get-mailbox pid) true))

  (defonce- *mb* (ThreadLocal.))
  (defonce- *self* (ThreadLocal.)) 
  (defn- mb [] (.get *mb*)) 

  ;; functions
  (let [r (java.util.Random.)]
    (defn make-tag []
      "produce a random tag/pid"
      (Long/toString (Math/abs (.nextLong r)) 36)))

  (defn ?? []
    (m/?? (mb) nil))
  (defn- throwf [& args] (throw (Exception. (apply format args))) )

  (defn !
    "send a message to a pid, with an option id which the message will be placed in"
    ([pid msg] (! pid nil msg))
    ([pid id msg]
       (if-let [mbox (get-mailbox pid)]
	 (m/! mbox id msg)
	 (throwf "unknown pid %s" pid))))
  (binding [*out* *out*] (defn- log [& args] (println (apply format args))))
  (defn self []
    "returns pid of current spawn or nil if it isnt a spawnage"
    (.get *self*))
  (defn spawn
    ([thunk] (spawn thunk nil))
    ([thunk name]
       (let [tag (make-tag)
	     mail (make-mailbox tag)]
	 (let [thread (let [thread (Thread.
				    (bound-fn
				     [] 
				     (try 
				       (do (.set *mb* mail) (.set *self* tag)
					   (thunk))
				       (catch Exception e
					 (log "pid %s error: %s " (self) e)
					 (.printStackTrace e)
					 )
				       (finally (remove-pid tag)))))]
			(if name (doto thread (.setName name)) thread))]
	   (swap! *threads* assoc tag thread)
	   (.start thread))
	 tag)))

  (defn- assert-spawn [] (when (not (self)) (throwf "no local spawn available")))
  ;;does work - but we dont really need it!

  (defn spawn-in-repl []
    "setup current thread as a spawned thread with mailbox"
    (let [tag (make-tag)]
      (remove-pid self)
      (.set *mb* (make-mailbox tag)) (.set *self* tag) (swap! *threads* assoc tag (Thread/currentThread))
      tag)) 

  (def- *?* nil)

  (defn ?
    "receive"
    ([] (? nil nil))
    ([timeout] (? timeout nil))
    ([timeout default] 
       (assert-spawn)
       (or (m/? (mb) nil timeout) default))) 

  (defmacro recv- [item & clauses]
    "match item with caluses"
    (let [msg-gen (gensym)]
      `(let [~msg-gen ~item]
	 (cond-match ~@(mapcat (fn [[test body]]
				 `[[~test ~msg-gen] ~body]) (group clauses 2))))))
  (defmacro recv [& clauses]
    "receive a message from current spawned thread mailbox"
    `(let [msg# (?)]
       (recv- msg# ~@clauses)))
  (defmacro recv-if [& clauses]
    "receive only if a message is in queue"
    `(let [msg# (? 0)]
       (recv- msg# ~@clauses)))

  (comment
    ;;until we figure out why soft-timeout doesnt work... we're leaving this here!
    (defn ??
      "asynchronous with timeout: wait for a receive filtered by the function, discarding any other messages received"
      ([function] (?? function nil))
      ([function timeout]
	 (soft-timeout! *?* timeout
	   (loop []
	     (let [msg (?)]
	       (if-let [it (function msg)]
		 msg
		 (recur))))))))

  (comment
    ;;until we figure out why soft-timeout doesnt work... we're leaving this here!
    (defn !?
      "asynchronous with timeout: send message with a tag and then receive back, discarding any other messages received"
      ([pid data] (!? pid data nil))
      ([pid data timeout]
	 (soft-timeout! *?* timeout
	   (let [tag (make-tag)]
	     (! pid [(self) tag data])
	     (loop []
	       (let [msg (?)]
		 (recv- msg
		   [(= ? tag) ?response] response
		   ? (recur)))))))))


  (defn stop-all 
    "stops all threads spawned. probably only useful for debugging, and assuming they respond to stop"
    []
    (map #(! % "stop") (keys @*threads*)))

  (defn kill-all
    []
    (map #(.stop %) (vals @*threads*)))
#+end_src
  
#+srcname:forex-util-fiber-mbox
#+begin_src clojure :tangle src/forex/util/fiber/mbox.clj
  ;;modified from
  ;;https://github.com/jochu/swank-clojure/tree/master/src/swank/util/concurrent/
  (ns forex.util.fiber.mbox
    (:use forex.util.general))

  ;; Holds references to the mailboxes (message queues)
  (defn- _get
    "Returns the mailbox for a given id. Creates one if one does not
     already exist."
    ([p id]
       (dosync         
	(when-not (get @(:boxes p) id)  
	  (alter (:boxes p) assoc
		 id (java.util.concurrent.LinkedBlockingQueue.)))
	(@(:boxes p) id)))
    {:tag java.util.concurrent.LinkedBlockingQueue})

  (defn !
    "Sends a message to a given id."
    ([p id message] 
       (let [mbox (_get p id)]
	 (.put mbox message))))


  (defn ??
    "poll in milliseconds"
    ([p] (?? p nil))
    ([p id]
       (let [mb (_get p id)]
	 (.peek mb))))

  (defn ?
    "poll in milliseconds"
    ([p id] (? p id nil))
    ([p id timeout]
       (is (or (not timeout) (and (number? timeout) (>= timeout 0))) "timeout must be nil or a positive number")
       (let [mb (_get p id)]
	 (cond
	   (not timeout) (.take mb)
	   true (.poll mb timeout java.util.concurrent.TimeUnit/MILLISECONDS)))))

  (defrecord+ mbox [[boxes (ref {})]]
    new-mbox)
#+end_src

#+srcname:forex-util-emacs
#+begin_src clojure :tangle src/forex/util/emacs.clj
  (ns forex.util.emacs (:use forex.util.general))

  (defn ns-vars
    ([] (ns-vars *ns*))
    ([ns] (let [vars (filter #(:var (meta  %)) (vals (ns-interns ns)))]
	    (apply hash-map (interleave vars (map var-get vars))))))

  (defmacro defvar
    ([name]
       (let [new-name (with-meta name (assoc (meta name) :var true))]
	 `(defonce ~new-name nil)))
    ([name init]
       (let [new-name (with-meta name (assoc (meta name) :var true))]
	 `(defonce ~new-name ~init))))

  (defmacro setq [& args]
    `(do ~@(map
	    (fn [[var val]]
	      `(alter-var-root #'~var (fn [a#] ~val)))
	    (group args))))


  (defn- member
    ([value list] (member value list =))
    ([value list test]
       (some #(test % value) list)))

  (defn add-to-list [var arg]
    (when-not (member arg (var-get var))
      (alter-var-root var (fn [it] (concat (list arg) it)))))

  (defn push [var val]
    (alter-var-root var (fn [it] (concat (list val) it))))

  (defn add-hook [hook function] (push hook function))

  (defn run-hooks [& hooks]
    (mapc (fn [hook] (mapc #(%) hook)) hooks))

  (defn run-hook-with-args [hook & args]
    (mapc #(apply % args) hook))

  (defn run-hook-with-args-until-success [hook & args]
    (is (sequence? hook) "hook %s isnt a list" hook)
    (loop [funcs hook]
      (cond
	(empty? funcs) nil
	true (if-let [it (apply (first funcs) args)]
	       it
	       (recur (rest funcs))))))

  (defn run-hook-with-args-until-failure [hook & args]
    (is (sequence? hook) "hook %s isnt a list" hook)
    (loop [funcs hook]
      (cond
	(empty? funcs) true
	true (when (apply (first funcs) args)
	       (recur (rest funcs))))))


  ;;(run-hook-with-args-until-success 'a 3)
#+end_src
*** Spawn
#+srcname:forex-util-spawn
#+begin_src clojure :tangle src/forex/util/spawn.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.spawn
    (:clone clj.core) 
    (:use forex.util.general forex.util.zmq)
    (:require [forex.util.fiber.spawn :as s]))

  (def- *pid* (atom []))

  (defalias pid? s/pid?)
  (defalias self s/self)
  (def kill-all s/kill-all)
  (defalias spawn-in-repl s/spawn-in-repl) ;;TODO: add socket for this one

  (defalias ? s/?)

  (defalias make-tag s/make-tag)
  (defn ! [pid msg]
    (with-open [local (doto (new-socket +push+)
			(.connect (format "inproc://%s" pid)))]
      (s/! pid msg)
      (.snd local "REQUEST" +noblock+)))
  (defn  stop-all []
    (swap! *pid*
	   (fn [old]
	     (map #(if (pid? %)
		     (! % "STOP")) @*pid*))))


  (defrecord LocalSocket [socket]
    PSocket
    (raw [this] (.raw socket)) 
    (recv [this flags] 
	  (let [r (.recv socket flags)]
	    (s/?)))
    (recv [this] (recv this 0))
    (close [this] (.close socket))
    (hasMore [this] false))


  (comment
    (defn te []
     (def pid (spawn #(do (pr "BEFORE") (pr local)
			  (pformat "local %s%n" (first (event-seq [local])))
			  (pr "AFTER"))))))


  (defonce- *local* (ThreadLocal.))
  (defn- self-get [key]
    (let [map (.get *local*)]
      (when map 
	(map key))))
  (defn- self-assoc [key obj]
    (let [map (.get *local*)]
      (if map 
       (.set *local* (assoc map key obj)))))
  (def local nil)
  (defn spawn
    ([thunk] (spawn thunk nil))
    ([thunk name] 
       (let [pid (s/spawn
		  (fn [] 
		    (.set *local* {})
		    (with-open
			[local-socket (LocalSocket. 
				       (doto
					   (new-socket +pull+)
					 (.bind  (str "inproc://" (self)))))]        
		      (binding [local local-socket]
			(thunk))))
		  name)]
	 (swap! *pid* concat [pid])
	 pid)))

  (defmulti event-seq class)
  (defmethod event-seq clojure.lang.IPersistentVector [v]
    (event-seq (new-poller v)))
  (defmethod event-seq forex.util.zmq.Poller [p]
    ((fn the-seq [p] 
       (lazy-seq
	(let [amount (.poll p)] 
	  (concat (for [i (range 0 (.getSize p)) :when (.pollin p i)]
		    (let [sock (.getSocket p i)
			  msg 
			  (loop [msg [(.recv sock 0)]]                    
			    (if (.hasMore sock)
			      (recur (cons (String. (.recv sock 0)) msg))
			      msg))]
		      [sock (if (= (count msg) 1) (first msg) (vec msg))]))
		  (the-seq p)))))
     p)) 

  ;;? with multiple sources or change to poll
  ;;!? (timeout)
  ;;?? (filter)
#+end_src
*** ZMQ
#+srcname:forex-util-zmq
#+begin_src clojure :tangle src/forex/util/zmq.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.util.zmq
    (:clone clj.core)
    (:import (org.zeromq ZMQ))
    (:use forex.util.general))
  (def +noblock+ 1)

  (def +p2p+ 0)
  (def +pub+ 1)
  (def +sub+ 2)
  (def +req+ 3)
  (def +rep+ 4)
  (def +xreq+ 5)
  (def +xrep+ 6)
  (def +pull+ 7) 
  (def +push+ 8)

  (def +hwm+ 1)
  (def +lwm+ 2)
  (def +swap+ 3)
  (def +affinity+ 4)
  (def +identity+ 5)
  (def +subscribe+ 6)
  (def +unsubscribe+ 7)
  (def +rate+ 8)
  (def +recovery-ivl+ 9)
  (def +mcast-loop+ 10)
  (def +sndbuf+ 11)
  (def +rcvbuf+ 12)

  (def +pollin+ 1)
  (def +pollout+ 2)
  (def +pollerr+ 4)
  (def +more+ 2)

  ;;Context
  (defn new-context [io-threads]
    (ZMQ/context io-threads))
  (defonce *context* (new-context 1))

  (defprotocol PSocket
    (raw [this])
    (recv [this flags] [this])
    (bind [this address])
    (connect [this address])
    (hasMore [this])
    (close [this])
    (snd [this msg] [this msg flags])) 
  (defprotocol PPoller
    (setTimeout [this timeout])
    (poll [this])
    (register [this socket])
    (getSocket [this i])
    (getSize [this])
    (pollin [this i])) 
  (defrecord Poller [poll sockets] 
    PPoller 
    (getSize [this] (.getSize (:poll this)))
    (pollin [this i] (.pollin (:poll this) i))
    (setTimeout [this timeout] (.setTimeout (:poll this) timeout))
    (poll [this] (.poll (:poll this)))
    (register [this socket]
	      (.register (:poll this)
			 (if (extends? PSocket (class socket))
			   (.raw socket)
			   socket))
	      (swap! (:sockets this) conj socket))
    (getSocket [this i] (nth @(:sockets this) i)))

  (defn new-poller
    ([sockets] (new-poller *context* sockets))
    ([context sockets]
       (let [p (Poller. (.poller context (count sockets)) (atom []))]
	 (.setTimeout p -1)
	 (on [sock sockets]
	     (.register p sock))
	 p)))

  ;;TODO: now just a string socket!
  (defrecord Socket [socket]
    PSocket 
    (raw [this] socket)
    (snd [this msg] (.snd this msg 0))
    (snd [this msg flags]
	 (if (string? msg)
	   (.send socket (.getBytes msg) flags)
	   (.send socket msg flags))) 
    (recv [this flags] (when-let [it (.recv socket flags)] (String. it)))
    (recv [this] (recv this 0)) 
    (close [this] (.close socket))
    (bind [this address] (.bind socket address))
    (connect [this address] (.connect socket address))
    (hasMore [this] (.hasReceiveMore socket))) 

  (defn new-socket
    ([type] (new-socket *context* type))
    ([context type] (Socket. (.socket context type))))

  (comment
    (defn new-poll
      ([sockets] (new-poll *context* sockets))
      ([context sockets]
	 (let [p (.poller context (count sockets))]
	   (.setTimeout p -1)
	   (on [sock sockets]
	       (.register p (.socket sock)))
	   p)))

    (defn new-socket
      ([socket-type]
	 (new-socket *context* socket-type))
      ([context socket-type ]
	 (.socket context socket-type))))
#+end_src
*** Devel
#+srcname:forex-util-mql-devel
#+begin_src clojure :tangle src/forex/util/mql_devel.clj
  (clojure.core/use 'nstools.ns)
  (ns forex.utils.mql-devel
    (:clone clj.core)
    (:use utils.general))


  (defmacro cond-out [& args]
    (apply str (map (fn [a]
		      (let [name (str a)]
			(format " else if (command==\"%s\") {\n\t   ret = process_%s(request);\n\t}" name name)))
		    args)))

  (cond-out
   AccountBalance
   AccountCredit
   AccountCompany
   AccountCurrency
   AccountEquity
   AccountFreeMargin
   AccountLeverage
   AccountMargin
   AccountName
   AccountNumber
   AccountServer
   AccountProfit
   OrderLots
   OrderDelete
   OrderCloseTime
   OrderType
   OrdersTotal
   OrderSend
   MarketInfo
   OrderClose
   OrderModify)
#+end_src

#+srcname:forex-util-indicator-devel
#+begin_src clojure :tangle src/forex/util/mql_indicator_devel.clj
  (clojure.core/use 'nstools.ns)
  ;;this file allows one to automatically produce binding code for metatrader custom indicators
  (ns+ forex.utils.mql-indicator-devel
    (:clone clj.core)
    (:import java.io.File))

  (defmacro for+ [args & body]
    (let [a (partition-all 2 args)]
      `(map (fn ~(vec (map first a)) ~@body) ~@(map second a))))
  (defn throwf [msg & args]
    (throw (Exception. (apply format msg args))))

  (defn args [s]
    (map rest (re-seq #"extern\s+(\w+)\s+(\w+)" s)))
  (defn buffers [s]
    (count (re-seq #"SetIndexBuffer" s)))

  (defn extract [args]
    (let [type-to-fn (fn [type]
		       (condp = type
			   "int" "StrToInteger"
			   "double" "StrToDouble"
			   "string" nil
			   "color" "StrToInteger"
			   "bool" "StrToInteger"
			   (throwf "unknown type %s" type)))
	  user-extract (apply str
			      (interpose "\n"
					 (for+ [[type name] args index (iterate inc 6)]
					       (let [type-fn (type-to-fn type)]
						 (if type-fn
						   (format "%s %s = %s(command[%s]);" type name type-fn index)
						   (format "%s %s = command[%s];" type name index))))))
	  always (format "
  string symbol = command[2];
  int timeframe = StrToInteger(command[3]);
  int mode = StrToInteger(command[4]);
  int shift = StrToInteger(command[5]);")]
      (str always "\n" user-extract)))

  (defn extension [f] (let [e (second (.split (if (instance? File f) (.getName f) f) "\\."))] (if (string? e) (.trim e))))

  (defn to-test [all]
    (format "%nstring process_INDICATORS(string commands[]) {%nstring ret = \"\";string command=commands[1];%n%s%nreturn(ret);}"
	    (apply str
		   "if (command==\"0\") {\n}\n"
		   (map #(format "else if (command==\"%s\") {%nprotocol_found=true;%nret = %s(commands);%n}%n" (:function-name %) (:function-name %)) all))))


  (defn- listify [s] (if-not (empty? s) (str (apply str (interpose "," s)) ",") "" ))
  (defn name-of [f] (first (.split (.getName f) "\\.")))
  (defn iCustom
    "given a file, generate mql4 binding code to the indicator in the flie"
    [f]
    (let [name (.replaceAll (first (.split (.getName f) "\\.")) "( |-)+" "_")
	  s (slurp f)
	  args (map #(list (first %) (format "i_%s" (second %))) (args s))
	  buffers (buffers s)]
      (when (and s args buffers)
	(let [custom (format "double val = iCustom(symbol,timeframe,\"%s\",%smode,shift);" ;
					       (name-of f) (listify (map second args))) 
	      extract (extract args)

	      return (format
		      "
  int err = GetLastError();
  if(err!=0)
    return(\"error \" + err);
  return(val); 
  }")
	      function-name (format "Custom_%s" name)
	      function-header (format "string %s (string command[]) {" function-name)] 
	  {:file f :file-name name :function-name function-name :args args :buffers buffers
	   :code  (format "%s %s %s %s" function-header extract custom return)}))))

  (defn iCustom-all [dir out]
    (let [files (.listFiles (File. dir))
	  customs (for [f files :when (= (extension f) "mq4")] (iCustom f))]
      (spit out (format "bool protocol_found = false;%n%s\n%s" (apply str (interpose "\n\n" (map :code customs)))
			(to-test customs)))))


  ;;example usage - first param is custom indicator folder, second is output file
  (defn do-it []
    (iCustom-all
     "/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/indicators/"
     "/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/include/INDICATORS.mqh"))
#+end_src

** Backend
*** MQL Socket Service
#+srcname:mql-socket-service
#+begin_src clojure :tangle src/forex/backend/mql/socket_service.clj
  ;;forex.backend.mql.socket-service: provide background sockets which allow us to connect with metatrader. Provides functions to interact with the background socket

  ;;todo: bug with stopping all and then stopping again! so bug with stop..
  (clojure.core/use 'nstools.ns)
  (ns+ forex.backend.mql.socket-service
       (:clone clj.core) 
       (:require
	[forex.util.fiber.mbox :as m]
	[clojure.contrib.logging :as l])
       (:use 
	forex.util.emacs 
	forex.util.core forex.util.general
	forex.util.zmq forex.util.log
	forex.util.spawn))

  ;;TODO: 3ms or so per request, a little slow...
  ;;also, unfortunately, if we add more servers, speed doesn't increase linearly. so the bottleneck is in the clojure code ... a better designed socket service should really be made.
  ;; in addition, if servers drop out, we will be waiting forever for them. this is bad.

  (defvar mql-socket-recv-address "tcp://127.0.0.1:3000")
  (defvar mql-socket-send-address "tcp://127.0.0.1:3005")
  (defvar mql-socket-pub-address "tcp://127.0.0.1:3010")
  (defonce *ids* (atom {})) 
  ;;utils  
  (defonce- *msg-id* (atom 0))
  (defn- msg-id []
    (str (swap! *msg-id* inc)))
  (defmacro catch-unexpected [& body]
    `(try (do ~@body)
	  (catch Exception e# (.printStackTrace e#) (warn e#))))

  ;;socket service
  ;;TODO: send id then message
  (defn- mql-recv [msg] 
    (catch-unexpected   
     (let [key (first msg)
	   msg-ask (get @*ids* key)] 
       (if-not (satisfies? PWait msg-ask)
	 (warn "Ignoring invalid msg: %s" msg)
	 (do  
	   (deliver msg-ask (second msg))
	   (swap! *ids* dissoc key))))))

  (comment
    (defn unblock []
      (doall (map #(deliver % (Exception. "unblock")) (keys *ids*)))))

  (comment ;;this causes problems ...deleted
    (if-not (satisfies?  PWait askin)
       (warn "Ignoring invalid REQUEST which does not contain a PWait argument %s %s" 
	     msg askin)))

  (defn- socket-service-match [events send receive]
    (match  
     (first events)
     [local "STOP"] (do (info "closing ...") "STOP")  
     [local ["REQUEST" ?msg ?askin]]  
     (let [id (msg-id)  
	   result  (.snd send (str id " " msg) +noblock+)]
       (if-not result  
	 (do  
	   (warn
	    "failed to queue request %s: are any metatrader scripts alive?"
	    msg)
	   (catch-unexpected
	    (deliver askin (Exception. "socket service down"))))
	 (swap! *ids* assoc id askin)))  
     [receive ?msg] (mql-recv msg)  
     ?msg (warn "Ignoring invalid message %s" msg)))

  ;;TODO: weird bugwhen stopping everything with an ea.

  (defn spawn-mql-socket-service
    []  
    (debugging
     "MQL Socket Service: " 
     {:pid 
      (spawn-log  
       #(with-open [send (doto (new-socket +push+)
			   (.bind mql-socket-send-address))
		    receive (doto (new-socket +pull+)
			      (.bind mql-socket-recv-address))]
	  (loop [events (event-seq [receive local])]
	    (when-not (= "STOP" (socket-service-match events send receive))
	      (recur (rest events)))))
       "MQL Socket Service")})) 

  ;;global socket service
  (defonce- *s* (atom nil))
  (defn alive? []
    (pid? (:pid @*s*))) 
  (defn start []
    (if (alive?)
      (warn "mql socket is already alive!")
      (reset! *s* (spawn-mql-socket-service))))
  (defn stop []
    (if (alive?)
      (! (:pid @*s*) "STOP")
      (warn "mql socket service is already stopped")))

  ;;interact with mql 
  (defn request [askin msg]
    (io!
     (if (pid? (:pid @*s*)) 
       (! (:pid @*s*) ["REQUEST" msg askin])
       (throwf "mql socket service is not alive"))))

  (defn receive
    ([msg] (receive msg nil))
    ([msg timeout]
       (let [askin (promise)]
	 (request askin msg)
	 (let [result (if (wait-for askin timeout) @askin)]
	   (cond
	    (instance? Exception result) (throw result)
	    result result
	    true (throwf "invalid result received %s" result))))))
#+end_src 
** Module 
*** Account
#+srcname:account-core
#+begin_src clojure :tangle src/forex/module/account/core.clj
  ;;forex.module.order.core - interface with mql backend
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.account.core
    (:clone clj.core)
    (:use forex.util.core
	  forex.util.emacs 
	  forex.util.general
	  forex.module.error))

  (def- order
    {:buy 0 :sell 1 :buy-limit 2 :sell-limit 3 :buy-stop 4 :sell-stop 5})

  (def- color
    {:red 230 :yellow 65535 :green 65280 :blue 13749760
     :purple  16711935 :white 16777215 :black 0})

  (defn- get! [hash key]
    (if-let [it (hash key)]
      it
      (throwf "invalid key %s in hash %s" key hash)))

  ;;the below can throw errors - how to handle this? 
  (defn order-modify
    ([ticket price sl tp]
       (order-modify ticket price sl tp :blue))
    ([ticket price sl tp color_of]
       (receive
	(format "OrderModify %s %s %s %s %s"
		ticket price sl tp (get! color color_of)))
       ;;{:id ticket :price price :sl sl :tp tp :color color_of}
       ))

  (defn order-send
    ([symbol cmd volume price] (order-send symbol cmd volume price 0 0))
    ([symbol cmd volume price sl tp] (order-send symbol cmd volume price sl tp 3))
    ([symbol cmd volume price sl tp slip]
       (receive
	(format "OrderSend %s %s %s %s %s %s %s"
		symbol (get! order cmd)
		volume price slip sl tp))))

  (defn order-close-time [ticket]
    (receive-int (format "OrderCloseTime %s" ticket)))

  (defn order-close [ticket lots price slippage color_of]
    (receive  
     (format "OrderClose %s %s %s %s %s"
	     ticket lots price slippage (get! color color_of))))
  (defn order-delete [ticket]
    (receive (format "OrderDelete %s" ticket)))

  (defn market-info [symbol type]
     (receive-double (format "MarketInfo %s %s" symbol type)))

  (defn order-close-time [ticket]
    (receive-double (format "OrderCloseTime %s" ticket)))

  (defn order-type [ticket]
    (receive-double (format "OrderType %s" ticket)))

  (defn order-lots [ticket]
    (receive-double (format "OrderLots %s" ticket)))
#+end_src
 
#+srcname:account-utils
#+begin_src clojure :tangle src/forex/module/account/utils.clj
  (clojure.core/use 'nstools.ns)

  (ns+ forex.module.account.utils
    (:clone clj.core)
    (:use forex.util.core
	  forex.util.emacs  
	  forex.util.general
	  forex.module.error)
  ;;  (:require forex.module.error [forex.module.error :as err])
    (:require  [forex.module.account.core :as core]))


  ;;account common
  (defn- sym [a] (symbol (camel-to-dash a)))
  (defmacro- single [name] `(defn ~(sym name) [] (receive! ~name)))
  (defmacro- double-single [name] `(defn ~(sym name) [] (receive-double! ~name)))
  (defmacro- singles [& names] `(do ~@(map (fn [a] `(single ~a)) names)))
  (defmacro- double-singles [& names] `(do ~@(map (fn [a] `(double-single ~a)) names)))

  ;;none of the below singles or double-singles should throw a mql error - therefore, it is a bug if they do
  (singles 
   "AccountCurrency"
   "AccountCompany"
   "AccountServer" 
   "AccountName"
   "AccountNumber")

  (double-singles
   "AccountCredit"
   "AccountBalance"
   "AccountEquity"
   "AccountFreeMargin"
   "AccountLeverage"
   "AccountMargin"
   "AccountProfit"
   "OrdersTotal")
  ;;

  (defmacro- define-market-info [& args]
    `(do ~@(map (fn [[name num]]
		  `(defn ~(symbolicate "mode-" name)
		     ([] (~(symbolicate "mode-" name) (env :symbol)))
		     ([symbol#]
			(let [res# (core/market-info symbol# ~num)]
			  (if (e? res#)
			    (throwf "market-info error %s" (:e res#))
			    res#)))))
		(group args)))) 

  (define-market-info
    low 1
    high 2
    time 5
    bid 9
    ask 10
    point 11
    digits 12
    spread 13
    stoplevel 14
    lotsize 15
    tickvalue 16
    ticksize 17
    swaplong 18
    swapshort 19
    starting 20
    expiration 21
    trade-allowed 22
    minlot 23
    lotstep 24
    maxlot 25
    swaptype 26
    profitcalcmode 27
    margincalcmode 28
    margininit 29
    marginmaintenance 30
    marginhedged 31
    marginrequired 32
    freezelevel 33)

  (defn demo? []
    (if (re-find #"(?i)demo" (account-server))
      true
      false))

  (defn sell? [{type :type}]
    (or (= type :sell) (= type :sell-stop) (= type :sell-limit)))
  (defn buy? [{type :type}]
    (or (= type :buy) (= type :buy-stop) (= type :buy-limit)))
  (defn- to-big [num] (BigDecimal/valueOf (if (integer? num) (double num) num)))
  (defn lot 
    ([num] (lot num (env :symbol)))
    ([num symbol]
       (let [a (to-big num)
	     b (to-big (mode-minlot symbol))]
	 (* b (.intValue (/ a b))))))


  (defn- assert-order [order] (is? [(or (sell? order) (buy? order))]))

  (defn o-- [o & args]
    (assert-order o)
    (if (sell? o) (- (apply - args)) (apply - args)))

  (defn o+ [o & args]
    (assert-order o) 
    (if (sell? o) (apply - args) (apply + args)))
  (defn o- [o & args]
    (assert-order o)
    (if (sell? o) (apply + args) (apply - args)))

  (defn omax [order & args]
    (assert-order order)
    (let [args (filter #(not (zero? %)) args)]
      (if (empty? args)
	(or (:sl order) 0) 
	(apply (if (buy? order) max min) args))))

  (defn omin [order & args]
    (assert-order order)
    (let [args (filter #(not (zero? %)) args)]
      (if (empty? args)
	(or (:sl order) 0) 
	(apply (if (buy? order) min max)
	       args))))


  ;;TODO: change for 4 digit broker
  (defn digit []
    (let [pt (mode-point "EURUSD")]
      (cond
       (= pt 0.00001) 5
       (= pt 0.0001) 4
       true (throwf
	     "unexpected broker digits given mode-point of % on EURUSD" pt))))

  ;;TODO: check for valid symbol on all of this??
  (defn spread
    ([] (spread (env :symbol)))
    ([symbol]
       (let [d (digit) spread (mode-spread symbol)]
	 (cond
	  (= d 5) (/ spread 10)
	  (= d 4) spread))))

  (defn point
    ([pt] (/ pt (point)))
    ([]
       (let [d (digit)] 
	 (if (= d 5)
	   (* 10 (mode-point))
	   (mode-point)))))

  (defn pip [pt] (* (point) pt))
#+end_src

#+srcname:account-common
#+begin_src clojure :tangle src/forex/module/account.clj
  ;;TODO: unit test everything
  ;;TODO: create a new atom-hash on merging, etc????????
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.account
    (:clone clj.core)
    (:use forex.util.core
	  forex.util.emacs  
	  forex.util.general forex.util.log
	  forex.module.indicator
	  forex.module.error forex.module.account.utils)
    (:require forex.module.error [forex.module.error :as err])
    (:require  [forex.module.account.core :as core]))

  (defvar *account-warn-on-mql-error* true)

  (defn- account-warn
    ([err order] (account-warn err order ""))
    ([err order msg & args]
       (if *account-warn-on-mql-error* 
	 (do (warn "MQL error %s on order %s - %s" (:e err)
		   order (apply format msg args)) err)
	 err)))
  (defmacro- with-order [order & body]
    `(let [o# ~order]
       (if-not (= (:lots o#) 0)
	 (do ~@body)
	 (do (warn "attempting to change order %s with zero lots" o#)
	     o#)))) 

  (defn- >? [a] (and (number? a) (>= a 0)))

  (defmacro- default [& body] 
    `(binding [*default* @~#'err/*er*]
       ~@body))

  ;;TODO: do we need all of these assertions?
  (def- value-to-order-type
    {0 :buy 1 :sell 2 :buy-limit
     3 :sell-limit 4 :buy-stop
     5 :sell-stop}) 

  (defprotocol POrder
    (order-close-time [this])
    (order-type [this])
    (delete! [this] )
    (close! [this] [this new-lots])
    (modify! [this sl-tp-map])
    (order! [this])
    (open? [this]) (close? [this])
    (order? [this]) 
    (market? [this]) (entry? [this]))

  (defn- order-close-time* [{id :id}]
    (is? (string? id))
    ;;we dont need to know mql4 error codes for order close time
    (aif (core/order-close-time id) it -1)) ;;TODO: return 0 instead?
  (defn- order-type*  [order]
    (is? (string? (:id order)))
    (default
      (aif (core/order-type (:id order))
	   (value-to-order-type (int it)))))

  (defn- delete!* [{id :id lots :lots :as o}]
    (with-order o
      (if-not (= lots 0)
	(aif (core/order-delete id) (merge o {:lots 0}) it)
	o)))


  (defn- close!*
    ([o] (close! o 0))
    ([{:keys [price lots slip id symbol] :as order} new-lots]
       (with-order order
	 (is? [(string? id) (string? symbol) 
	       [price (pos? price)]
	       [(number? lots) (>= lots 0)]])
	 (is? (>= (- lots new-lots) 0))
	 (if-not (= new-lots lots)
	   (aif (core/order-close id (- lots new-lots)
				  (if (sell? order)
				    (ask symbol)
				    (bid symbol))
				  slip :blue)
		(merge order {:lots new-lots})
		(account-warn it order "invalid new lots %s" new-lots))
	   order))))

  ;;TODO: normalize so we dont get mql error 1?
  (defn- modify!* [order {:keys [sl tp] :as mod}]
    (with-order order
      (let [sl (or sl (:sl order) 0)
	    tp (or tp (:tp order) 0)
	    price (:price order)]
	(is? [sl tp price (>? sl) (>? tp) (pos? price)]) 
	(if-not (and (= sl (:sl order))
		     (= tp (:tp order)))
	  (aif (core/order-modify (:id order) (:price order) sl tp)
	       (merge order (merge mod {:sl sl :tp tp}))
	       (if (= (:e it) 1)
		 (merge order mod)
		 (account-warn it order "sl %s tp %s" sl tp)))
	  (merge order mod)))))  

  ;;TOODOs: how do we get map with defaults?
  (defn- verify-order [{:keys [slip symbol type price tp sl lots]
			:or {slip 3 sl 0 tp 0}}]
    (is? [(number? slip) (> slip 0) (integer? slip)]
	 "invalid order slip %s" slip)
    (is? [ (keyword? type) (number? lots)
	   (number? tp) (number? sl) (number? price)]) 
    (is? [ (string? symbol) (> lots 0)
	   (>= tp 0) (>= sl 0) (>= price 0)])  
    (cond
     (or (= type :sell) (= type :sell-limit) (= type :sell-stop))
     (is? (or (and (zero? sl) (zero? tp))
	      (and (zero? sl) tp (< tp price))
	      (and (zero? tp) sl (> sl price))
	      (and (< tp sl) (< tp price) (> sl price)))
	  "invalid %s order with sl/tp %s/%s with price of %s" type sl tp price)
     (or (= type :buy) (= type :buy-limit) (= type :buy-stop))
     (is? (or (and (zero? sl) (zero? tp))
	      (and (zero? sl) tp (> tp price))
	      (and (zero? tp) sl (< sl price))
	      (and (> tp sl) (> tp price) (< sl price)))
	  "invalid %s order with sl/tp %s/%s with price of %s" type sl tp price)
     true (throwf "invalid %s order with sl/tp %s/%s with price of %s"
		  type sl tp price))) 
  ;;TODO: change to make reliable and to work for ECN brokers and such
  ;;see http://forum.mql4.com/36608
  ;;TODO: what happens if second modify fails? how can programmer find this out?

  (defn- order!* [{:keys [symbol type price tp sl lots slip]
		   :as order
		   :or { symbol (env :symbol) sl 0 tp 0 slip 3}}]
    (let [price (or price (if (sell? order) (bid symbol) (ask symbol)))
	  order (merge 
		 {:symbol symbol
		  :slip slip}
		 (merge order {:sl 0 :tp 0 :id "" :price price}))]
      (with-order order    
	(verify-order order)
	(aif (core/order-send symbol type lots price 0 0 slip)
	     (let [result
		   (let [o (merge order {:id it})]
		     ;;now, use modify to change sl and tp
		     (aif (modify!* o {:sl sl :tp tp})
			  (merge o {:sl sl :tp tp})
			  o))
		   spread (spread)]
	       (merge result {:spread spread :break (o+ result price (pip spread))})) 
	     (account-warn it order))))) 

  (defn- open?* [order] 
    (default (= (order-close-time order) 0)))
  (defn- close?* [order]
    (not (open? order)))
  (defn- order?* [order]
    (not (nil? (order-type order))))   
  (defn- market?*
    "determine if order is market order"
    [order]
    (let [type (order-type order)]
      (or (= type :sell) (= type :buy)))) 
  (defn- entry?*
    "determine if order is entry order"
    [order]
    (let [type (order-type order)]
      (and type (not (or (= type :sell) (= type :buy))))))

  (extend clojure.lang.IPersistentMap
    POrder {:order-close-time order-close-time*
	    :order-type order-type*
	    :delete! delete!*
	    :close! close!*
	    :modify! modify!*
	    :order! order!*

	    :open? open?*
	    :close? close?*
	    :order? order?*
	    :market? market?*
	    :entry? entry?*})

  (extend-type forex.module.error.MqlError
    POrder
    (order! [this] this)
    (delete! [this] this)
    (close! [this] this)
    (modify! [this] this))

  (extend-type forex.util.core.AtomHash ;;clojure.lang.Atom
    POrder
    (order-close-time [this] (order-close-time @this))
    (order-type [this] (order-type @this))
    ;;(order! [this] (aif (order! @this) (do (reset! (.val this) it) this) it))
    (delete! [this] (aif (delete! @this) (do (reset! (.val this) it) this) it))  
    (close!
     ([this new-amount] (aif (close! @this new-amount) (do (reset! (.val this) it) this) it))
     ([this] (close! this 0)))
    (modify! [this sl-tp] (aif (modify! @this sl-tp) (do (reset! (.val this) it) this) it))
    (open? [this] (open? @this))
    (close? [this] (not (open? @this)))
    (order? [this] (order? @this))
    (market? [this] (market? @this))
    (entry? [this] (entry? @this)))
#+end_src
*** Ea
#+srcname:ea-common
#+begin_src clojure :tangle src/forex/module/ea.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.ea 
    (:clone clj.core)
    (:use forex.util.core
	  forex.util.general
	  forex.util.spawn
	  clojure.contrib.core)
    (:import clojure.lang.Atom)
    (:require [clj-time.core :as t])
    (:use forex.util.emacs
     forex.util.log  
     forex.module.error 
     forex.module.indicator 
     forex.module.account))   
  (defn- get-fn [a] (if (var? a) (var-get a) a)) 
  (defonce *ea* nil)
  (defonce *args* nil) 
  (defmacro with-ea [[ea & name] & body]
    `(let [ea# ~ea]
       (debugging (format "%s %s:" ~(or (first name) "") (:name ea#))
		  (binding [*ea* ea# *args* (:args ea#)]
		    (wenv {:symbol (:symbol ea#) :period (:period ea#)}
			  ~@body)))))
  (defmacro locking-read[lock & body]
    `(let [l# (.readLock ~lock)]
       (try (do (.lock l#) ~@body)
	    (finally (.unlock l#)))))
  (defmacro locking-write [lock & body]
    `(let [l# (.writeLock ~lock)]
       (try (do (.lock l#) ~@body)
	    (finally (.unlock l#)))))


  (deferror *ea-stop* [*clj-forex-error*] [message]
    {:msg (str "ea stop: " message)})


  (defn exit
    ([msg] (raise *ea-stop* msg))
    ([msg & args] (raise *ea-stop* (if (string? msg)
				     (apply format msg args)
				     (concat [msg] args)))))


  (defn- copy-atoms [map]
    (apply hash-map
	   (mapcat (fn [[key val]]
		     (list key
			   (if (instance? clojure.lang.Atom val)
			     (atom @val)
			     val)))
		   map)))
  ;;##ea implementation
  (defonce *eas* (atom []))
  (import java.util.concurrent.locks.ReentrantReadWriteLock)
  (defonce- *ea-pre-lock*
    (java.util.concurrent.locks.ReentrantReadWriteLock.))

  (defn every [pred coll]
    (if (empty? coll)
      false
      (loop [a coll]
	(if (empty? a)
	  true
	  (if (not (pred (first a)))
	    false
	    (recur (rest a)))))))

  (defn query [m]
    (let [a (filter
	     (fn [ea]
	       (if (every (fn [[key val]]
			    (= val (get ea key)))
			  m) 
		 ea))
	     @*eas*)]
      (if (= (count a) 1) (first a) a)))
  (defn alive? [ea] (pid? (:pid ea)))

  (defmacro- catch-unexpected [prefix & body]
    `(try (do ~@body)
	  (catch Exception e#
	    (severe "%s - caught unexpected error %s" ~prefix e#))))

  ;;TODO: place in forex-user
  (defvar save-file "/home/seth/Desktop/eas")

  (defn save-eas []
    (println "Attempting to acquire writeLock of *ea-pre-lock* ...")
    (locking-write *ea-pre-lock*
		   (println "saving ...")
		   (frm-save save-file @*eas*)
		   (count @*eas*)))

  (defn load-eas
    ([] (load-eas false))
    ([append]
       (let [eas (frm-load save-file)]
	 (if append (swap! *eas* conj eas) (vec eas)))))


  (require 'clojure.contrib.error-kit)
  ;;TODO; how to create unbound var for error-kit???
  (defn ping [a] (! (:pid a) "PING"))
  (defn ping-all [] (doall (map ping @*eas*)))
  ;;TODO: we need a monitor which pings and then sets something.... like in erlang

  (defn run-by-tick [{:keys [deinit init start] :as ea}]
    (with-ea [ea]
      (try
	(clojure.contrib.error-kit/with-handler
	  (loop [prev-close nil]
	    (sleep 1) 
	    (when-not (match (? 0) "STOP"  true "PING" (do (out "ping") nil)) 
	      (let [new-close (close)] 
		(when-not (= new-close prev-close)
		  (let [func (get-fn start)]
		    (if (fn? func)
		      (locking-read *ea-pre-lock*
				    (func (:args ea)))
		      (warn "%s is not a function. start cannot be called" func))))
		(recur new-close))))
	  (clojure.contrib.error-kit/handle *ea-stop* [message] (out "stopping ea ... %s" message))) 
	(catch Exception e 
	  (severe "stopping ea... caught exception %s" e)
	  (.printStackTrace e))
	(finally
	 (info "running deinit ...")
	 (catch-unexpected
	  "deinit" 
	  (let [de (get-fn deinit)]
	    (if (fn? de)
	      (de)
	      (warn "deinit %s is not a function. ignoring ...." de))))))))

  (defn- timeframe? [a] (number? a))
  (defrecord EA [name type ns init deinit start symbol period args
		 pid run vars])

  (defn- constant-map [& args] {})
  (defn- constant-true [& args] {})
  (defn new-ea
    ([] (new-ea {}))
    ([{:keys [ns symbol period run args vars] :or {symbol (env :symbol)
						   run run-by-tick
						   vars {}
						 period (env :period)}}]
       (let [ns (cond
		 (nil? ns) *ns*
		 (symbol? ns) (find-ns ns)
		 (string? ns) (find-ns (symbol ns))
		 true ns)]
	 (is? (ns? ns))
	 (is? [(map? vars) (every? var? (keys vars))])
	 (let [name (str (ns-name ns))
	       start (ns-symbol 'start ns)
	       init (or (let [fn (ns-symbol 'init ns)]
			  (if (get-fn fn) fn))
			constant-map)
	       deinit (or (let [fn (ns-symbol 'deinit ns)]
			    (if (get-fn fn) fn))
			   constant-true)]
	   (is? [(fn? (get-fn init)) (fn? (get-fn deinit)) (string? name)
		 (string? symbol) (fn? run) (timeframe? period)])
	   (EA. (format "%s %s, %s" name symbol period) name ns
		init deinit start symbol period (or args {})
		nil run
		(merge (copy-atoms (ns-vars ns)) vars)))))) 

  ;;how to get it to access actual var? as long as we dont use set!
  (defmethod clojure.core/print-method EA [o w]
    (.write w  (format "<EA \"%s\" %s %s |%s|>"
		       (:name o)
		       (if (pid? (:pid o)) true false)                 
		       (:args o) (:vars o))))

  ;;TODO: pid without spawn!!

  (defn run-start [ea]
    (with-ea [ea "START"] 
      (with-bindings (:vars ea)
	(let [new-ea (merge ea {:pid (spawn
				      #((:run ea) ea)
				      (:name ea))})]
	  (swap! *eas* conj new-ea)
	  new-ea))))

  ;;TODO: check return type
  (defn run-init [ea]
    (with-ea [ea "INIT"]
      (let [result ((get-fn (:init ea)) (:args ea))]
	(if result
	  (merge ea {:vars (merge (:vars ea) result)})))))

  (defn run-all [ea]
    (with-ea [ea "ALL"]
      (let [new-ea (run-init ea)]
	(if (instance? EA new-ea)
	  (run-start new-ea) 
	  (warn "failed to start - returned nil from init" (:name ea))))))

  (defn run
    ([] (run *ns* {}))
    ([args] (run *ns* args {}))
    ([args vars] (run *ns* args vars))
    ([ns args vars]
       ;;todo: not default, no nil
       (run-all (new-ea {:ns ns :args args :vars vars
			 :symbol (or (:symbol args) (env :symbol))
			 :period (or (:period args) (env :period))}))))

  (defn sym [] (:symbol *ea*))
  (defn period [] (:period *ea*))
  ;;TODO: wait till it stops and delete
  (defn stop [ea]
    (let [stop-it (fn [e]
		    (if (pid? (:pid e))
		      (do (! (:pid e) "STOP") 
			  true)))]
      (if (map? ea)
	(stop-it ea)
	(map stop-it ea))))

  (defn clear-eas [] (count (reset! *eas* (filter alive? @*eas*))))
#+end_src
*** Error
#+srcname:error-common 
#+begin_src clojure :tangle src/forex/module/error.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.error
    (:clone clj.core)
    (:require [forex.backend.mql.socket-service :as s])
    (:use forex.util.general
	  forex.util.core
	  forex.util.emacs 
	  forex.util.general))

  ;;raw receive
  (defn raw-receive [msg]
    (s/receive msg))
  (defn raw-receive-lst [msg]
    (split (raw-receive msg) #" +"))


  ;;receive with errors
  ;;TODO: error 4054 also occurs when we pass in invalid symbol
  ;;distinguish from loading???
  (defn receive-lst!
    ([msg] (receive-lst! msg nil))
    ([msg try]
       (loop [retries 0]
	 (let [spl (raw-receive-lst msg)] 
	   (if (= (first spl) "error")
	     (let [err (try (Integer/parseInt (second spl))
			    (catch Exception e (second spl)))]
	       (cond
		(and try (< retries try) (or (= err 4066) (= err 4054))) (do (Thread/sleep 300) (recur (inc retries)))
		true (throwf "MQL error %s" (second spl))))
	     spl)))))

  (defn receive!
    ([msg] (receive! msg nil))
    ([msg try]
       (join " " (receive-lst! msg try))))

  (defn receive-double!
    ([msg] (receive-double! msg nil))
    ([msg try] (Double/parseDouble (receive! msg try))))

  ;;receive with default instead of errors, returns error object for errors
  ;;is customizable to default to errors!
  (defrecord MqlError [e])
  (defonce- *er* (gensym)) 
  (def *default* *er*)

  (defn e? [a] (instance? MqlError a))

  (defmacro aif
    ([test then] `(aif ~test ~then nil))
    ([test then else]
       `(let [~'it ~test]
	  (if (and ~'it (not (e? ~'it)))
	    ~then
	    ~else)))) 
  (defmacro awhen [test & body] `(aif ~test (do ~@body)))
  (defmacro aif-not 
    ([test then] `(aif-not ~test ~then nil))
    ([test then else]
       `(let [~'it ~test]
	  (if (not (and ~'it (not (e? ~'it))))
	    ~then
	    ~else)))) 
  (defmacro awhen-not [test & body] `(aif-not ~test (do ~@body)))

  (defn- parse-int [a] (try (Integer/parseInt a) (catch Exception e a)))

  (defn receive
    ([msg] (receive msg *default*))
    ([msg default]
       (let [spl (raw-receive-lst msg)]
	 (if (and (= (first spl) "error"))
	   (let [err (parse-int  (second spl))] 
	     (if (= default *er*)
	       (MqlError. err) 
	       (if (fn? default) (default (MqlError. err)) default)))
	   (join "" spl)))))

  (defn receive-double
    ([msg] (receive-double msg *default*))
    ([msg default]
       (let [spl (raw-receive-lst msg)]
	 (if (= (first spl) "error")
	   (if (= default *er*)
	     (MqlError. (Integer/parseInt (second spl)))
	     (if (fn? default) (default (MqlError. (Integer/parseInt (second spl)))) default))
	   (Double/parseDouble (join " "  spl))))))

  (defn receive-int [s]
    (aif (receive-double s)
	 (int it)
	 it))
#+end_src
*** Indicator
#+srcname:indicator-common
#+begin_src clojure :tangle src/forex/module/indicator.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.module.indicator
    (:clone clj.core)
    (:use
     forex.util.core
     forex.util.general
     forex.module.account.utils
     forex.module.error)   
    (:require [forex.module.error :as s]))

  (def +m1+ 1)
  (def +m5+ 5)
  (def +m15+ 15)
  (def +h1+ 60)
  (def +h4+ 240)
  (def +d1+ (* 24 +h1+))
  (defn cross?
    ([signal main] (cross? signal main 0))
    ([signal main i]
       (let [i1 (+ i 1) i2 (+ i 2)
	     a1 (signal i1) a2 (signal i2)
	     b1 (main i1) b2 (main i2)] 
	 (or (and (> a1 b1) (< a2 b2) [:buy i])
	     (and (< a1 b1) (> a2 b2) [:sell i])
	     nil))))

  ;;high low open close
  (defn get-rel-data [^String symbol ^Integer period ^Integer from ^Integer to]
    (is?  (>= to from) "in get-data, from/to is invalid")
    (loop [dat nil retries 0]
      (if (> retries 3) (throwf "MQL error %s" (second dat)))
      (let [data (s/raw-receive-lst (format "bars_relative %s %s %s %s"
					symbol period from to))]
	(if (= (first data) "error") 
	  (do (sleep 0.4) (recur data (+ retries 1)))
	  data)))) 

  (defn- rel [i]
    (let [sym (env :symbol)
	  period (env :period)]
      (is? (and (string? sym) (integer? period)))
      (get-rel-data sym period i i)))
  (defn- off [a] (+ (or (env :i) 0) a))
  (defn high
    ([] (high 0)) 
    ([i] (Double/parseDouble (nth (rel (off i)) 1))))
  (defn open 
    ([] (open 0)) 
    ([i] (Double/parseDouble (nth (rel (off i)) 3))))
  (defn low
    ([] (low 0))
    ([i] (Double/parseDouble (nth (rel (off i)) 2))))
  (defn close
    ([] (close 0))
    ([i] (Double/parseDouble (nth (rel (off i)) 4))))

  ;;TODO: change
  (defn ask
    ([] (ask (env :symbol)))
    ([symbol] (aif (mode-ask symbol) it (throwf "MQL error %s" (:e it)))))
  ;;bid==close 
  (defn bid
    ([] (bid (env :symbol)))
    ([symbol] (aif (mode-bid symbol) it (throwf "MQL error %s" (:e it)))))

  (defn- env? [] (and (string? (env :symbol)) (integer? (env :period))))
  (defn- >? [a] (or (zero? a) (pos? a)))
  ;;an example of acessing a custom ea


  (defn moving-averages
    ([method] (fn
		([period] (moving-averages method period))
		([period offset] (moving-averages method period offset))))
    ([method period] (moving-averages method period 0))
    ([method period offset]
       {:pre [(env?)  (>? offset)
	      (number? method) (>? period)]}
       (receive-double! 
	(format "Custom_Moving_Averages %s %s %s %s %s 0 %s"
		(env :symbol) (env :period) ;;period/method
		0 (off offset) period method)
	3))) 
  (def sma (moving-averages 0))
  (def ema (moving-averages 1))
  (def smma (moving-averages 2))
  (def lwma (moving-averages 3))

  ;;todo - check for valif params - above 1?
  (defn psar
    "step (0.02), maximum 0.2"
    ([params] (psar params 0))
    ([params offset]
       {:pre [(env?) (>? offset)  (= (count params) 2)]}
       (receive-double! 
	(format "Custom_Parabolic %s %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) (first params) (second params))
	3)))
  (defn cci
    ([period] (cci period 0))
    ([period offset]
       {:pre [(env?) (>? offset)  (number? period)]}
       (receive-double! 
	(format "Custom_CCI %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))


  (defn momentum
    ([period] (momentum period 0))
    ([period offset]
       {:pre [(env?) (>? offset)  (number? period)]}
       (receive-double! 
	(format "Custom_Momentum %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))


  (defn rsi
    ([period] (rsi period 0))
    ([period offset]
       {:pre [(env?) (>? offset) (number? period)]}
       (receive-double! 
	(format "Custom_RSI %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) period)
	3)))

  (defn vma
    ([params] (vma params 0))
    ([params offset]
       {:pre [(env?) (>? offset) (= (count params) 4)]}
       (receive-double! 
	(format "Custom_FantailVMA3 %s %s %s %s %s"
		(env :symbol) (env :period)
		0 (off offset) (apply str (interpose " " params)))
	3)))


  (defmacro- indicator-fn [[params index] & body]
    `(fn a#
       ([~params] (a# ~params 0))
       ([~params ~index]
	  ~@body)))



  (defn rsi-black 
    ([params] (fn 
		([mode offset] (rsi-black params mode offset))
		([offset] (rsi-black params 0 offset))))
    ([params mode] (fn
		     ([offset] (rsi-black params mode offset))
		     ([] (rsi-black params mode  0))))
    ([params mode offset]
       {:pre [(env?) (>? offset) (>? mode) 
	      (= (count params) 5)]}
       (receive-double! 
	(format "Custom_Rsi_BlackFeet_modded %s %s %s %s %s"
		(env :symbol) (env :period)
		mode (off offset) (apply str (interpose " " params)))
	3)))

  (def rsi-black-signal
    (indicator-fn [params index]
		  (rsi-black params 1
				 index)))
  (def rsi-black-main
    (indicator-fn [params index]
		  (rsi-black params 0 index)))


  (defn blazan-dynamic-stop
    ([params] (fn 
		([mode offset] (blazan-dynamic-stop params mode offset))
		([offset] (blazan-dynamic-stop params 0 offset))))
    ([params mode] (fn
		     ([offset] (blazan-dynamic-stop params mode offset))
		     ([] (blazan-dynamic-stop params mode  0))))
    ([params mode offset]
       {:pre [(env?) (>? offset) (>? mode) 
	      (= (count params) 4)]}
       (receive-double! 
	(format "Custom_Blazan_Dynamic_Stop %s %s %s %s %s"
		(env :symbol) (env :period)
		mode (off offset) (apply str (interpose " " params)))
	3)))



  (defn hit? [order val]
    (cond
     (sell? order)
     (<= (close) val)
     (buy? order)
     (>= (close) val )
     true (throwf "invalid order type %s" order)))
#+end_src
** User 
#+srcname:forex_user
#+begin_src clojure :tangle src/forex_user.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex-user
       (:like forex.default)
       (:use utils.general))
  ;;TODO: mql error 146

  ;;forex_user is the ns in which customization will occur
#+end_src

** Templates
#+source: template
#+begin_src clojure :tangle src/forex/default.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.default
       (:clone clj.core)
       (:use forex.util.core
	     forex.util.emacs
	     forex.util.log) 
       (:use forex.module.error
	     forex.module.ea
	     forex.module.indicator
	     forex.module.account forex.module.account.utils
	     [clj-time.core :exclude [extend start]])
       (:require
	[forex.backend.mql.socket-service :as backend]))
#+end_src

** Examples
Notice that examples are right now just examples, they arent particularly
profitable, they are examples of using clj-forex. I decided to release
them without thoroughly testing so that one can see an early look of how to
use clj-forex....

#+source: timeout-ea
#+begin_src clojure :tangle src/forex/examples/timeout_ea/timeout_ea.clj
  ;;forex.examples.timeout-ea : ea which manages the orders of a trade
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.timeout-ea.timeout-ea
       (:like forex.default)
       (:use utils.general
	     forex.examples.timeout-ea.utils))
   ;;ea vars   
  (defvar state (atom :timeout))
  (defvar end-time)
  (defvar order) 
  ;;  
  ;;TODO: when we order, and modify fails, how do we get the error? later :)...
  (defn init [{:keys [type sl price]}]
    (aif (order! (atom-hash {:type type :sl sl :price price
			     :lots (* (mode-minlot) 2)}))
	 {#'end-time (plus (now) (hours 12))
	  #'order it} 
	 (out "MQL error %s" (:e it))))
  (declare timeout break-even trail)
  (defn start [args]
    (cond
     (close? order) (exit "order is now closed")
     (= @state :timeout) (timeout args)
     (= @state :break-even) (break-even args))) 


  (defn timeout [_]
    (cond
     ;;changed to market
     (market? order)
     (do (reset! state :break-even) (out "changed to break even"))
     ;;entry order reach sl 
     (if (sell? order) (> (close) (:sl order)) (< (close) (:sl order)))
					  ;TODO: reliable delete????
     (awhen (delete! order) (exit "entry order reached sl. deleting ..."))
     ;;timed out
     (after? (now) end-time)
     (awhen (delete! order) (exit "order timed out"))))

  (defn break-even [{:keys [tp2 tp1]}]
    (when (hit? order tp1)
      (out "closing to half ...")
      (awhen (-> (modify! order {:sl (:price order) :tp tp2})
		 (close! (lot (/ (:lots order) 2))))
	     (exit "finished break even"))))

  (defn hh [a]
    (apply max (map high (range 1 (inc a)))))
  (defn ll [a]
    (apply min (map low (range 1 (inc a)))))
  (defn trail [_]
    (modify! order 
	     {:sl (if (sell? order)
		    (min (:sl order) (hh 3))
		    (max (:sl order) (ll 3)))}))
#+end_src
  
#+source: timeout-ea-utils
#+begin_src clojure :tangle src/forex/examples/timeout_ea/utils.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.timeout-ea.utils
       (:like forex.default)
       (:use utils.general))
  (defn pip-price
    ([] (pip-price (env :symbol)))
    ([symbol] (mode-tickvalue symbol)))
  ;;TODO: mql err on point? no way! we should throw an error

  (defn point 
    ([] (point (env :symbol)))
    ([symbol]
       (* 10 (mode-point symbol))))
  (defn pips   
    ([price] (pips price (env :symbol)))
    ([price symbol] 
       (/ price (point symbol)))) 
  (defn price-of 
    ([val] (price-of val (env :symbol)))
    ([val symbol]
       (* (pip-price symbol) (pips val)))) 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (def method-regex
    (re-pattern (.replaceAll
		 (str "(?i)\\s*(Propulsion|Pip Reactor|Impulse|Spring)\\s+Method"
		      ".+running on (\\w+/\\w+)"
		      ".+generated a (Buy|Sell) Signal @ (\\d{0,15}\\.\\d{0,15})"
		      ".+Stop @ (\\d{0,15}\\.\\d{0,15})"
		      ".+(?:1st|First) Limit @ (\\d{0,15}\\.\\d{0,15})"
		      ".+(?:2nd|Second) Limit @ (\\d{0,15}\\.\\d{0,15})") 
		 "\\s+" "\\\\s+")))

  (defmacro catch-un [& body]
    `(try (do ~@body) (catch Exception e# (warn "caught unexpected error: %s" e#))))

  (defn match-method [s]
    (when s 
      (debugging "Matching Profit Multiplier Trade: "
		 (catch-un 
		  (when-let [it (first (re-seq method-regex (.replaceAll s "[\\r\\n]+" " ")))]
		    (let [[method-type symbol type price stop tp1 tp2] (rest it)]
		      {:method (.toLowerCase method-type)
		       :symbol (.replaceAll symbol "/" "")
		       :type (condp = (.toLowerCase type)
				 "buy" :buy-stop
				 "sell" :sell-stop)
		       :price (Double/parseDouble price)
		       :sl (Double/parseDouble stop)
		       :tp1 (Double/parseDouble tp1)
		       :tp2 (Double/parseDouble tp2)}))))))
#+end_src
 
#+source: renko
#+begin_src clojure :tangle src/forex/examples/renko/renko.clj
  (clojure.core/use 'nstools.ns)
  (ns+ forex.examples.renko.renko
       (:clone forex.default) 
       (:use forex.util.general)) 
  ;;TODO: *ea-stop* already refers to: #'forex.module.ea/*ea-stop* in namespace: forex.default 
  ;;TODO: on GBP/JPY, why did it enter so late????

  ;;TODO!!!: speed up ns+ by alot! and dont have it automatically reload it, please!!!

  ;;TODO: test reusing of account.utils
  (def ^{:var true} state (atom :monitor)) 
  (def ^{:var true} order (atom-hash)) 
  (def ^{:var true} close-on-middle false) 

  (def main (partial vma [2 2 100 1]))
  (def signal (partial vma [2 2 1 1] ))
  (def middle (partial vma [2 2 26 1]))
  (def support (blazan-dynamic-stop [150 70 1 10000] 1))
  (def resistance (blazan-dynamic-stop [150 70 1 10000] 0))

  ;;UTILS
  (defn up? [signal i]
    (let [diff (- (signal i) (signal (+ i 1)))]
      (if (>= diff 0) 
	diff
	false))) 
  (defn down? [signal i]
    (let [diff (- (signal i) (signal (+ i 1)))]
      (if (<= diff 0)
	diff
	false)))    
  (defn reset []
    (reset! state :monitor) (reset! order nil) (out "order closed"))
  (defn calculate-lots [] (lot (* 0.01 (/ (account-balance) 100))))
  ;;TODO: use symbol in o for profit! 
  (defn profit
    ([o] (wenv {:symbol (or (:symbol o) (env :symbol))} (profit o (close) (:break o))))
    ([o a] (profit o a (:break o)))
    ([o a b] (point (o-- o a b))))

  ;;TODO: exit half when cross middle? enter half more when recross? 
  ;;OPEN CONDITION 
  (defn open-condition [i] 
    (if-let [[dir i] (cross? signal main i)]
      (or (and (= dir :buy) (> (signal i) (middle i)) {:type :buy :i i :category  :long :state :init})
	  (and (= dir :sell) (< (signal i) (middle  i)) {:type :sell :i i :category :long :state :init}))
      (when-let [[dir i] (cross? signal middle i)]
	(or (and (= dir :buy) ;;TODO: better reentry , oui? slope? 
		 (or (and (< (middle i) (main i)) (> (middle (+ i 10)) (main (+ i 10)))
			  {:type :buy :i i :category :long :state :init}) ;;the dip
		     (and (<= (Math/abs (- (main i) (middle i))) (pip 20)) (or (up? main i) (up? main (+ i 1)))
			  (> (middle i) (main i)) 
			  ;;{:type :buy :i i :category :scalp}
			  nil
			  ))) ;;thin 
	    (and (= dir :sell)
		 (or (and (> (middle i) (main i)) (< (middle (+ i 10)) (main (+ i 10)))
			  {:type :sell :i i :category :long :state :init}) ;;the dip
		     (and (<= (Math/abs (- (main i) (middle i))) (pip 20)) (or (down? main i) (down? main (+ i 1)))
			  (< (middle i) (main i))
			  ;;{:type :sell :i i :category :scalp}
			  nil
			  )))))))   

  ;;ORDER MANAGEMENT
  (defmulti close-condition (fn [o & args] (:category o)))
  (defmulti check (fn [o & args] (:category o)))
  ;;;SCALP ORDER MANAGEMENT
  (defn enough-profit? [o] 
    ;;20 pips + spread
    (>= (profit o) 10))
  (defn should-close? [{:keys [type] :as o}] 
    (cond
     (= type :buy)
     (or (or (< (signal 1) (main 1)) (< (signal 1) (middle 1)))
	 (and (enough-profit? o)
	      (or (< (signal) (main)) (< (signal) (middle)))))
     (= type :sell)
     (or (or (> (signal 1) (main 1)) (> (signal 1) (middle 1)))
	 (and (enough-profit? o)
	      (or (> (signal) (main)) (> (signal) (middle)))))))

  ;;;LONG ORDER MANAGEMENT
  (defmethod close-condition :long [{:keys [type state] :as o}]
    (if (or (and  close-on-middle (>= (profit o) 75)) (= state :init))
      (should-close? o)
      (cond
       (= type :buy)
       (< (signal 1) (main 1))
       (= type :sell)
       (> (signal 1) (main 1)))))

  (defmethod check :long [o]
    "long orders have a trailing stop if profit>=20, otherwise we close it regularly like a scalper. "
    (when (>= (profit o) 20) (modify! o {:state :trail}))
    ;;sl is a safety feature in case we go offline accidently
    (when (or (= (:sl o) 0) (>= (profit o (close) (:sl o)) 20))
      ;;shouldnt have to use omax, but just in case!...
      (modify! o {:sl (omax o (:sl o) (o- o (main 1) (pip 20)))})))  

  ;;MAIN  
  (defn gobble [o] 
    (if (close? o) 
      (reset)
      (awhen-not (and (close-condition o) (close! o))
		 (check o))))

  (defn monitor []
    (when-let [{:keys [type category] :as o} (open-condition 0)] 
      (awhen (order! (merge o  {:type type :lots (calculate-lots)})) 
	     (reset! order it)
	     (reset! state :gobble)   
	     (out "entered %s %s order" type category)))) 
  (defn start [args]  
    (cond
     (= @state :monitor) (monitor)
     (= @state :gobble) (gobble @order)))

  (defn vars [ea] (:vars ea))
  (defn var [var ea] (get (:vars ea) var))
#+end_src
