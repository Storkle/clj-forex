<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>CLJ-FOREX</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-02-20 12:28:25 CST"/>
<meta name="author" content="Seth Burleigh"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="content">

<h1 class="title">CLJ-FOREX</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Introduction </a>
<ul>
<li><a href="#sec-1_1">1.1 What is forex? </a></li>
<li><a href="#sec-1_2">1.2 What is clj-forex? </a></li>
<li><a href="#sec-1_3">1.3 The Difference </a></li>
<li><a href="#sec-1_4">1.4 Where's the code?? </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Development Tools </a></li>
<li><a href="#sec-3">3 From Ideas to Implementation - Metatrader Backend </a></li>
<li><a href="#sec-4">4 Code </a>
<ul>
<li><a href="#sec-4_1">4.1 Project </a></li>
<li><a href="#sec-4_2">4.2 Util </a>
<ul>
<li><a href="#sec-4_2_1">4.2.1 ThirdParty </a></li>
<li><a href="#sec-4_2_2">4.2.2 CLJ </a></li>
<li><a href="#sec-4_2_3">4.2.3 Core </a></li>
<li><a href="#sec-4_2_4">4.2.4 General </a></li>
<li><a href="#sec-4_2_5">4.2.5 Log </a></li>
<li><a href="#sec-4_2_6">4.2.6 Fiber </a></li>
<li><a href="#sec-4_2_7">4.2.7 Spawn </a></li>
<li><a href="#sec-4_2_8">4.2.8 ZMQ </a></li>
<li><a href="#sec-4_2_9">4.2.9 GUI </a></li>
<li><a href="#sec-4_2_10">4.2.10 Devel </a></li>
</ul>
</li>
<li><a href="#sec-4_3">4.3 Backend </a>
<ul>
<li><a href="#sec-4_3_1">4.3.1 MQL Socket Service </a></li>
</ul>
</li>
<li><a href="#sec-4_4">4.4 Module </a>
<ul>
<li><a href="#sec-4_4_1">4.4.1 Account </a></li>
<li><a href="#sec-4_4_2">4.4.2 Ea </a></li>
<li><a href="#sec-4_4_3">4.4.3 Error </a></li>
<li><a href="#sec-4_4_4">4.4.4 Indicator </a></li>
</ul>
</li>
<li><a href="#sec-4_5">4.5 Interface </a></li>
<li><a href="#sec-4_6">4.6 User </a></li>
<li><a href="#sec-4_7">4.7 Templates </a></li>
<li><a href="#sec-4_8">4.8 Examples </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction </h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1"><span class="section-number-3">1.1</span> What is forex? </h3>
<div class="outline-text-3" id="text-1_1">

<p>Forex is a currency trading market. But you probably know all about forex, since you're here! If not, read up on it! <br/>
</p><ul>
<li>
<a href="http://en.wikipedia.org/wiki/Foreign_exchange_market">Wiki article - OK</a>
</li>
<li>
<a href="http://www.fxcm.com/metatrader.jsp">FXCM Retail Broker Free Metatarder Terminal -  get demo account and see what forex trading is first hand!</a>
</li>
</ul>


</div>

</div>

<div id="outline-container-1_2" class="outline-3">
<h3 id="sec-1_2"><span class="section-number-3">1.2</span> What is clj-forex? </h3>
<div class="outline-text-3" id="text-1_2">

<p>Clj-forex is an in progress effort to create a non-graphical backend to various forex trading backends. Right now Metatrader is the focus. 
The ultimate goal of clj-forex is to create a robust library to allow the creation of EA (expert advisors) in the scripting language clojure. Expert advisors
are programs which automatically trade the market, performing sell/buy orderes, changing stoplosses, using technical indicators, etc. They are useful for
both automating parts of manual trading systems (performing trailing stops, expiration of market orders) and also for full out automated trading.
</p>
<p>
Indicators will be calculated java side using price bars retrieved from the backends. Integration of indicator data to various gui backends (i.e. at this time,
Metatrader) will be supported. The only purpose of the forex backend is to allow access to spreads, current price, ability to buy/sell, etc. 
</p></div>

</div>

<div id="outline-container-1_3" class="outline-3">
<h3 id="sec-1_3"><span class="section-number-3">1.3</span> The Difference </h3>
<div class="outline-text-3" id="text-1_3">

<p>Im not sure why noone has done this before, but integration of a scripting language to create eas is, in my opinion, vital. 
Integration of a lisp-like dialect, like clojure, will allow much more rapid creation and prototyping of eas. 
This combined with easy access to any java library (clojure is implemented on the java virtual machine) makes for a winning combination! 
Things like neural networks, database, and other such ‘advanced’ concepts can now be much more easily integrated than if we had used <a href="http://book.mql4.com/">mql4</a>.
</p>
<p>
Its like an artist! Give an artist more efficient tools in the toolbox and who knows what can be created! [And clojure is fun to learn anyways!]
</p></div>

</div>

<div id="outline-container-1_4" class="outline-3">
<h3 id="sec-1_4"><span class="section-number-3">1.4</span> Where's the code?? </h3>
<div class="outline-text-3" id="text-1_4">

<p>This file is the code (clojure, anyways). The code is untangled using the
keystroke C-c C-v t in emacs when this file is open. While currently most
of the code is simply in the Code section, it will all eventually be explained
in the <a href="http://groups.google.com/group/clojure/browse_thread/thread/664a1d305f32ab90">literate programming</a> manner.
</p></div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Development Tools </h2>
<div class="outline-text-2" id="text-2">

<p>org-mode in emacs + babel is used. Currently code is one ns per one code block
format. Therefore, i use the below code, along with the latest git repository
for org-mode (needed!). I then hit f8 to detangle all my changes to my org file.
f9 can be used to jump from source code to location in org file. 
</p>


<pre class="src src-emacs-lisp">(<span style="color: #a020f0;">defvar</span> <span style="color: #b8860b;">clj-forex-file</span> <span style="color: #bc8f8f;">"/home/seth/Dropbox/.rep/clj-forex/clj-forex.org"</span>)


(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-file</span> (file <span style="color: #228b22;">&amp;rest</span> body)
  <span style="color: #bc8f8f;">"open up file in a buffer, and set current buffer to it"</span>
  `(<span style="color: #a020f0;">with-current-buffer</span> (find-file-noselect ,file t) ,@body))

(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">out-files</span> (org-file)
  (<span style="color: #a020f0;">let</span> (args)
    (org-babel-map-src-blocks org-file
      (<span style="color: #a020f0;">let</span> ((tangle-file (<span style="color: #a020f0;">with-temp-buffer</span>
                           (insert header-args)
                           (goto-char (point-min))
                           (<span style="color: #a020f0;">if</span> (re-search-forward <span style="color: #bc8f8f;">":tangle[ ]+</span><span style="color: #bc8f8f; font-weight: bold;">\\</span><span style="color: #bc8f8f; font-weight: bold;">(</span><span style="color: #bc8f8f;">[</span><span style="color: #bc8f8f;">^</span><span style="color: #bc8f8f;"> ]+</span><span style="color: #bc8f8f; font-weight: bold;">\\</span><span style="color: #bc8f8f; font-weight: bold;">)</span><span style="color: #bc8f8f;">"</span> nil t)
                               (match-string 1)
                             nil))))
        (<span style="color: #a020f0;">when</span> tangle-file (push tangle-file args))))
    args))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-cd</span> (dir <span style="color: #228b22;">&amp;rest</span> body)
  (<span style="color: #a020f0;">let</span> ((current (gensym)))
    `(<span style="color: #a020f0;">let</span> ((,current default-directory))
       (cd ,dir)
       (<span style="color: #a020f0;">unwind-protect</span> (<span style="color: #a020f0;">progn</span> ,@body) (cd default-directory)))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO rever buffers when detangle/tangle?
</span>(<span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">detangle</span> ()
  (interactive)
  (<span style="color: #a020f0;">save-excursion</span>
    (<span style="color: #a020f0;">let*</span> ((org-file clj-forex-file)
           (out (out-files org-file))
           (amount 0)) 
      (with-cd (file-name-directory org-file)
               (<span style="color: #a020f0;">dolist</span> (file out)
                 (with-file
                  file
                  (goto-char (truncate (/ (+ (point-min) (point-max)) 2)))
                  (<span style="color: #a020f0;">let</span> ((detangled (org-babel-detangle)))
                    (<span style="color: #a020f0;">if</span> (= detangled 0) (<span style="color: #a020f0;">progn</span> (message <span style="color: #bc8f8f;">"failed on %s"</span> file)
                                             ))
                    (incf amount detangled)))))
      (message <span style="color: #bc8f8f;">"Detangled %s source blocks/ %s"</span> amount (length out)))))
(global-set-key (kbd <span style="color: #bc8f8f;">"&lt;f8&gt;"</span>) 'detangle)
(global-set-key (kbd <span style="color: #bc8f8f;">"&lt;f9&gt;"</span>) 'org-babel-tangle-jump-to-org)
(setq org-src-fontify-natively t)
</pre>



<p>
Given the tangled output of the source files, which basically tags the
code so that it can detangle it and jump back to the org file, we can
technically work in something other than emacs if we have a clojure tool
to detangle and tangle. However, this is not yet implemented. Also, it is planned
to give noweb support for babel so that i can break up the blocks.
</p>
<p>
Yes, currently it is not very development start friendly. That will change!
</p></div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> From Ideas to Implementation - Metatrader Backend </h2>
<div class="outline-text-2" id="text-3">

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Code </h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4_1" class="outline-3">
<h3 id="sec-4_1"><span class="section-number-3">4.1</span> Project </h3>
<div class="outline-text-3" id="text-4_1">




<div class="org-src-container"><label class="org-src-name">project()</label><pre class="src src-clojure">
(defproject clj-forex <span style="color: #bc8f8f;">"0.1-SNAPSHOT"</span>
  <span style="color: #da70d6;">:description</span> <span style="color: #bc8f8f;">"non graphical library for automated trading for forex market with various backends like metatrader"</span>
  <span style="color: #da70d6;">:dependencies</span> [[org.clojure/clojure <span style="color: #bc8f8f;">"1.2.0"</span>]
                 [org.clojure/clojure-contrib <span style="color: #bc8f8f;">"1.2.0"</span>]           
                 [matchure <span style="color: #bc8f8f;">"0.10.0"</span>]
                 [clj-time <span style="color: #bc8f8f;">"0.2.0-SNAPSHOT"</span>]
                 [mmemail <span style="color: #bc8f8f;">"1.0.1"</span>] 
                 [nstools <span style="color: #bc8f8f;">"0.2.4"</span>]
                 [com.miglayout/miglayout <span style="color: #bc8f8f;">"3.7.4"</span>]
                 [commons-codec <span style="color: #bc8f8f;">"1.4"</span>]]   
  <span style="color: #da70d6;">:dev-dependencies</span> [[native-deps <span style="color: #bc8f8f;">"1.0.5"</span>]
                     [swank-clojure <span style="color: #bc8f8f;">"1.3.0-SNAPSHOT"</span>]]  
  <span style="color: #da70d6;">:native-dependencies</span> [[org.clojars.starry/jzmq-native-deps <span style="color: #bc8f8f;">"2.0.10.3"</span>]]
  <span style="color: #da70d6;">:main</span> forex.interface.main
  <span style="color: #da70d6;">:repositories</span> {<span style="color: #bc8f8f;">"miglayout"</span> <span style="color: #bc8f8f;">"http://www.miglayout.com/mavensite/"</span>} 
 <span style="color: #b22222;">;; </span><span style="color: #b22222;">:run-aliases {:izpack forex.dev.install} 
</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">:jvm-opts      ["-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8030"]
</span>  <span style="color: #b22222;">;;</span><span style="color: #b22222;">:aot :all
</span>  )
</pre></div>



</div>

</div>

<div id="outline-container-4_2" class="outline-3">
<h3 id="sec-4_2"><span class="section-number-3">4.2</span> Util </h3>
<div class="outline-text-3" id="text-4_2">


</div>

<div id="outline-container-4_2_1" class="outline-4">
<h4 id="sec-4_2_1"><span class="section-number-4">4.2.1</span> ThirdParty </h4>
<div class="outline-text-4" id="text-4_2_1">




<div class="org-src-container"><label class="org-src-name">defrecord2()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">BY David McNeil
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">https://github.com/david-mcneil/defrecord2
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">modified defrecord2 macro so i could include protocols
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">got rid of print-method and pprint method 
</span>
(<span style="color: #a020f0;">ns</span> clj.third-party.defrecord2
  (<span style="color: #da70d6;">:require</span> [clojure.contrib.str-utils2 <span style="color: #da70d6;">:as</span> str2])
  (<span style="color: #da70d6;">:use</span> [clojure.contrib.core <span style="color: #da70d6;">:only</span> (seqable?)]
        [clojure.set <span style="color: #da70d6;">:only</span> (<span style="color: #228b22;">difference</span>)]
        [clojure.string <span style="color: #da70d6;">:only</span> (<span style="color: #228b22;">join</span>)]
        [clojure.contrib.pprint <span style="color: #da70d6;">:only</span> (*simple-dispatch* use-method pprint-map)])
  (<span style="color: #da70d6;">:import</span> [clojure.lang IPersistentList IPersistentVector IPersistentMap ISeq]))

<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">enhanced records with constructor support (take in a hashmap) and print-dup support
</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">internal helpers for name conversion
</span>
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">take-even</span> [x]
  (<span style="color: #da70d6;">take-nth</span> 2 x))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">take-odd</span> [x]
  (<span style="color: #da70d6;">take-nth</span> 2 (<span style="color: #da70d6;">drop</span> 1 x)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">is-upper?</span> [s]
  (<span style="color: #da70d6;">=</span> (.toUpperCase s) s))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">assemble-words</span> [parts]
  (<span style="color: #a020f0;">loop</span> [remaining-parts parts result []]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">seq</span> remaining-parts)
      (<span style="color: #a020f0;">let</span> [part (<span style="color: #da70d6;">first</span> remaining-parts)]
        (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> remaining-parts)
               (<span style="color: #a020f0;">if</span> (is-upper? part)
                 (<span style="color: #da70d6;">conj</span> result (.toLowerCase part))
                 (<span style="color: #da70d6;">conj</span> (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">seq</span> result)
                         (<span style="color: #da70d6;">pop</span> result)
                         []) (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">last</span> result) part)))))
      result)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">camel-to-dashed</span>
  <span style="color: #bc8f8f;">"Convert a name like 'BigBlueCar' to 'big-blue-car'."</span>
  [s]
  (<span style="color: #a020f0;">let</span> [parts (<span style="color: #da70d6;">remove</span> #(<span style="color: #da70d6;">=</span> <span style="color: #bc8f8f;">""</span> %) (str2/partition s #<span style="color: #bc8f8f;">"[A-Z]"</span>))
        words (assemble-words parts)]
    (<span style="color: #228b22;">join</span> <span style="color: #bc8f8f;">"-"</span> words)))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">internal helpers for changing records via maps 
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">set-record-field</span>
  <span style="color: #bc8f8f;">"Set a single field on a record."</span>
  [source [key value]]
  (<span style="color: #da70d6;">assoc</span> source key value))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">set-record-fields</span>
  <span style="color: #bc8f8f;">"Set many fields on a record, from a map."</span>
  [initial value-map]
  (<span style="color: #da70d6;">reduce</span> set-record-field initial value-map))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">internal helper for generating constructor function
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">expected-keys?</span> [map expected-key-set]
  (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">seq</span> (<span style="color: #228b22;">difference</span> (<span style="color: #da70d6;">set</span> (<span style="color: #da70d6;">keys</span> map)) expected-key-set))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">make-record-constructor</span>
  <span style="color: #bc8f8f;">"Define the constructor functions used to instantiate a record."</span>
  [ctor-name type-name field-list default-record]
  `(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">~ctor-name</span>
     ([value-map#]
        (~ctor-name ~default-record value-map#))
     ([initial# value-map#]
        {<span style="color: #da70d6;">:pre</span> [(<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">nil?</span> initial#)
                   (<span style="color: #da70d6;">isa?</span> (<span style="color: #da70d6;">class</span> initial#) ~type-name))
               (<span style="color: #da70d6;">map?</span> value-map#)
               (expected-keys? value-map# ~(<span style="color: #da70d6;">set</span> (<span style="color: #da70d6;">map</span> keyword field-list)))]}
        (set-record-fields (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">nil?</span> initial#) ~default-record initial#) value-map#)))) 

<span style="color: #b22222;">;; </span><span style="color: #b22222;">internal helpers for printing
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">remove-nil-native-fields</span> [native-keys record]
  (<span style="color: #a020f0;">let</span> [extra-keys (<span style="color: #228b22;">difference</span> (<span style="color: #da70d6;">set</span> (<span style="color: #da70d6;">keys</span> record))
                               native-keys)]
    (<span style="color: #da70d6;">apply</span> array-map (<span style="color: #da70d6;">reduce</span> into (<span style="color: #a020f0;">for</span> [[k v] record]
                                    (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">contains?</span> extra-keys k)
                                            (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">nil?</span> v)))
                                      [k v]))))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">ns-resolve-symbol</span> [s]
  (<span style="color: #a020f0;">if-let</span> [s (<span style="color: #da70d6;">resolve</span> s)]
    (.substring (<span style="color: #da70d6;">str</span> s) 2)
    (<span style="color: #da70d6;">str</span> s)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">print-record</span>
  <span style="color: #bc8f8f;">"Low-level function to print a record to a stream using the specified constructor name in the print output and using the provided write-contents function to write out the contents of the record (represented as a map)."</span>
  [ctor ctor-name native-keys record stream write-contents]
  `(<span style="color: #a020f0;">do</span> 
     (.write ~stream (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"#=("</span> ~(ns-resolve-symbol ctor-name) <span style="color: #bc8f8f;">" "</span>))
     (~write-contents (remove-nil-native-fields ~native-keys ~record))
     (.write ~stream  <span style="color: #bc8f8f;">")"</span>)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">print-record-contents</span>
  <span style="color: #bc8f8f;">"Simply write the contents of a record to a stream as a string. Used for basic printing."</span>
  [stream contents]
  (.write stream (<span style="color: #da70d6;">str</span> contents)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">setup-print-record-method</span> [ctor ctor-name native-keys type-name method-name]
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">~method-name</span> ~type-name [record# writer#]
     (print-record ~ctor ~ctor-name ~native-keys record# writer# (<span style="color: #da70d6;">partial</span> print-record-contents writer#))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">setup-print-record</span>
  <span style="color: #bc8f8f;">"Define the print methods to print a record nicely (so that records will print in a form that can be evaluated as itself)."</span>
  [ctor ctor-name native-keys type-name]

  `(<span style="color: #a020f0;">do</span> <span style="color: #b22222;">;</span><span style="color: #b22222;">(setup-print-record-method ~ctor ~ctor-name ~native-keys ~type-name print-method)
</span>     (setup-print-record-method ~ctor ~ctor-name ~native-keys ~type-name print-dup)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">generate-record-pprint</span>
  <span style="color: #bc8f8f;">"Return a function that can be used in the pprint dispatch mechanism to handle a specific constructor name."</span>
  [ctor ctor-name native-keys]
  `(<span style="color: #da70d6;">fn</span> [record#]
     (print-record ~ctor ~ctor-name ~native-keys record# *out* pprint-map)))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">internal helpers - walking data structures
</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">w - walker function
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">f - mutator function
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">n - node in data tree being walked
</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">helper - generating walking methods like this:
</span>(<span style="color: #da70d6;">comment</span> (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">prewalk2</span> Foo [f foo]
           (<span style="color: #a020f0;">if-let</span> [foo2 (f foo)]
             (new-foo foo2 {<span style="color: #da70d6;">:a</span> (prewalk2 f (<span style="color: #da70d6;">:a</span> foo2))
                            <span style="color: #da70d6;">:b</span> (prewalk2 f (<span style="color: #da70d6;">:b</span> foo2))})))

         (<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">postwalk2</span> Foo [f foo]
           (f (new-foo foo {<span style="color: #da70d6;">:a</span> (postwalk2 f (<span style="color: #da70d6;">:a</span> foo))
                            <span style="color: #da70d6;">:b</span> (postwalk2 f (<span style="color: #da70d6;">:b</span> foo))}))))

(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">walk2</span> (<span style="color: #da70d6;">fn</span> [w f n] (<span style="color: #da70d6;">class</span> n)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">walk2</span> <span style="color: #da70d6;">:default</span> [w f n]
  n)

<span style="color: #b22222;">;; </span><span style="color: #b22222;">TODO: handle sets
</span>
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">walk2</span> IPersistentVector [w f n]
  (<span style="color: #da70d6;">apply</span> vector (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">partial</span> w f) n)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">walk2</span> IPersistentMap [w f n]
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">TODO: handle sorted maps
</span>  (<span style="color: #da70d6;">apply</span> array-map (<span style="color: #da70d6;">mapcat</span> (<span style="color: #da70d6;">partial</span> walk2 w f) n)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">walk2</span> IPersistentList [w f n]
  (<span style="color: #da70d6;">apply</span> list (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">partial</span> w f) n)))

(<span style="color: #da70d6;">prefer-method</span> walk2 IPersistentList ISeq)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">walk2</span> ISeq [w f n]
  (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">partial</span> w f) n))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">walking-helper-field</span>
  ([w f n field]
     `[~(<span style="color: #da70d6;">keyword</span> field) (~w ~f (~(<span style="color: #da70d6;">keyword</span> field) ~n))])
  ([w f n field &amp; more]
     `(<span style="color: #da70d6;">concat</span> (walking-helper-field ~w ~f ~n ~field) (walking-helper-field ~w ~f ~n ~@more))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">walking-helper-fields</span>
  [w f n fields]
  `(<span style="color: #da70d6;">apply</span> array-map (walking-helper-field ~w ~f ~n ~@fields)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">make-prewalk2-method</span>
  <span style="color: #bc8f8f;">"Define the methods used to walk data structures."</span>
  [ctor-name type-name field-list]
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">prewalk2</span> ~type-name [f# n#]
     (<span style="color: #a020f0;">if-let</span> [n2# (f# n#)]
       (~ctor-name n2# (walking-helper-fields prewalk2 f# n2# ~field-list)))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">make-postwalk2-method</span>
  <span style="color: #bc8f8f;">"Define the methods used to walk data structures."</span>
  [ctor-name type-name field-list]
  `(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">postwalk2</span> ~type-name [f# n#]
     (f# (~ctor-name n# (walking-helper-fields postwalk2 f# n# ~field-list)))))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">public entry points
</span>
(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">prewalk2</span> (<span style="color: #da70d6;">fn</span> [f n] (<span style="color: #da70d6;">class</span> n)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">prewalk2</span> <span style="color: #da70d6;">:default</span> [f n]
  (walk2 prewalk2 f (f n)))

(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">postwalk2</span> (<span style="color: #da70d6;">fn</span> [f n] (<span style="color: #da70d6;">class</span> n)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">postwalk2</span> <span style="color: #da70d6;">:default</span> [f n]
  (f (walk2 postwalk2 f n)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defrecord2</span>
  <span style="color: #bc8f8f;">"Defines a record and sets up constructor functions, printing, and pprinting for the new record type."</span>
  [type field-list &amp; protocols]
  (<span style="color: #a020f0;">let</span> [type-name (<span style="color: #a020f0;">if</span> (seqable? type) (<span style="color: #da70d6;">first</span> type) type)
        ctor-name (<span style="color: #a020f0;">if</span> (seqable? type)
                    (<span style="color: #da70d6;">second</span> type)
                    (<span style="color: #da70d6;">symbol</span> (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"new-"</span> (camel-to-dashed (<span style="color: #da70d6;">str</span> type)))))]
    `(<span style="color: #a020f0;">do</span> 
       <span style="color: #b22222;">;; </span><span style="color: #b22222;">define the record
</span>       (<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">~type-name</span> ~field-list ~@protocols)
       <span style="color: #b22222;">;; </span><span style="color: #b22222;">define the constructor functions
</span>       (make-record-constructor ~ctor-name
                                ~type-name
                                ~field-list
                                (~(<span style="color: #da70d6;">symbol</span> (<span style="color: #da70d6;">str</span> type-name <span style="color: #bc8f8f;">"."</span>)) ~@(<span style="color: #da70d6;">repeat</span> (<span style="color: #da70d6;">count</span> field-list) nil)))
       <span style="color: #b22222;">;; </span><span style="color: #b22222;">setup tree walking methods
</span>       (make-prewalk2-method ~ctor-name ~type-name ~field-list)
       (make-postwalk2-method ~ctor-name ~type-name ~field-list)

       <span style="color: #b22222;">;; </span><span style="color: #b22222;">setup printing
</span>       (<span style="color: #a020f0;">let</span> [empty-record# (~ctor-name {})
             native-keys# (<span style="color: #da70d6;">set</span> (<span style="color: #da70d6;">keys</span> empty-record#))]
         (setup-print-record ~ctor-name ~ctor-name native-keys# ~type-name)
         <span style="color: #b22222;">;; </span><span style="color: #b22222;">setup pprinting
</span>         (<span style="color: #da70d6;">comment</span>
           (use-method *simple-dispatch*
                       ~type-name

                       (generate-record-pprint ~ctor-name
                                               ~ctor-name
                                               native-keys#)))))))
</pre></div>



</div>

</div>

<div id="outline-container-4_2_2" class="outline-4">
<h4 id="sec-4_2_2"><span class="section-number-4">4.2.2</span> CLJ </h4>
<div class="outline-text-4" id="text-4_2_2">




<div class="org-src-container"><label class="org-src-name">clj-core()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> clj.core
  (<span style="color: #da70d6;">:refer-clojure</span> <span style="color: #da70d6;">:exclude</span> [promise swap! reset! defrecord spit file])
  (<span style="color: #da70d6;">:require</span> clj.third-party.defrecord2)
  (<span style="color: #da70d6;">:import</span> clojure.lang.APersistentMap java.io.Writer))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defrecord</span> [name fields &amp; protocols]
  `(clj.third-party.defrecord2/defrecord2 ~name ~fields ~@protocols))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: serializable records and atoms and refs 
</span>(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">swap!</span> (<span style="color: #da70d6;">fn</span> [a &amp; args] (<span style="color: #da70d6;">class</span> a)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">swap!</span> clojure.lang.Atom [&amp; args]
  (<span style="color: #da70d6;">apply</span> clojure.core/swap! args))
(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">reset!</span> (<span style="color: #da70d6;">fn</span> [a &amp; args] (<span style="color: #da70d6;">class</span> a)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">reset!</span> clojure.lang.Atom [&amp; args]
  (<span style="color: #da70d6;">apply</span> clojure.core/reset! args))
(<span style="color: #a020f0;">defprotocol</span> <span style="color: #0000ff;">PWait</span> 
  (wait-for [this timeout units] [this timeout]))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">copied from clojure source, but adding timeout wait-for
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">promise</span>
  <span style="color: #bc8f8f;">"Alpha - subject to change.
  Returns a promise object that can be read with deref/@, and set,
  once only, with deliver. Calls to deref/@ prior to delivery will
  block. All subsequent derefs will return the same delivered value
  without blocking."</span>
  {<span style="color: #da70d6;">:added</span> <span style="color: #bc8f8f;">"1.1"</span>}
  []
  (<span style="color: #a020f0;">let</span> [d (java.util.concurrent.CountDownLatch. 1)
        v (<span style="color: #da70d6;">atom</span> nil)]
    (<span style="color: #da70d6;">reify</span> 
      clojure.lang.IDeref
      (<span style="color: #da70d6;">deref</span> [_] (.await d) @v)
      PWait
      (wait-for [this timeout]
                (wait-for this timeout
                          java.util.concurrent.TimeUnit/MILLISECONDS))
      (wait-for [this timeout units]
                (<span style="color: #a020f0;">if</span> timeout
                  (.await d timeout units)
                  (<span style="color: #a020f0;">do</span> (.await d) true)))
      clojure.lang.IFn
      (invoke [this x] 
              (<span style="color: #da70d6;">locking</span> d
                (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">pos?</span> (.getCount d))
                  (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> v x)
                      (.countDown d)
                      x)
                  (<span style="color: #a020f0;">throw</span>
                   (IllegalStateException.
                    <span style="color: #bc8f8f;">"Multiple deliver calls to a promise"</span>))))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dup</span> clojure.lang.Atom [o w]
  (.write w <span style="color: #bc8f8f;">"#=(clojure.core/atom "</span>) (<span style="color: #da70d6;">print-dup</span> @o w) (.write w <span style="color: #bc8f8f;">")"</span>))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dup</span> clojure.lang.Ref [o w]
  (.write w <span style="color: #bc8f8f;">"#=(clojure.core/ref "</span>) (<span style="color: #da70d6;">print-dup</span> @o w) (.write w <span style="color: #bc8f8f;">")"</span>))
</pre></div>




<div class="org-src-container"><label class="org-src-name">clj-io()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;; </span><span style="color: #b22222;">duck_streams.clj -- duck-typed I/O streams for Clojure
</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">by Stuart Sierra, http://stuartsierra.com/
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">May 13, 2009
</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Copyright (c) Stuart Sierra, 2009. All rights reserved.  The use
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">and distribution terms for this software are covered by the Eclipse
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">which can be found in the file epl-v10.html at the root of this
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">distribution.  By using this software in any fashion, you are
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">agreeing to be bound by the terms of this license.  You must not
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">remove this notice, or any other, from this software.
</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">This file defines "duck-typed" I/O utility functions for Clojure.
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">The 'reader' and 'writer' functions will open and return an
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">instance of java.io.BufferedReader and java.io.BufferedWriter,
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">respectively, for a variety of argument types -- filenames as
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">strings, URLs, java.io.File's, etc.  'reader' even works on http
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">URLs.
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Note: this is not really "duck typing" as implemented in languages
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">like Ruby.  A better name would have been "do-what-I-mean-streams"
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">or "just-give-me-a-stream", but ducks are funnier.
</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">CHANGE LOG
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">May 13, 2009: added functions to open writers for appending
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">May 3, 2009: renamed file to file-str, for compatibility with
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">clojure.contrib.java.  reader/writer no longer use this
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">function.
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">February 16, 2009: (lazy branch) fixed read-lines to work with lazy
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">Clojure.
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">January 10, 2009: added *default-encoding*, so streams are always
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">opened as UTF-8.
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">December 19, 2008: rewrote reader and writer as multimethods; added
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">slurp*, file, and read-lines
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">April 8, 2008: first version
</span>


(<span style="color: #a020f0;">ns</span>
 #^{<span style="color: #da70d6;">:author</span> <span style="color: #bc8f8f;">"Stuart Sierra"</span>,
    <span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"This file defines polymorphic I/O utility functions for Clojure.

           The Streams protocol defines reader, writer, input-stream and
           output-stream methods that return BufferedReader, BufferedWriter,
           BufferedInputStream and BufferedOutputStream instances (respectively),
           with default implementations extended to a variety of argument
           types: URLs or filenames as strings, java.io.File's, Sockets, etc."</span>}
 clj.io
 (<span style="color: #da70d6;">:refer-clojure</span> <span style="color: #da70d6;">:exclude</span> (spit))
 (<span style="color: #da70d6;">:import</span> 
  (java.io Reader InputStream InputStreamReader PushbackReader
           BufferedReader File OutputStream
           OutputStreamWriter BufferedWriter Writer
           FileInputStream FileOutputStream ByteArrayOutputStream
           StringReader ByteArrayInputStream
           BufferedInputStream BufferedOutputStream
           CharArrayReader)
  (java.net URI URL MalformedURLException Socket)))

(<span style="color: #a020f0;">defmulti</span> <span style="color: #228b22;">#^File</span> ^{<span style="color: #da70d6;">:private</span> true} <span style="color: #0000ff;">as-file</span> 
  <span style="color: #bc8f8f;">"Interpret a String or a java.io.File as a File. Building block
   for clojure.contrib.java/file, which you should prefer
   in most cases."</span>
  class)
(<span style="color: #a020f0;">defmethod</span> ^{<span style="color: #da70d6;">:private</span> true} <span style="color: #0000ff;">as-file</span> String [<span style="color: #228b22;">#^String</span> s] (File. s))
(<span style="color: #a020f0;">defmethod</span> ^{<span style="color: #da70d6;">:private</span> true} <span style="color: #0000ff;">as-file</span> File [f] f)


(<span style="color: #a020f0;">def</span>
 #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Name of the default encoding to use when reading &amp; writing.
  Default is UTF-8."</span>
    <span style="color: #da70d6;">:tag</span> <span style="color: #bc8f8f;">"java.lang.String"</span>}
 <span style="color: #0000ff;">*default-encoding*</span> <span style="color: #bc8f8f;">"UTF-8"</span>)

(<span style="color: #a020f0;">def</span>
 #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Size, in bytes or characters, of the buffer used when
  copying streams."</span>}
 <span style="color: #0000ff;">*buffer-size*</span> 1024)

(<span style="color: #a020f0;">def</span>
 #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Type object for a Java primitive byte array."</span>}
 <span style="color: #0000ff;">*byte-array-type*</span> (<span style="color: #da70d6;">class</span> (<span style="color: #da70d6;">make-array</span> Byte/TYPE 0)))

(<span style="color: #a020f0;">def</span>
 #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Type object for a Java primitive char array."</span>}
 <span style="color: #0000ff;">*char-array-type*</span> (<span style="color: #da70d6;">class</span> (<span style="color: #da70d6;">make-array</span> Character/TYPE 0)))


(<span style="color: #a020f0;">defn</span> <span style="color: #228b22;">#^File</span> <span style="color: #0000ff;">file-str</span>
  <span style="color: #bc8f8f;">"Concatenates args as strings and returns a java.io.File.  Replaces
  all / and \\ with File/separatorChar.  Replaces ~ at the start of
  the path with the user.home system property."</span>
  [&amp; args]
  (<span style="color: #a020f0;">let</span> [<span style="color: #228b22;">#^String</span> s (<span style="color: #da70d6;">apply</span> str args)
        s (.replace s \\ File/separatorChar)
        s (.replace s \/ File/separatorChar)
        s (<span style="color: #a020f0;">if</span> (.startsWith s <span style="color: #bc8f8f;">"~"</span>)
            (<span style="color: #da70d6;">str</span> (System/getProperty <span style="color: #bc8f8f;">"user.home"</span>)
                 File/separator (<span style="color: #da70d6;">subs</span> s 1))
            s)]
    (File. s)))

(<span style="color: #a020f0;">def</span>
 #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"If true, writer, output-stream and spit will open files in append mode.
          Defaults to false.  Instead of binding this var directly, use append-writer,
          append-output-stream or append-spit."</span>
    <span style="color: #da70d6;">:tag</span> <span style="color: #bc8f8f;">"java.lang.Boolean"</span>}
 <span style="color: #0000ff;">*append*</span> false)

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">assert-not-appending</span> []
  (<span style="color: #a020f0;">when</span> *append*
    (<span style="color: #a020f0;">throw</span> (Exception. <span style="color: #bc8f8f;">"Cannot change an open stream to append mode."</span>))))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">@todo -- Both simple and elaborate methods for controlling buffering of
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">in the Streams protocol were implemented, considered, and postponed
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">see http://groups.google.com/group/clojure-dev/browse_frm/thread/3e39e9b3982f542b
</span>(<span style="color: #a020f0;">defprotocol</span> <span style="color: #0000ff;">Streams</span>
  (reader [x]
    <span style="color: #bc8f8f;">"Attempts to coerce its argument into an open java.io.Reader.
     The default implementations of this protocol always return a
     java.io.BufferedReader.

     Default implementations are provided for Reader, BufferedReader,
     InputStream, File, URI, URL, Socket, byte arrays, character arrays,
     and String.

     If argument is a String, it tries to resolve it first as a URI, then
     as a local file name.  URIs with a 'file' protocol are converted to
     local file names.  If this fails, a final attempt is made to resolve
     the string as a resource on the CLASSPATH.

     Uses *default-encoding* as the text encoding.

     Should be used inside with-open to ensure the Reader is properly
     closed."</span>)
  (writer [x]
    <span style="color: #bc8f8f;">"Attempts to coerce its argument into an open java.io.Writer.
     The default implementations of this protocol always return a
     java.io.BufferedWriter.

     Default implementations are provided for Writer, BufferedWriter,
     OutputStream, File, URI, URL, Socket, and String.

     If the argument is a String, it tries to resolve it first as a URI, then
     as a local file name.  URIs with a 'file' protocol are converted to
     local file names.

     Should be used inside with-open to ensure the Writer is properly
     closed."</span>)
  (input-stream [x]
    <span style="color: #bc8f8f;">"Attempts to coerce its argument into an open java.io.InputStream.
     The default implementations of this protocol always return a
     java.io.BufferedInputStream.

     Default implementations are defined for OutputStream, File, URI, URL,
     Socket, byte array, and String arguments.

     If the argument is a String, it tries to resolve it first as a URI, then
     as a local file name.  URIs with a 'file' protocol are converted to
     local file names.

     Should be used inside with-open to ensure the InputStream is properly
     closed."</span>)
  (output-stream [x]
    <span style="color: #bc8f8f;">"Attempts to coerce its argument into an open java.io.OutputStream.
     The default implementations of this protocol always return a
     java.io.BufferedOutputStream.

     Default implementations are defined for OutputStream, File, URI, URL,
     Socket, and String arguments.

     If the argument is a String, it tries to resolve it first as a URI, then
     as a local file name.  URIs with a 'file' protocol are converted to
     local file names.

     Should be used inside with-open to ensure the OutputStream is
     properly closed."</span>))

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">default-streams-impl</span>
  {<span style="color: #da70d6;">:reader</span> #(reader (input-stream %))
   <span style="color: #da70d6;">:writer</span> #(writer (output-stream %))
   <span style="color: #da70d6;">:input-stream</span> #(<span style="color: #a020f0;">throw</span> (Exception. (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"Cannot open &lt;"</span> (<span style="color: #da70d6;">pr-str</span> %) <span style="color: #bc8f8f;">"&gt; as an InputStream."</span>)))
   <span style="color: #da70d6;">:output-stream</span> #(<span style="color: #a020f0;">throw</span> (Exception. (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"Cannot open &lt;"</span> (<span style="color: #da70d6;">pr-str</span> %) <span style="color: #bc8f8f;">"&gt; as an OutputStream."</span>)))})

(<span style="color: #da70d6;">extend</span> File
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:input-stream</span> #(input-stream (FileInputStream. <span style="color: #228b22;">#^File</span> %))
    <span style="color: #da70d6;">:output-stream</span> #(<span style="color: #a020f0;">let</span> [stream (FileOutputStream. <span style="color: #228b22;">#^File</span> % *append*)]
                      (<span style="color: #a020f0;">binding</span> [*append* false]
                        (output-stream stream)))))
(<span style="color: #da70d6;">extend</span> URL
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:input-stream</span> (<span style="color: #da70d6;">fn</span> [<span style="color: #228b22;">#^URL</span> x]
                    (input-stream (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> <span style="color: #bc8f8f;">"file"</span> (.getProtocol x))
                                    (FileInputStream. (.getPath x))
                                    (.openStream x))))
    <span style="color: #da70d6;">:output-stream</span> (<span style="color: #da70d6;">fn</span> [<span style="color: #228b22;">#^URL</span> x]
                     (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> <span style="color: #bc8f8f;">"file"</span> (.getProtocol x))
                       (output-stream (File. (.getPath x)))
                       (<span style="color: #a020f0;">throw</span> (Exception. (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"Can not write to non-file URL &lt;"</span> x <span style="color: #bc8f8f;">"&gt;"</span>)))))))
(<span style="color: #da70d6;">extend</span> URI
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:input-stream</span> #(input-stream (.toURL <span style="color: #228b22;">#^URI</span> %))
    <span style="color: #da70d6;">:output-stream</span> #(output-stream (.toURL <span style="color: #228b22;">#^URI</span> %))))
(<span style="color: #da70d6;">extend</span> String
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:input-stream</span> #(<span style="color: #a020f0;">try</span>
                     (input-stream (URL. %))
                     (<span style="color: #a020f0;">catch</span> MalformedURLException e
                       (input-stream (File. <span style="color: #228b22;">#^String</span> %))))
    <span style="color: #da70d6;">:output-stream</span> #(<span style="color: #a020f0;">try</span>
                      (output-stream (URL. %))
                      (<span style="color: #a020f0;">catch</span> MalformedURLException err
                        (output-stream (File. <span style="color: #228b22;">#^String</span> %))))))
(<span style="color: #da70d6;">extend</span> Socket
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:input-stream</span> #(.getInputStream <span style="color: #228b22;">#^Socket</span> %)
    <span style="color: #da70d6;">:output-stream</span> #(output-stream (.getOutputStream <span style="color: #228b22;">#^Socket</span> %))))
(<span style="color: #da70d6;">extend</span> *byte-array-type*
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:input-stream</span> #(input-stream (ByteArrayInputStream. %))))
(<span style="color: #da70d6;">extend</span> *char-array-type*
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:reader</span> #(reader (CharArrayReader. %))))
(<span style="color: #da70d6;">extend</span> Object
  Streams
  default-streams-impl)

(<span style="color: #da70d6;">extend</span> Reader
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:reader</span> #(BufferedReader. %)))
(<span style="color: #da70d6;">extend</span> BufferedReader
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:reader</span> identity))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">inputstream-&gt;reader</span>
  [<span style="color: #228b22;">#^InputStream</span> is]
  (reader (InputStreamReader. is *default-encoding*)))
(<span style="color: #da70d6;">extend</span> InputStream
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:input-stream</span> #(BufferedInputStream. %)
    <span style="color: #da70d6;">:reader</span> inputstream-&gt;reader))
(<span style="color: #da70d6;">extend</span> BufferedInputStream
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:input-stream</span> identity
    <span style="color: #da70d6;">:reader</span> inputstream-&gt;reader))

(<span style="color: #da70d6;">extend</span> Writer
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:writer</span> #(<span style="color: #a020f0;">do</span> (assert-not-appending)
                                           (BufferedWriter. %))))
(<span style="color: #da70d6;">extend</span> BufferedWriter
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl <span style="color: #da70d6;">:writer</span> #(<span style="color: #a020f0;">do</span> (assert-not-appending) %)))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">outputstream-&gt;writer</span>
  [<span style="color: #228b22;">#^OutputStream</span> os]
  (assert-not-appending)
  (writer (OutputStreamWriter. os *default-encoding*)))
(<span style="color: #da70d6;">extend</span> OutputStream
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:output-stream</span> #(<span style="color: #a020f0;">do</span> (assert-not-appending)
                        (BufferedOutputStream. %))
    <span style="color: #da70d6;">:writer</span> outputstream-&gt;writer))
(<span style="color: #da70d6;">extend</span> BufferedOutputStream
  Streams
  (<span style="color: #da70d6;">assoc</span> default-streams-impl
    <span style="color: #da70d6;">:output-stream</span> #(<span style="color: #a020f0;">do</span> (assert-not-appending) %)
      <span style="color: #da70d6;">:writer</span> outputstream-&gt;writer))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">append-output-stream</span>
  <span style="color: #bc8f8f;">"Like output-stream but opens file for appending.  Does not work on streams
  that are already open."</span>
  [x]
  (<span style="color: #a020f0;">binding</span> [*append* true]
    (output-stream x)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">append-writer</span>
  <span style="color: #bc8f8f;">"Like writer but opens file for appending.  Does not work on streams
  that are already open."</span>
  [x]
  (<span style="color: #a020f0;">binding</span> [*append* true]
    (writer x)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">write-lines</span>
  <span style="color: #bc8f8f;">"Writes lines (a seq) to f, separated by newlines.  f is opened with
  writer, and automatically closed at the end of the sequence."</span>
  [f lines]
  (<span style="color: #a020f0;">with-open</span> [<span style="color: #228b22;">#^BufferedWriter</span> writer (writer f)]
    (<span style="color: #a020f0;">loop</span> [lines lines]
      (<span style="color: #a020f0;">when-let</span> [line (<span style="color: #da70d6;">first</span> lines)]
        (.write writer (<span style="color: #da70d6;">str</span> line))
        (.newLine writer)
        (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> lines))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">read-lines</span>
  <span style="color: #bc8f8f;">"Like clojure.core/line-seq but opens f with reader.  Automatically
  closes the reader AFTER YOU CONSUME THE ENTIRE SEQUENCE."</span>
  [f]
  (<span style="color: #a020f0;">let</span> [read-line (<span style="color: #da70d6;">fn</span> <span style="color: #0000ff;">this</span> [<span style="color: #228b22;">#^BufferedReader</span> rdr]
                    (<span style="color: #da70d6;">lazy-seq</span>
                     (<span style="color: #a020f0;">if-let</span> [line (.readLine rdr)]
                       (<span style="color: #da70d6;">cons</span> line (this rdr))
                       (.close rdr))))]
    (<span style="color: #da70d6;">read-line</span> (reader f))))

(<span style="color: #a020f0;">defn</span> <span style="color: #228b22;">#^String</span> <span style="color: #0000ff;">slurp*</span>
  <span style="color: #bc8f8f;">"Like clojure.core/slurp but opens f with reader."</span>
  [f]
  (<span style="color: #a020f0;">with-open</span> [<span style="color: #228b22;">#^BufferedReader</span> r (reader f)]
      (<span style="color: #a020f0;">let</span> [sb (StringBuilder.)]
        (<span style="color: #a020f0;">loop</span> [c (.read r)]
          (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">neg?</span> c)
            (<span style="color: #da70d6;">str</span> sb)
            (<span style="color: #a020f0;">do</span> (.append sb (<span style="color: #da70d6;">char</span> c))
                (<span style="color: #a020f0;">recur</span> (.read r))))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">spit</span>
  <span style="color: #bc8f8f;">"Opposite of slurp.  Opens f with writer, writes content, then
  closes f."</span>
  [f content]
  (<span style="color: #a020f0;">with-open</span> [<span style="color: #228b22;">#^Writer</span> w (writer f)]
    (.write w content)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">append-spit</span>
  <span style="color: #bc8f8f;">"Like spit but appends to file."</span>
  [f content]
  (<span style="color: #a020f0;">with-open</span> [<span style="color: #228b22;">#^Writer</span> w (append-writer f)]
    (.write w content)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">pwd</span>
  <span style="color: #bc8f8f;">"Returns current working directory as a String.  (Like UNIX 'pwd'.)
  Note: In Java, you cannot change the current working directory."</span>
  []
  (System/getProperty <span style="color: #bc8f8f;">"user.dir"</span>))



(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-out-writer</span>
  <span style="color: #bc8f8f;">"Opens a writer on f, binds it to *out*, and evalutes body.
  Anything printed within body will be written to f."</span>
  [f &amp; body]
  `(<span style="color: #a020f0;">with-open</span> [stream# (writer ~f)]
     (<span style="color: #a020f0;">binding</span> [*out* stream#]
       ~@body)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-out-append-writer</span>
  <span style="color: #bc8f8f;">"Like with-out-writer but appends to file."</span>
  [f &amp; body]
  `(<span style="color: #a020f0;">with-open</span> [stream# (append-writer ~f)]
     (<span style="color: #a020f0;">binding</span> [*out* stream#]
       ~@body)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-in-reader</span>
  <span style="color: #bc8f8f;">"Opens a PushbackReader on f, binds it to *in*, and evaluates body."</span>
  [f &amp; body]
  `(<span style="color: #a020f0;">with-open</span> [stream# (PushbackReader. (reader ~f))]
     (<span style="color: #a020f0;">binding</span> [*in* stream#]
       ~@body)))

(<span style="color: #a020f0;">defmulti</span>
  #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Copies input to output.  Returns nil.
  Input may be an InputStream, Reader, File, byte[], or String.
  Output may be an OutputStream, Writer, or File.

  Does not close any streams except those it opens itself 
  (on a File).

  Writing a File fails if the parent directory does not exist."</span>
     <span style="color: #da70d6;">:arglists</span> '([input output])}
  <span style="color: #0000ff;">copy</span>
  (<span style="color: #da70d6;">fn</span> [input output]
    [(<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> input) File (<span style="color: #da70d6;">type</span> input))
     (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> output) File (<span style="color: #da70d6;">type</span> output))]))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [InputStream OutputStream] [<span style="color: #228b22;">#^InputStream</span> input <span style="color: #228b22;">#^OutputStream</span> output]
  (<span style="color: #a020f0;">let</span> [buffer (<span style="color: #da70d6;">make-array</span> Byte/TYPE *buffer-size*)]
    (<span style="color: #a020f0;">loop</span> []
      (<span style="color: #a020f0;">let</span> [size (.read input buffer)]
        (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">pos?</span> size)
          (<span style="color: #a020f0;">do</span> (.write output buffer 0 size)
              (<span style="color: #a020f0;">recur</span>)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [InputStream Writer] [<span style="color: #228b22;">#^InputStream</span> input <span style="color: #228b22;">#^Writer</span> output]
  (<span style="color: #a020f0;">let</span> [#^<span style="color: #bc8f8f;">"[B"</span> buffer (<span style="color: #da70d6;">make-array</span> Byte/TYPE *buffer-size*)]
    (<span style="color: #a020f0;">loop</span> []
      (<span style="color: #a020f0;">let</span> [size (.read input buffer)]
        (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">pos?</span> size)
          (<span style="color: #a020f0;">let</span> [chars (.toCharArray (String. buffer 0 size *default-encoding*))]
            (<span style="color: #a020f0;">do</span> (.write output chars)
                (<span style="color: #a020f0;">recur</span>))))))))


(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [InputStream File] [<span style="color: #228b22;">#^InputStream</span> input <span style="color: #228b22;">#^File</span> output]
  (<span style="color: #a020f0;">with-open</span> [out (FileOutputStream. output)]
    (copy input out)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [Reader OutputStream] [<span style="color: #228b22;">#^Reader</span> input <span style="color: #228b22;">#^OutputStream</span> output]
  (<span style="color: #a020f0;">let</span> [#^<span style="color: #bc8f8f;">"[C"</span> buffer (<span style="color: #da70d6;">make-array</span> Character/TYPE *buffer-size*)]
    (<span style="color: #a020f0;">loop</span> []
      (<span style="color: #a020f0;">let</span> [size (.read input buffer)]
        (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">pos?</span> size)
          (<span style="color: #a020f0;">let</span> [bytes (.getBytes (String. buffer 0 size) *default-encoding*)]
            (<span style="color: #a020f0;">do</span> (.write output bytes)
                (<span style="color: #a020f0;">recur</span>))))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [Reader Writer] [<span style="color: #228b22;">#^Reader</span> input <span style="color: #228b22;">#^Writer</span> output]
  (<span style="color: #a020f0;">let</span> [#^<span style="color: #bc8f8f;">"[C"</span> buffer (<span style="color: #da70d6;">make-array</span> Character/TYPE *buffer-size*)]
    (<span style="color: #a020f0;">loop</span> []
      (<span style="color: #a020f0;">let</span> [size (.read input buffer)]
        (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">pos?</span> size)
          (<span style="color: #a020f0;">do</span> (.write output buffer 0 size)
              (<span style="color: #a020f0;">recur</span>)))))))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [Reader File] [<span style="color: #228b22;">#^Reader</span> input <span style="color: #228b22;">#^File</span> output]
  (<span style="color: #a020f0;">with-open</span> [out (FileOutputStream. output)]
    (copy input out)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [File OutputStream] [<span style="color: #228b22;">#^File</span> input <span style="color: #228b22;">#^OutputStream</span> output]
  (<span style="color: #a020f0;">with-open</span> [in (FileInputStream. input)]
    (copy in output)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [File Writer] [<span style="color: #228b22;">#^File</span> input <span style="color: #228b22;">#^Writer</span> output]
  (<span style="color: #a020f0;">with-open</span> [in (FileInputStream. input)]
    (copy in output)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [File File] [input output]
  (<span style="color: #a020f0;">with-open</span> [in (FileInputStream. (as-file input))
              out (FileOutputStream. (as-file output))]
    (copy in out)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [String OutputStream] [<span style="color: #228b22;">#^String</span> input <span style="color: #228b22;">#^OutputStream</span> output]
  (copy (StringReader. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [String Writer] [<span style="color: #228b22;">#^String</span> input <span style="color: #228b22;">#^Writer</span> output]
  (copy (StringReader. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [String File] [<span style="color: #228b22;">#^String</span> input <span style="color: #228b22;">#^File</span> output]
  (copy (StringReader. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [*char-array-type* OutputStream] [input <span style="color: #228b22;">#^OutputStream</span> output]
  (copy (CharArrayReader. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [*char-array-type* Writer] [input <span style="color: #228b22;">#^Writer</span> output]
  (copy (CharArrayReader. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [*char-array-type* File] [input <span style="color: #228b22;">#^File</span> output]
  (copy (CharArrayReader. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [*byte-array-type* OutputStream] [#^<span style="color: #bc8f8f;">"[B"</span> input <span style="color: #228b22;">#^OutputStream</span> output]
  (copy (ByteArrayInputStream. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [*byte-array-type* Writer] [#^<span style="color: #bc8f8f;">"[B"</span> input <span style="color: #228b22;">#^Writer</span> output]
  (copy (ByteArrayInputStream. input) output))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy</span> [*byte-array-type* File] [#^<span style="color: #bc8f8f;">"[B"</span> input <span style="color: #228b22;">#^Writer</span> output]
  (copy (ByteArrayInputStream. input) output))


(<span style="color: #a020f0;">defmulti</span>
  #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Converts argument into a Java byte array.  Argument may be
  a String, File, InputStream, or Reader.  If the argument is already
  a byte array, returns it."</span>
    <span style="color: #da70d6;">:arglists</span> '([arg])}
  <span style="color: #0000ff;">to-byte-array</span> type)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">to-byte-array</span> *byte-array-type* [x] x)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">to-byte-array</span> String [<span style="color: #228b22;">#^String</span> x]
  (.getBytes x *default-encoding*))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">to-byte-array</span> File [<span style="color: #228b22;">#^File</span> x]
  (<span style="color: #a020f0;">with-open</span> [input (FileInputStream. x)
              buffer (ByteArrayOutputStream.)]
    (copy input buffer)
    (.toByteArray buffer)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">to-byte-array</span> InputStream [<span style="color: #228b22;">#^InputStream</span> x]
  (<span style="color: #a020f0;">let</span> [buffer (ByteArrayOutputStream.)]
    (copy x buffer)
    (.toByteArray buffer)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">to-byte-array</span> Reader [<span style="color: #228b22;">#^Reader</span> x]
  (.getBytes (slurp* x) *default-encoding*))

(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">relative-path-string</span> 
  <span style="color: #bc8f8f;">"Interpret a String or java.io.File as a relative path string. 
   Building block for clojure.contrib.java/file."</span>
  class)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">relative-path-string</span> String [<span style="color: #228b22;">#^String</span> s]
  (relative-path-string (File. s)))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">relative-path-string</span> File [<span style="color: #228b22;">#^File</span> f]
  (<span style="color: #a020f0;">if</span> (.isAbsolute f)
    (<span style="color: #a020f0;">throw</span> (IllegalArgumentException. (<span style="color: #da70d6;">str</span> f <span style="color: #bc8f8f;">" is not a relative path"</span>)))
    (.getPath f)))


(<span style="color: #a020f0;">defn</span> <span style="color: #228b22;">#^File</span> <span style="color: #0000ff;">file</span>
  <span style="color: #bc8f8f;">"Returns a java.io.File from string or file args."</span>
  ([arg]                      
     (as-file arg))
  ([parent child]             
     (File. <span style="color: #228b22;">#^File</span> (as-file parent) <span style="color: #228b22;">#^String</span> (relative-path-string child)))
  ([parent child &amp; more]
     (<span style="color: #da70d6;">reduce</span> file (file parent child) more)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">delete-file</span>
  <span style="color: #bc8f8f;">"Delete file f. Raise an exception if it fails unless silently is true."</span>
  [f &amp; [silently]]
  (<span style="color: #a020f0;">or</span> (.delete (file f))
      silently
      (<span style="color: #a020f0;">throw</span> (java.io.IOException. (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"Couldn't delete "</span> f)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">delete-file-recursively</span>
  <span style="color: #bc8f8f;">"Delete file f. If it's a directory, recursively delete all its contents.
Raise an exception if any deletion fails unless silently is true."</span>
  [f &amp; [silently]]
  (<span style="color: #a020f0;">let</span> [f (file f)]
    (<span style="color: #a020f0;">if</span> (.isDirectory f)
      (<span style="color: #a020f0;">doseq</span> [child (.listFiles f)]
        (delete-file-recursively child silently)))
    (delete-file f silently)))

(<span style="color: #a020f0;">defmulti</span>
  #^{<span style="color: #da70d6;">:doc</span> <span style="color: #bc8f8f;">"Coerces argument (URL, URI, or String) to a java.net.URL."</span>
     <span style="color: #da70d6;">:arglists</span> '([arg])}
  <span style="color: #0000ff;">as-url</span> type)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">as-url</span> URL [x] x)

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">as-url</span> URI [<span style="color: #228b22;">#^URI</span> x] (.toURL x))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">as-url</span> String [<span style="color: #228b22;">#^String</span> x] (URL. x))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">as-url</span> File [<span style="color: #228b22;">#^File</span> x] (.toURL x))



(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">make-parents</span>
  <span style="color: #bc8f8f;">"Creates all parent directories of file."</span>
  [file]
  (.mkdirs (.getParentFile (as-file file))))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">copy-dir</span> [source target]
  (<span style="color: #a020f0;">let</span> [source (as-file source) target (as-file target)]
    (make-parents target)
    (<span style="color: #a020f0;">loop</span> [source source target target]
      (<span style="color: #a020f0;">if</span> (.isDirectory source)
        (<span style="color: #a020f0;">do</span> (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">not</span> (.exists target)) (.mkdir target))
            (<span style="color: #a020f0;">doseq</span> [child (.list source)]             
              (copy-dir (file source child) (file target child))))
        (<span style="color: #a020f0;">if</span> (.exists source) (copy source target))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">file-type</span> [f]
  (<span style="color: #a020f0;">if</span> (.isFile f)
    (<span style="color: #a020f0;">let</span> [a (.split (.getName f) <span style="color: #bc8f8f;">"\\."</span>)]
      (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">&gt;</span> (<span style="color: #da70d6;">count</span> a) 1)
        (<span style="color: #da70d6;">last</span> a)
        <span style="color: #bc8f8f;">""</span>))
    <span style="color: #bc8f8f;">""</span>))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">list-files</span> [source]
  (<span style="color: #a020f0;">let</span> [source (as-file source)
        files (.listFiles source)]
    (<span style="color: #da70d6;">lazy-seq</span>
     (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> files)
       nil
       (<span style="color: #da70d6;">apply</span> concat (<span style="color: #da70d6;">vec</span> files) (<span style="color: #da70d6;">map</span> list-files (<span style="color: #da70d6;">filter</span> #(.isDirectory %) files)))))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">(count (filter #(= (file-type %) "clj") (list-files "/home/seth/Dropbox/.rep/clj-forex/")))
</span></pre></div>



</div>

</div>

<div id="outline-container-4_2_3" class="outline-4">
<h4 id="sec-4_2_3"><span class="section-number-4">4.2.3</span> Core </h4>
<div class="outline-text-4" id="text-4_2_3">




<div class="org-src-container"><label class="org-src-name">forex-util-core()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.util.core
  (<span style="color: #da70d6;">:clone</span> clj.core)
  (<span style="color: #da70d6;">:use</span> forex.util.emacs forex.util.general forex.util.spawn forex.util.log)
  (<span style="color: #da70d6;">:require</span> clojure.contrib.error-kit clojure.contrib.pprint)
  (<span style="color: #da70d6;">:import</span> java.io.File (org.joda.time DateTime DateTimeZone Instant)))

(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*debug*</span> true)
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">debug</span> [msg &amp; args]
  (<span style="color: #a020f0;">when</span> *debug* (<span style="color: #da70d6;">apply</span> out (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"DEBUG: "</span> msg) args)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: we need a combination of saving using byte straems and saving as clojure! that way clojure stuff is compatible with later stuff 
</span>
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">make-exception</span> [a] (Exception. a))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dup</span> Exception [o w]
  (.write w (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"#=(forex.util.core/make-exception \""</span> (.getMessage o) <span style="color: #bc8f8f;">"\")"</span>)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: memoize pow?
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">used from http://groups.google.com/group/clojure/browse_thread/thread/cb5246d07142a3dc?fwc=2&amp;pli=1
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">frm-save</span> 
 <span style="color: #bc8f8f;">"Save a clojure form to file."</span> 
  [file form] 
  (<span style="color: #a020f0;">with-open</span> [w (java.io.FileWriter.
                 (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">instance?</span> File file) file (File. file)))] 
    (<span style="color: #a020f0;">binding</span> [*out* w *print-dup* true] (<span style="color: #da70d6;">prn</span> form))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">frm-load</span> 
  <span style="color: #bc8f8f;">"Load a clojure form from file."</span> 
  [file] 
  (<span style="color: #a020f0;">with-open</span> [r (java.io.PushbackReader. 
     (java.io.FileReader. (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">instance?</span> File file) file (File. file))))] 
     (<span style="color: #a020f0;">let</span> [rec (<span style="color: #da70d6;">read</span> r)] 
       rec)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">round</span> [num places]
  (<span style="color: #a020f0;">let</span> [multiplier (Math/pow 10 places)]
    (<span style="color: #da70d6;">/</span> (<span style="color: #da70d6;">int</span> (<span style="color: #da70d6;">*</span> num multiplier)) multiplier)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ns?</span> [a] (<span style="color: #da70d6;">instance?</span> clojure.lang.Namespace a))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">decimal-places</span> [num]
  (<span style="color: #a020f0;">let</span> [<span style="color: #228b22;">^String</span> s (<span style="color: #da70d6;">reverse</span> (<span style="color: #da70d6;">second</span> (.split (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">double</span> num)) <span style="color: #bc8f8f;">"\\."</span>)))
        c (<span style="color: #da70d6;">count</span> s)]
    (<span style="color: #a020f0;">loop</span> [c (<span style="color: #da70d6;">nth</span> s 0) i 0]
      (<span style="color: #a020f0;">cond</span>
       (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> i c) (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> c \0)))
       (<span style="color: #da70d6;">-</span> (<span style="color: #da70d6;">count</span> s) i)
       true
       (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">nth</span> s (<span style="color: #da70d6;">inc</span> i)) (<span style="color: #da70d6;">inc</span> i))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ns-symbol</span>
  ([symbol] (ns-symbol symbol *ns*))
  ([symbol ns] (ns-symbol symbol ns nil))
  ([symbol ns default]
     (<span style="color: #a020f0;">let</span> [var ((<span style="color: #da70d6;">ns-interns</span> ns) symbol)]
       (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">var?</span> var) (<span style="color: #da70d6;">var-get</span> var)) var default))))

(<span style="color: #a020f0;">deftype</span> <span style="color: #0000ff;">AtomHash</span> [val]
  Object
  (toString [this] (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"&lt;AtomHash "</span> @val <span style="color: #bc8f8f;">"&gt;"</span>))
  clojure.lang.IPersistentMap
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">ILookup
</span>  (valAt [this key] (<span style="color: #da70d6;">get</span> @val key))
  (valAt [this key notfound] (<span style="color: #da70d6;">get</span> @val key notfound))
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">IPersistentCollection
</span>  (<span style="color: #da70d6;">count</span> [this] (.count @val))
  (<span style="color: #da70d6;">empty</span> [this]  {}) 
  (<span style="color: #da70d6;">cons</span> [this e]  (.cons @val e))
  (equiv [this gs] (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">identical?</span> this gs)
                       (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">identical?</span> (<span style="color: #da70d6;">class</span> this) (<span style="color: #da70d6;">class</span> gs))
                         (<span style="color: #da70d6;">=</span> val (.val gs)))))
  (containsKey [this k] (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">get</span> @val k) true) false))
  (entryAt [this k] (<span style="color: #da70d6;">get</span> @val k))
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">Seqable
</span>  (<span style="color: #da70d6;">seq</span> [this] (<span style="color: #da70d6;">seq</span> @val))
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">Associative 
</span>  (<span style="color: #da70d6;">assoc</span> [this k g] (<span style="color: #da70d6;">assoc</span> @val k g))
  (assocEx [this k g] (<span style="color: #da70d6;">assoc</span> this k g))
  (without [this k] (.without @val k))
  clojure.lang.IDeref
  (<span style="color: #da70d6;">deref</span> [this] @val))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">todo - create ns-resolve-symbol, instead of hardcoding namespace
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: add pprint
</span>(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dup</span> AtomHash [o w]
  (.write w <span style="color: #bc8f8f;">"#=(forex.util.core/atom-hash "</span>) (<span style="color: #da70d6;">print-dup</span> @o w) (.write w <span style="color: #bc8f8f;">")"</span>))

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">clojure.core/print-method</span> AtomHash [o w]
  (.write w (.toString o)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: make into protocol method! not multimethod!
</span>(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">swap!</span>  forex.util.core.AtomHash [a &amp; args]
  (<span style="color: #da70d6;">apply</span> swap! (.val a) args))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">reset!</span>  forex.util.core.AtomHash [a &amp; args]
  (<span style="color: #da70d6;">apply</span> reset! (.val a) args))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">atom-hash</span>
  ([] (atom-hash {}))
  ([val]
     (<span style="color: #a020f0;">let</span> [val (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">nil?</span> val) {} val)]
      (<span style="color: #228b22;">is</span> (<span style="color: #da70d6;">map?</span> val))
      (AtomHash. (<span style="color: #da70d6;">atom</span> val)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">symbolicate</span>
  <span style="color: #bc8f8f;">"symbolicate symbols together. ignores things like whitespaces, just drops them!"</span>
  [&amp; args]
  (<span style="color: #da70d6;">symbol</span> (<span style="color: #da70d6;">apply</span> str args)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">naive-var-local-cache-strategy</span> [var] 
 `(<span style="color: #a020f0;">let</span> [cache# (<span style="color: #da70d6;">atom</span> {})]
    (<span style="color: #da70d6;">reify</span> PCachingStrategy
      (retrieve [_ item#] (<span style="color: #da70d6;">get</span> @cache# item#))
      (cached? [_ item#] (<span style="color: #da70d6;">contains?</span> @cache# item#))
      (hit [this# _] this#)
      (miss [this# item# result#]
            (<span style="color: #da70d6;">reset!</span> cache# (<span style="color: #da70d6;">swap!</span> ~var assoc item# result#))
            this#))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">constants</span> [&amp; args]
  `(<span style="color: #a020f0;">do</span> ~@(<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [[name val]] `(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">~name</span> ~val)) (group args 2))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">spawn-log</span> [func name]
  `(spawn (<span style="color: #da70d6;">fn</span> [] (<span style="color: #a020f0;">try</span> (~func) (<span style="color: #a020f0;">catch</span> Exception e#
                                (.printStackTrace e#) (severe e#))))
          ~name)) 

(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*env*</span> (<span style="color: #da70d6;">atom</span> {<span style="color: #da70d6;">:period</span> 240 <span style="color: #da70d6;">:symbol</span> <span style="color: #bc8f8f;">"EURUSD"</span>})) <span style="color: #b22222;">;</span><span style="color: #b22222;">default +H4+, EURUSD
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">env</span>
  ([] @*env*)
  ([key] (<span style="color: #da70d6;">get</span> @*env* key)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">env!</span> [map] 
  (<span style="color: #da70d6;">swap!</span> *env* #(<span style="color: #da70d6;">merge</span> % map))
  map)

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">wenv</span> [map &amp; body] 
  `(<span style="color: #a020f0;">binding</span> [forex.util.core/*env*
             (<span style="color: #da70d6;">atom</span> (<span style="color: #da70d6;">merge</span> @@~#'*env* ~map))]
     ~@body))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">aliases for error kit
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ns-export</span> [from-ns]  
  (<span style="color: #da70d6;">count</span> (<span style="color: #a020f0;">doall</span> (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [[sym var]]
                       (<span style="color: #a020f0;">let</span> [var-obj (<span style="color: #a020f0;">if</span> (.hasRoot var)
                                       (<span style="color: #da70d6;">intern</span> *ns* sym (<span style="color: #da70d6;">var-get</span> var))
                                       (<span style="color: #da70d6;">intern</span> *ns* sym))]
                         (<span style="color: #a020f0;">when</span> var-obj
                           (<span style="color: #da70d6;">alter-meta!</span> var-obj
                                        (<span style="color: #da70d6;">fn</span> [old] (<span style="color: #da70d6;">merge</span> (<span style="color: #da70d6;">meta</span> var) old)))
                           var-obj)))
                     (<span style="color: #da70d6;">ns-publics</span> from-ns)))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">eval-when</span> [&amp; args]
  (<span style="color: #da70d6;">eval</span> `(<span style="color: #a020f0;">do</span> ~@args)) nil)

(eval-when
 (<span style="color: #da70d6;">require</span> 'clojure.contrib.error-kit)
 (ns-export (<span style="color: #da70d6;">find-ns</span> 'clojure.contrib.error-kit)))

(deferror *clj-forex-error* [] [message] 
  {<span style="color: #da70d6;">:msg</span> (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"clj-forex error: "</span> message) 
   <span style="color: #da70d6;">:unhandled</span> (throw-msg Exception)})

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">throwf</span> [msg &amp; args] (raise *clj-forex-error* (<span style="color: #da70d6;">apply</span> format  msg args)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">is?</span>
  [val &amp; message]
  (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">vector?</span> val)
    `(<span style="color: #a020f0;">do</span> ~@(<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [test] `(is? ~test ~@message)) val))
    `(<span style="color: #a020f0;">let</span> [result# ~val]
       (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">not</span> result#)
         (throwf  ~(<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">first</span> message)
                            `(<span style="color: #da70d6;">format</span> ~@message))
                       (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"assertion %s failed"</span>
                               (<span style="color: #da70d6;">str</span> val))))
         result#))))
</pre></div>


</div>

</div>

<div id="outline-container-4_2_4" class="outline-4">
<h4 id="sec-4_2_4"><span class="section-number-4">4.2.4</span> General </h4>
<div class="outline-text-4" id="text-4_2_4">




<div class="org-src-container"><label class="org-src-name">forex-util-general()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.util.general 
  (<span style="color: #da70d6;">:require</span>  [clojure.contrib.str-utils2 <span style="color: #da70d6;">:as</span> s] clojure.string)
  (<span style="color: #da70d6;">:import</span> java.lang.management.ManagementFactory)
  (<span style="color: #da70d6;">:require</span> [matchure <span style="color: #da70d6;">:as</span> m]
            [clojure.contrib.def <span style="color: #da70d6;">:as</span> d])
  (<span style="color: #da70d6;">:use</span> clojure.contrib.macro-utils))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-out-str+</span>
  <span style="color: #bc8f8f;">"Evaluates exprs in a context in which *out* is bound to a fresh
  StringWriter.  Returns the string created by any nested printing
  calls."</span>  {<span style="color: #da70d6;">:added</span> <span style="color: #bc8f8f;">"1.0"</span>} [arg &amp; body]
  `(<span style="color: #a020f0;">let</span> [~arg (new java.io.StringWriter)]
     (<span style="color: #a020f0;">binding</span> [*out* ~arg]
       ~@body)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-shutdown-hook</span> [a]
  (<span style="color: #a020f0;">try</span>
    (.addShutdownHook (Runtime/getRuntime) a)
    true
    (<span style="color: #a020f0;">catch</span> Exception e false)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">dump-threads</span> []
  (<span style="color: #a020f0;">let</span> [info (.dumpAllThreads (ManagementFactory/getThreadMXBean) false false)]
   (<span style="color: #a020f0;">doall</span>
    (<span style="color: #da70d6;">map</span> println info))
   (<span style="color: #da70d6;">count</span> info)))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">seq1</span> [s]
  (<span style="color: #da70d6;">reify</span> clojure.lang.ISeq
    (<span style="color: #da70d6;">first</span> [_] (.first s))
    (more [_] (seq1 (.more s)))
    (<span style="color: #da70d6;">next</span> [_] (<span style="color: #a020f0;">let</span> [sn (.next s)] (<span style="color: #a020f0;">and</span> sn (seq1 sn))))
    (<span style="color: #da70d6;">seq</span> [_] (<span style="color: #a020f0;">let</span> [ss (.seq s)] (<span style="color: #a020f0;">and</span> ss (seq1 ss))))
    (<span style="color: #da70d6;">count</span> [_] (.count s))
    (<span style="color: #da70d6;">cons</span> [_ o] (.cons s o))
    (<span style="color: #da70d6;">empty</span> [_] (.empty s))
    (equiv [_ o] (.equiv s o))))
(d/defalias defalias d/defalias)

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">upper?</span> [s]
  (<span style="color: #da70d6;">=</span> (.toUpperCase s) s))

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">join</span> clojure.string/<span style="color: #228b22;">join</span>)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">split</span> s/split)
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">atom?</span> [a] (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">symbol?</span> a) (<span style="color: #da70d6;">number?</span> a)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">camel case - gotten from defrecord2 on github
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">assemble-words</span> [parts]
  (<span style="color: #a020f0;">loop</span> [remaining-parts parts result []]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">seq</span> remaining-parts)
      (<span style="color: #a020f0;">let</span> [part (<span style="color: #da70d6;">first</span> remaining-parts)]
        (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> remaining-parts)
               (<span style="color: #a020f0;">if</span> (upper? part)
                 (<span style="color: #da70d6;">conj</span> result (.toLowerCase part))
                 (<span style="color: #da70d6;">conj</span> (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">seq</span> result)
                         (<span style="color: #da70d6;">pop</span> result)
                         []) (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">last</span> result) part)))))
      result)))



(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">camel-to-dash</span>
  <span style="color: #bc8f8f;">"Convert a name like 'BigBlueCar' to 'big-blue-car'."</span>
  [s]
  (<span style="color: #a020f0;">let</span> [parts (<span style="color: #da70d6;">remove</span> #(<span style="color: #da70d6;">=</span> <span style="color: #bc8f8f;">""</span> %) (s/partition s #<span style="color: #bc8f8f;">"[A-Z]"</span>))
        words (assemble-words parts)]
    (<span style="color: #228b22;">join</span> <span style="color: #bc8f8f;">"-"</span> words)))
<span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">classpath</span> []
  (<span style="color: #da70d6;">seq</span> (.getURLs (java.lang.ClassLoader/getSystemClassLoader))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">sequence?</span> [a] (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">list?</span> a) (<span style="color: #da70d6;">vector?</span> a) (<span style="color: #da70d6;">seq?</span> a)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">var-root-set</span> [var val]
  (<span style="color: #da70d6;">alter-var-root</span> var (<span style="color: #da70d6;">constantly</span> val)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">copied from  
</span>(<span style="color: #a020f0;">defprotocol</span> <span style="color: #0000ff;">PCachingStrategy</span>
  <span style="color: #bc8f8f;">"A caching strategy implements the backend for memoize. It handles the
  underlying cache and might define different strategies to remove old
  items from the cache."</span>
  (retrieve [cache item] <span style="color: #bc8f8f;">"Get the requested cache item."</span>)
  (cached?  [cache item] <span style="color: #bc8f8f;">"Checks whether the given argument list is cached."</span>)
  (hit      [cache item] <span style="color: #bc8f8f;">"Called in case of a cache hit."</span>)
  (miss     [cache item result] <span style="color: #bc8f8f;">"Called in case of a cache miss."</span>))

(<span style="color: #da70d6;">declare</span> naive-cache-strategy)

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">mem</span>
  <span style="color: #bc8f8f;">"Returns a memoized version of a referentially transparent function.
  The memoized version of the function keeps a cache of the mapping from
  arguments to results and, when calls with the same arguments are repeated
  often, has higher performance at the expense of higher memory use.
  Optionally takes a cache strategy. Default is the naive safe all strategy."</span>
  ([f] (mem f (naive-cache-strategy)))
  ([f strategy]
   (<span style="color: #a020f0;">let</span> [cache-state (<span style="color: #da70d6;">atom</span> strategy)
         hit-or-miss (<span style="color: #da70d6;">fn</span> [cache item]
                       (<span style="color: #a020f0;">if</span> (cached? cache item)
                         (hit cache item)
                         (miss cache item (<span style="color: #da70d6;">delay</span> (<span style="color: #da70d6;">apply</span> f item)))))]
     (<span style="color: #da70d6;">fn</span> [&amp; args]
       (<span style="color: #a020f0;">let</span> [cs (<span style="color: #da70d6;">swap!</span> cache-state hit-or-miss args)]
         @(retrieve cs args))))))

(<span style="color: #a020f0;">deftype</span> ^{<span style="color: #da70d6;">:private</span> true} <span style="color: #0000ff;">NaiveStrategy</span> [cache]
  PCachingStrategy
  (retrieve
    [_ item]
    (<span style="color: #da70d6;">get</span> cache item))
  (cached?
    [_ item]
    (<span style="color: #da70d6;">contains?</span> cache item))
  (hit
    [this _]
    this)
  (miss
    [_ item result]
    (NaiveStrategy. (<span style="color: #da70d6;">assoc</span> cache item result))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">naive-cache-strategy</span>
  <span style="color: #bc8f8f;">"The naive safe-all cache strategy for memoize."</span>
  []
  (NaiveStrategy. {}))  2



<span style="color: #b22222;">;;;;;;;;;;;;;;;;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;;;;;;;;;;;;;;;;</span><span style="color: #b22222;">
</span>
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defonce-</span>
  <span style="color: #bc8f8f;">"Same as defonce but yields a private definition"</span>
  ([name expr]
     (<span style="color: #da70d6;">list</span> `defonce (<span style="color: #da70d6;">with-meta</span> name (<span style="color: #da70d6;">assoc</span> (<span style="color: #da70d6;">meta</span> name) <span style="color: #da70d6;">:private</span> true)) expr))
  ([name expr doc]
     (<span style="color: #da70d6;">list</span> `defonce (<span style="color: #da70d6;">with-meta</span> name (<span style="color: #da70d6;">assoc</span> (<span style="color: #da70d6;">meta</span> name) <span style="color: #da70d6;">:private</span> true <span style="color: #da70d6;">:doc</span> doc)) expr)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">def-</span>
  <span style="color: #bc8f8f;">"Same as def but yields a private definition"</span>
  [name &amp; decls]
  (<span style="color: #da70d6;">list*</span> `def (<span style="color: #da70d6;">with-meta</span> name (<span style="color: #da70d6;">assoc</span> (<span style="color: #da70d6;">meta</span> name) <span style="color: #da70d6;">:private</span> true)) decls))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defmacro-</span>
  <span style="color: #bc8f8f;">"Same as defmacro but yields a private definition"</span>
  [name &amp; decls]
  (<span style="color: #da70d6;">list*</span> `defmacro (<span style="color: #da70d6;">with-meta</span> name (<span style="color: #da70d6;">assoc</span> (<span style="color: #da70d6;">meta</span> name) <span style="color: #da70d6;">:private</span> true)) decls))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">WARNING: this can screw up protocols implemented on existing object - i.e. replace them, they no longer work! so you have to create new object. how to fix this???...
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reload</span>
  ([] (reload *ns*))
  ([n]
     (<span style="color: #a020f0;">let</span> [name (<span style="color: #a020f0;">cond</span> (<span style="color: #da70d6;">symbol?</span> n) n true (<span style="color: #da70d6;">ns-name</span> n))]
       (<span style="color: #da70d6;">require</span> name <span style="color: #da70d6;">:reload-all</span>))))

(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">*fake*</span> (<span style="color: #da70d6;">gensym</span>))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defrecord+</span> 
  [record-name fields-and-values constructor-name &amp; record-body] 
  (<span style="color: #a020f0;">let</span> [fields-and-values (<span style="color: #da70d6;">map</span> #(<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">vector?</span> %) % [% nil])
                               fields-and-values) 
        fields            (<span style="color: #da70d6;">vec</span> (<span style="color: #da70d6;">map</span> first fields-and-values)) 
        default-map       (<span style="color: #da70d6;">into</span> {} fields-and-values)
        fn-name (<span style="color: #da70d6;">symbol</span> (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> constructor-name (<span style="color: #da70d6;">str</span> constructor-name))
                            (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"new-"</span> (<span style="color: #da70d6;">name</span> record-name))))] 
    `(<span style="color: #a020f0;">do</span> 
       (<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">~record-name</span> 
           ~fields 
         ~@record-body) 
       (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">~fn-name</span>
         ([] (~fn-name ~#'*fake* nil))
         ([&amp; {<span style="color: #da70d6;">:keys</span> ~fields <span style="color: #da70d6;">:or</span> ~default-map}] 
            (new ~record-name ~@fields))))))

(<span style="color: #a020f0;">binding</span> [*out* *out*] (<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">log</span> [e] (.println *out* (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"ERROR!: "</span> e))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: get rid of!
</span>(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">mapc</span> [&amp; args] `(<span style="color: #a020f0;">dorun</span> (<span style="color: #da70d6;">map</span> ~@args)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">thread</span> [&amp; body]
  `(<span style="color: #a020f0;">let</span> [thread# (Thread.
                  (<span style="color: #da70d6;">bound-fn</span> [] (<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> ~@body) (<span style="color: #a020f0;">catch</span> Exception e# (<span style="color: #da70d6;">println</span> <span style="color: #bc8f8f;">"error in thread "</span> e#)))))]
     (.start thread#)
     thread#))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">is</span> [val &amp; message]
  `(<span style="color: #a020f0;">let</span> [result# ~val]
     (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">not</span> result#)
       (<span style="color: #a020f0;">throw</span> (Exception. ~(<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">first</span> message) `(<span style="color: #da70d6;">format</span> ~@message)) (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"assert: %s"</span> (<span style="color: #da70d6;">str</span> val)))))
       result#)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: efficiency: timeout without throwing exception? and definitely a timeout with all that thread hastle!
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">this should be done in a thread pool!
</span>(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">pf</span> [&amp; args]
  `(<span style="color: #da70d6;">print</span> (<span style="color: #da70d6;">format</span> ~@args)))

(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">throwf</span> [message &amp; args]
   (<span style="color: #a020f0;">if</span> args
     `(<span style="color: #a020f0;">throw</span> (Exception. (<span style="color: #da70d6;">format</span> ~message ~@args)))
     `(<span style="color: #a020f0;">throw</span> (Exception. ~message)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">group</span>
  ([coll] (group coll 2))
  ([coll by] (partition-all by coll)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">do1</span> [a &amp; body]
  `(<span style="color: #a020f0;">let</span> [ret# ~a]
     ~@body
     ret#))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">mapc</span> [&amp; args] `(<span style="color: #a020f0;">dorun</span> (<span style="color: #da70d6;">map</span> ~@args)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">sleep</span> [s] (Thread/sleep (<span style="color: #da70d6;">*</span> 1000 s)))


(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">on</span> [[&amp; args] &amp; body]
  (<span style="color: #a020f0;">let</span> [a (group args 2)
        first-args (<span style="color: #da70d6;">map</span> first a)
        second-args (<span style="color: #da70d6;">map</span> second a)]
    `(<span style="color: #a020f0;">doseq</span> [[~@first-args] (<span style="color: #da70d6;">map</span> vector ~@second-args)]
       ~@body)))





(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">if-match</span> m/if-match)
(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">when-match</span> m/when-match)
(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">cond-match</span> m/cond-match)
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">match</span>
  <span style="color: #bc8f8f;">"match item with caluses"</span>
  [item &amp; clauses] 
  (<span style="color: #a020f0;">let</span> [msg-gen (<span style="color: #da70d6;">gensym</span>)]
    `(<span style="color: #a020f0;">let</span> [~msg-gen ~item] 
       (cond-match
        ~@(<span style="color: #da70d6;">mapcat</span> (<span style="color: #da70d6;">fn</span> [[test body]]
                    `[[~test ~msg-gen] ~body]) (group clauses 2))))))
</pre></div>



</div>

</div>

<div id="outline-container-4_2_5" class="outline-4">
<h4 id="sec-4_2_5"><span class="section-number-4">4.2.5</span> Log </h4>
<div class="outline-text-4" id="text-4_2_5">




<div class="org-src-container"><label class="org-src-name">forex-util-log()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.util.log
  (<span style="color: #da70d6;">:clone</span> clj.core)
  (<span style="color: #da70d6;">:import</span> [java.util.logging Logger Level LogManager Handler
            FileHandler SimpleFormatter ConsoleHandler])
  (<span style="color: #da70d6;">:require</span> [clojure.contrib.duck-streams <span style="color: #da70d6;">:as</span> f])
  (<span style="color: #da70d6;">:use</span> forex.util.emacs forex.util.general))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: minor mode
</span>(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">log-dir</span> <span style="color: #bc8f8f;">"%h/.forex"</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">log-file</span>)

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">formatter</span> [] 
  (<span style="color: #a020f0;">let</span> [d (java.util.Date.)]
    (<span style="color: #da70d6;">proxy</span> [java.util.logging.Formatter] []
      (<span style="color: #da70d6;">format</span> [r] 
              (clojure.core/<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s%n%s: %s%n%n"</span>
                                   (<span style="color: #a020f0;">do</span> (.setTime d (.getMillis r)) d)
                                   (.getLevel r)
                                   (.getMessage r))))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">wrap the PrintWriter *out* in an OutputStream to be used in ConsoleHandler
</span>(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">new-out-stream</span> [out]
    (<span style="color: #da70d6;">proxy</span> [java.io.OutputStream] []
      (close [] (.close out))
      (<span style="color: #da70d6;">flush</span> [] (.flush out))
      (write ([b] (.print out (String. b)))
             ([b off len] (.print out (String. b off len)))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-logger</span>
  ([file] (new-logger file true))
  ([file make-file]
     (<span style="color: #a020f0;">when</span> make-file
       (<span style="color: #a020f0;">let</span> [file (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s/.forex/%s"</span> (System/getProperty <span style="color: #bc8f8f;">"user.home"</span>)
                          file)]
         (f/make-parents
          (java.io.File. file))
         (var-root-set #'log-file file)))
     (<span style="color: #a020f0;">let</span> [l (java.util.logging.Logger/getLogger (<span style="color: #da70d6;">str</span> *ns*))]
       (mapc #(.removeHandler l %) (.getHandlers l))
       (.addHandler l (<span style="color: #a020f0;">doto</span> (ConsoleHandler.) (.setFormatter (formatter))))
       (<span style="color: #a020f0;">when</span> make-file
         (.addHandler l (<span style="color: #a020f0;">doto</span> (FileHandler. (<span style="color: #da70d6;">str</span> log-dir <span style="color: #bc8f8f;">"/"</span> file))
                          (.setFormatter (formatter)))))
       (.setUseParentHandlers l false)
       l)))

(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">log</span> (new-logger <span style="color: #bc8f8f;">"forex-log"</span> false))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: set filtering levels
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">fine,finer,finest wont log
</span>
(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">*debug-info*</span> <span style="color: #bc8f8f;">""</span>)
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">debugging</span> [str &amp; args] `(<span style="color: #a020f0;">binding</span> [*debug-info* ~str] ~@args))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">info</span> [msg &amp; args]
  (.info log (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">out</span> [msg &amp; args]
  (<span style="color: #da70d6;">println</span> (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"INFO: "</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args))
  (<span style="color: #da70d6;">apply</span> info msg args)
  nil)

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">fine</span> [msg &amp; args]
   (.fine log (<span style="color: #da70d6;">apply</span> format  (<span style="color: #da70d6;">str</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">finer</span> [msg &amp; args]
   (.finer log (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">finest</span> [msg &amp; args]
  (.finest log (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">severe</span> [msg &amp; args]
  (<span style="color: #a020f0;">let</span> [s (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args)]
    (.severe log s)
    (<span style="color: #da70d6;">print</span> (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"SEVERE: %s%n"</span> s))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">warn</span> [msg &amp; args]
  (<span style="color: #a020f0;">let</span> [s (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> *debug-info* <span style="color: #bc8f8f;">" "</span> msg) args)]
    (.warning log s) 
    (<span style="color: #da70d6;">print</span> (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"WARNING: %s%n"</span> s))))
</pre></div>



</div>

</div>

<div id="outline-container-4_2_6" class="outline-4">
<h4 id="sec-4_2_6"><span class="section-number-4">4.2.6</span> Fiber </h4>
<div class="outline-text-4" id="text-4_2_6">




<div class="org-src-container"><label class="org-src-name">forex-util-fiber-spawn()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">inspired by gambit-c termite's syntax
</span>(<span style="color: #a020f0;">ns</span> forex.util.fiber.spawn
  (<span style="color: #da70d6;">:use</span> forex.util.general)
  (<span style="color: #da70d6;">:require</span> [forex.util.fiber.mbox <span style="color: #da70d6;">:as</span> m]))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: will eventually integrate with zeromq and will be able to be 'reactive' so we avoid
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">java's thread pool limit (or somehow get kilim to work?)
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: also, should we allow functions like ?? to discard messages? Perhaps not?
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: user settable default return value?
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: linking, remote nodes
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">utils
</span>(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*mailboxes*</span> (<span style="color: #da70d6;">atom</span> {}))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">make-mailbox</span> [tag]
  (<span style="color: #a020f0;">let</span> [mb (m/new-mbox)]
    (<span style="color: #da70d6;">swap!</span> *mailboxes* assoc tag mb)
    mb))
(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*threads*</span> (<span style="color: #da70d6;">atom</span> {}))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">remove-pid</span> [pid]
  (<span style="color: #a020f0;">when</span> pid (<span style="color: #da70d6;">swap!</span> *threads* dissoc pid) (<span style="color: #da70d6;">swap!</span> *mailboxes* dissoc pid)))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">get-mailbox</span> [tag]
  (<span style="color: #da70d6;">get</span> @*mailboxes* tag))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">pid?</span> [pid]
  <span style="color: #bc8f8f;">"test for valid pid"</span>
  (<span style="color: #a020f0;">if</span> (get-mailbox pid) true false))

(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*mb*</span> (ThreadLocal.))
(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*self*</span> (ThreadLocal.)) 
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">mb</span> [] (.get *mb*)) 

<span style="color: #b22222;">;; </span><span style="color: #b22222;">functions
</span>(<span style="color: #a020f0;">let</span> [r (java.util.Random.)]
  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">make-tag</span> []
    <span style="color: #bc8f8f;">"produce a random tag/pid"</span>
    (Long/toString (Math/abs (.nextLong r)) 36)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">??</span> []
  (m/?? (mb) nil))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">throwf</span> [&amp; args] (<span style="color: #a020f0;">throw</span> (Exception. (<span style="color: #da70d6;">apply</span> format args))) )

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">!</span>
  <span style="color: #bc8f8f;">"send a message to a pid, with an option id which the message will be placed in"</span>
  ([pid msg] (! pid nil msg))
  ([pid id msg]
     (<span style="color: #a020f0;">if-let</span> [mbox (get-mailbox pid)]
       (m/! mbox id msg)
       (throwf <span style="color: #bc8f8f;">"unknown pid %s"</span> pid))))
(<span style="color: #a020f0;">binding</span> [*out* *out*] (<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">log</span> [&amp; args] (<span style="color: #da70d6;">println</span> (<span style="color: #da70d6;">apply</span> format args))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">self</span> []
  <span style="color: #bc8f8f;">"returns pid of current spawn or nil if it isnt a spawnage"</span>
  (.get *self*))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">spawn</span>
  ([thunk] (spawn thunk nil))
  ([thunk name]
     (<span style="color: #a020f0;">let</span> [tag (make-tag)
           mail (make-mailbox tag)]
       (<span style="color: #a020f0;">let</span> [thread (<span style="color: #a020f0;">let</span> [thread (Thread.
                                  (<span style="color: #da70d6;">bound-fn</span>
                                   [] 
                                   (<span style="color: #a020f0;">try</span> 
                                     (<span style="color: #a020f0;">do</span> (.set *mb* mail) (.set *self* tag)
                                         (thunk))
                                     (<span style="color: #a020f0;">catch</span> Exception e
                                       (log <span style="color: #bc8f8f;">"pid %s error: %s "</span> (self) e)
                                       (.printStackTrace e)
                                       )
                                     (<span style="color: #a020f0;">finally</span> (remove-pid tag)))))]
                      (<span style="color: #a020f0;">if</span> name (<span style="color: #a020f0;">doto</span> thread (.setName name)) thread))]
         (<span style="color: #da70d6;">swap!</span> *threads* assoc tag thread)
         (.start thread))
       tag)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">assert-spawn</span> [] (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">not</span> (self)) (throwf <span style="color: #bc8f8f;">"no local spawn available"</span>)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">does work - but we dont really need it!
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">spawn-in-repl</span> []
  <span style="color: #bc8f8f;">"setup current thread as a spawned thread with mailbox"</span>
  (<span style="color: #a020f0;">let</span> [tag (make-tag)]
    (remove-pid self)
    (.set *mb* (make-mailbox tag)) (.set *self* tag) (<span style="color: #da70d6;">swap!</span> *threads* assoc tag (Thread/currentThread))
    tag)) 

(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">*?*</span> nil)

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">?</span>
  <span style="color: #bc8f8f;">"receive"</span>
  ([] (? nil nil))
  ([timeout] (? timeout nil))
  ([timeout default] 
     (assert-spawn)
     (<span style="color: #a020f0;">or</span> (m/? (mb) nil timeout) default))) 

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">recv-</span> [item &amp; clauses]
  <span style="color: #bc8f8f;">"match item with caluses"</span>
  (<span style="color: #a020f0;">let</span> [msg-gen (<span style="color: #da70d6;">gensym</span>)]
    `(<span style="color: #a020f0;">let</span> [~msg-gen ~item]
       (cond-match ~@(<span style="color: #da70d6;">mapcat</span> (<span style="color: #da70d6;">fn</span> [[test body]]
                               `[[~test ~msg-gen] ~body]) (group clauses 2))))))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">recv</span> [&amp; clauses]
  <span style="color: #bc8f8f;">"receive a message from current spawned thread mailbox"</span>
  `(<span style="color: #a020f0;">let</span> [msg# (?)]
     (recv- msg# ~@clauses)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">recv-if</span> [&amp; clauses]
  <span style="color: #bc8f8f;">"receive only if a message is in queue"</span>
  `(<span style="color: #a020f0;">let</span> [msg# (? 0)]
     (recv- msg# ~@clauses)))

(<span style="color: #da70d6;">comment</span>
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">until we figure out why soft-timeout doesnt work... we're leaving this here!
</span>  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">??</span>
    <span style="color: #bc8f8f;">"asynchronous with timeout: wait for a receive filtered by the function, discarding any other messages received"</span>
    ([function] (?? function nil))
    ([function timeout]
       (soft-timeout! *?* timeout
         (<span style="color: #a020f0;">loop</span> []
           (<span style="color: #a020f0;">let</span> [msg (?)]
             (<span style="color: #a020f0;">if-let</span> [it (function msg)]
               msg
               (<span style="color: #a020f0;">recur</span>))))))))

(<span style="color: #da70d6;">comment</span>
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">until we figure out why soft-timeout doesnt work... we're leaving this here!
</span>  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">!?</span>
    <span style="color: #bc8f8f;">"asynchronous with timeout: send message with a tag and then receive back, discarding any other messages received"</span>
    ([pid data] (!? pid data nil))
    ([pid data timeout]
       (soft-timeout! *?* timeout
         (<span style="color: #a020f0;">let</span> [tag (make-tag)]
           (! pid [(self) tag data])
           (<span style="color: #a020f0;">loop</span> []
             (<span style="color: #a020f0;">let</span> [msg (?)]
               (recv- msg
                 [(<span style="color: #da70d6;">=</span> ? tag) ?response] response
                 ? (<span style="color: #a020f0;">recur</span>)))))))))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">stop-all</span> 
  <span style="color: #bc8f8f;">"stops all threads spawned. probably only useful for debugging, and assuming they respond to stop"</span>
  []
  (<span style="color: #da70d6;">map</span> #(! % <span style="color: #bc8f8f;">"stop"</span>) (<span style="color: #da70d6;">keys</span> @*threads*)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">kill-all</span>
  []
  (<span style="color: #da70d6;">map</span> #(.stop %) (<span style="color: #da70d6;">vals</span> @*threads*)))
</pre></div>






<div class="org-src-container"><label class="org-src-name">forex-util-fiber-mbox()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">modified from
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">https://github.com/jochu/swank-clojure/tree/master/src/swank/util/concurrent/
</span>(<span style="color: #a020f0;">ns</span> forex.util.fiber.mbox
  (<span style="color: #da70d6;">:use</span> forex.util.general))

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Holds references to the mailboxes (message queues)
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">_get</span>
  <span style="color: #bc8f8f;">"Returns the mailbox for a given id. Creates one if one does not
   already exist."</span>
  ([p id]
     (<span style="color: #a020f0;">dosync</span>         
      (<span style="color: #a020f0;">when-not</span> (<span style="color: #da70d6;">get</span> @(<span style="color: #da70d6;">:boxes</span> p) id)  
        (<span style="color: #da70d6;">alter</span> (<span style="color: #da70d6;">:boxes</span> p) assoc
               id (java.util.concurrent.LinkedBlockingQueue.)))
      (@(<span style="color: #da70d6;">:boxes</span> p) id)))
  {<span style="color: #da70d6;">:tag</span> java.util.concurrent.LinkedBlockingQueue})

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">!</span>
  <span style="color: #bc8f8f;">"Sends a message to a given id."</span>
  ([p id message] 
     (<span style="color: #a020f0;">let</span> [mbox (_get p id)]
       (.put mbox message))))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">??</span>
  <span style="color: #bc8f8f;">"poll in milliseconds"</span>
  ([p] (?? p nil))
  ([p id]
     (<span style="color: #a020f0;">let</span> [mb (_get p id)]
       (.peek mb))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">?</span>
  <span style="color: #bc8f8f;">"poll in milliseconds"</span>
  ([p id] (? p id nil))
  ([p id timeout]
     (<span style="color: #228b22;">is</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">not</span> timeout) (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">number?</span> timeout) (<span style="color: #da70d6;">&gt;=</span> timeout 0))) <span style="color: #bc8f8f;">"timeout must be nil or a positive number"</span>)
     (<span style="color: #a020f0;">let</span> [mb (_get p id)]
       (<span style="color: #a020f0;">cond</span>
         (<span style="color: #da70d6;">not</span> timeout) (.take mb)
         true (.poll mb timeout java.util.concurrent.TimeUnit/MILLISECONDS)))))

(defrecord+ mbox [[boxes (<span style="color: #da70d6;">ref</span> {})]]
  new-mbox)
</pre></div>




<div class="org-src-container"><label class="org-src-name">forex-util-emacs()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.util.emacs (<span style="color: #da70d6;">:use</span> forex.util.general))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">fn-meta</span> [function meta]
  (<span style="color: #a020f0;">let</span> [ns-from *ns*]
    (<span style="color: #da70d6;">proxy</span> [clojure.lang.AFn clojure.lang.Fn  clojure.lang.IMeta] []
      (invoke [&amp; args] (<span style="color: #da70d6;">apply</span> function args))
      (<span style="color: #da70d6;">meta</span> [] (<span style="color: #da70d6;">merge</span> (<span style="color: #da70d6;">meta</span> function) (<span style="color: #da70d6;">merge</span> {<span style="color: #da70d6;">:ns</span> ns-from} meta))))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">val-of</span> [a] (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">var?</span> a) (<span style="color: #da70d6;">var-get</span> a) a)) 
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: add log to this
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">apply-fn</span> [a args]
  (<span style="color: #a020f0;">try</span> (<span style="color: #da70d6;">apply</span> (val-of a) args)
       (<span style="color: #a020f0;">catch</span> Exception e
         (<span style="color: #da70d6;">println</span> (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"error in hook %s %s: %s"</span> a (val-of a) e)))))
(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">run-fn</span> [a &amp; args]
  `(<span style="color: #a020f0;">let</span> [a# ~a]
     (<span style="color: #a020f0;">try</span> ((val-of a#) ~@args)
          (<span style="color: #a020f0;">catch</span> Exception e# (<span style="color: #da70d6;">println</span> 
                               (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"error in hook %s %s: %s"</span> a# (val-of a#) e#))))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">as-ns</span> [a]
  (<span style="color: #a020f0;">condp</span> = (<span style="color: #da70d6;">class</span> a)
      String (<span style="color: #da70d6;">find-ns</span> (<span style="color: #da70d6;">symbol</span> a))
      clojure.lang.Symbol (<span style="color: #da70d6;">find-ns</span> a)
      a))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ns-metas</span>
  ([fn] (ns-metas *ns* fn))
  ([ns fn]
     (<span style="color: #228b22;">is</span> (as-ns ns) <span style="color: #bc8f8f;">"%s is not a ns, or cant find it"</span> ns)
     (<span style="color: #a020f0;">let</span> [vars (<span style="color: #da70d6;">filter</span> fn (<span style="color: #da70d6;">vals</span> (<span style="color: #da70d6;">ns-interns</span> (as-ns ns))))]
       (<span style="color: #da70d6;">apply</span> hash-map (<span style="color: #da70d6;">interleave</span> vars (<span style="color: #da70d6;">map</span> var-get vars))))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ns-vars</span>
  ([] (ns-vars *ns*))
  ([ns]
     (<span style="color: #228b22;">is</span> (as-ns ns) <span style="color: #bc8f8f;">"%s is not an ns, or cant find it"</span> ns)
     (<span style="color: #a020f0;">let</span> [vars (<span style="color: #da70d6;">filter</span> #(<span style="color: #da70d6;">:var</span> (<span style="color: #da70d6;">meta</span>  %)) (<span style="color: #da70d6;">vals</span> (<span style="color: #da70d6;">ns-interns</span> (as-ns ns))))]
       (<span style="color: #da70d6;">apply</span> hash-map (<span style="color: #da70d6;">interleave</span> vars (<span style="color: #da70d6;">map</span> var-get vars))))))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defvar</span>
  ([name]
     (<span style="color: #a020f0;">let</span> [new-name (<span style="color: #da70d6;">with-meta</span> name (<span style="color: #da70d6;">assoc</span> (<span style="color: #da70d6;">meta</span> name) <span style="color: #da70d6;">:var</span> true))]
       `(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">~new-name</span> nil)))
  ([name init]
     (<span style="color: #a020f0;">let</span> [new-name (<span style="color: #da70d6;">with-meta</span> name (<span style="color: #da70d6;">assoc</span> (<span style="color: #da70d6;">meta</span> name) <span style="color: #da70d6;">:var</span> true))]
       `(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">~new-name</span> ~init))))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">defhook</span> [&amp; args] `(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">~@args</span>)) 
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">setq</span> [&amp; args]
  `(<span style="color: #a020f0;">do</span> ~@(<span style="color: #da70d6;">map</span>
          (<span style="color: #da70d6;">fn</span> [[var val]]
            `(<span style="color: #da70d6;">alter-var-root</span> #'~var (<span style="color: #da70d6;">fn</span> [a#] ~val)))
          (group args))))


(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">member</span>
  ([value list] (member value list =))
  ([value list test]
     (<span style="color: #da70d6;">some</span> #(<span style="color: #da70d6;">test</span> % value) list)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">pushnew*</span> [hook arg id replace] 
  (<span style="color: #a020f0;">if</span> replace 
    (<span style="color: #da70d6;">alter-var-root</span> hook (<span style="color: #da70d6;">fn</span> [old]
                           (<span style="color: #a020f0;">doall</span> (<span style="color: #da70d6;">concat</span>
                                   (<span style="color: #da70d6;">list</span> arg)
                                   (<span style="color: #da70d6;">filter</span> #(<span style="color: #a020f0;">and</span> (<span style="color: #a020f0;">if</span> id (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:id</span> (<span style="color: #da70d6;">meta</span> %)) id)) true)
                                                (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> % arg))) old)))))
    (<span style="color: #da70d6;">alter-var-root</span> hook (<span style="color: #da70d6;">fn</span> [old] 
                           (<span style="color: #a020f0;">doall</span> (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> (<span style="color: #da70d6;">take</span> 1 (<span style="color: #da70d6;">filter</span> #(<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">when</span> id (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:id</span> (<span style="color: #da70d6;">meta</span> %)) id)) (<span style="color: #da70d6;">=</span> % arg)) old)))
                                    (<span style="color: #da70d6;">concat</span> (<span style="color: #da70d6;">list</span> arg) old)
                                    old))))))
(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">pushnew</span> (<span style="color: #da70d6;">fn</span> [a b &amp; args] [(<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> a) <span style="color: #da70d6;">::fn</span> (<span style="color: #da70d6;">type</span> a)) (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> b) <span style="color: #da70d6;">::fn</span> (<span style="color: #da70d6;">type</span> b))]))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pushnew</span> [clojure.lang.Var <span style="color: #da70d6;">::fn</span>]
  ([hook function] (pushnew hook function *ns* true))
  ([hook function id] (pushnew hook function id true))
  ([hook function id replace] 
     (<span style="color: #a020f0;">let</span> [new-function (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">:id</span> (<span style="color: #da70d6;">meta</span> function)) function (<span style="color: #a020f0;">if</span> id (fn-meta function {<span style="color: #da70d6;">:id</span> id}) function))]
       (pushnew* hook new-function id replace))))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">pushnew</span> [clojure.lang.Var clojure.lang.Var]
  ([hook var] (pushnew hook var nil false))
  ([hook var id] (pushnew hook var id false)) 
  ([hook var id replace] (pushnew* hook var id replace)))


(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">add-to-list*</span> [hook arg id replace] 
  (<span style="color: #a020f0;">if</span> replace 
    (<span style="color: #da70d6;">alter-var-root</span> hook (<span style="color: #da70d6;">fn</span> [old]
                           (<span style="color: #a020f0;">doall</span> (<span style="color: #da70d6;">concat</span>
                                   (<span style="color: #da70d6;">filter</span> #(<span style="color: #a020f0;">and</span> (<span style="color: #a020f0;">if</span> id (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:id</span> (<span style="color: #da70d6;">meta</span> %)) id)) true)
                                                (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> % arg))) old)
                                   (<span style="color: #da70d6;">list</span> arg)))))
    (<span style="color: #da70d6;">alter-var-root</span> hook (<span style="color: #da70d6;">fn</span> [old]
                           (<span style="color: #a020f0;">doall</span> (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> (<span style="color: #da70d6;">take</span> 1 (<span style="color: #da70d6;">filter</span> #(<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">when</span> id (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:id</span> (<span style="color: #da70d6;">meta</span> %)) id)) (<span style="color: #da70d6;">=</span> % arg)) old)))
                                    (<span style="color: #da70d6;">concat</span> old (<span style="color: #da70d6;">list</span> arg))
                                    old))))))
(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">add-to-list</span> (<span style="color: #da70d6;">fn</span> [a b &amp; args] [(<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> a) <span style="color: #da70d6;">::fn</span> (<span style="color: #da70d6;">type</span> a)) (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> b) <span style="color: #da70d6;">::fn</span> (<span style="color: #da70d6;">type</span> b))]))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-to-list</span> [clojure.lang.Var <span style="color: #da70d6;">::fn</span>]
  ([hook function] (add-to-list hook function *ns* true))
  ([hook function id] (add-to-list hook function id true))
  ([hook function id replace] 
     (<span style="color: #a020f0;">let</span> [new-function (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">:id</span> (<span style="color: #da70d6;">meta</span> function)) function (<span style="color: #a020f0;">if</span> id (fn-meta function {<span style="color: #da70d6;">:id</span> id}) function))]
       (add-to-list* hook new-function id replace))))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">add-to-list</span> [clojure.lang.Var clojure.lang.Var]
  ([hook var] (add-to-list hook var nil false))
  ([hook var id] (add-to-list hook var id false)) 
  ([hook var id replace] (add-to-list* hook var id replace)))

(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">push</span> [var val]
    (<span style="color: #da70d6;">alter-var-root</span> var (<span style="color: #da70d6;">fn</span> [it] (<span style="color: #da70d6;">concat</span> (<span style="color: #da70d6;">list</span> val) it))))) 

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-hook</span> [hook function] (pushnew hook function))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-hooks</span> [hook functions] (<span style="color: #a020f0;">doall</span> (<span style="color: #da70d6;">map</span> #(pushnew hook %) functions)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">RUNNING hooks
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-hooks</span> [&amp; hooks]
  (mapc (<span style="color: #da70d6;">fn</span> [hook] (mapc #(run-fn %) hook)) hooks))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-hook-with-args</span> [hook &amp; args]
  (mapc #(apply-fn % args) hook))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-hook-with-args-until-success</span> [hook &amp; args]
  (<span style="color: #228b22;">is</span> (sequence? hook) <span style="color: #bc8f8f;">"hook %s isnt a list"</span> hook)
  (<span style="color: #a020f0;">loop</span> [funcs hook]
    (<span style="color: #a020f0;">cond</span>
      (<span style="color: #da70d6;">empty?</span> funcs) nil
      true (<span style="color: #a020f0;">if-let</span> [it (apply-fn (<span style="color: #da70d6;">first</span> funcs) args)]
             it
             (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> funcs)))))) 

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-hook-with-args-until-failure</span> [hook &amp; args]
  (<span style="color: #228b22;">is</span> (sequence? hook) <span style="color: #bc8f8f;">"hook %s isnt a list"</span> hook)
  (<span style="color: #a020f0;">loop</span> [funcs hook]
    (<span style="color: #a020f0;">cond</span>
      (<span style="color: #da70d6;">empty?</span> funcs) true
      true (<span style="color: #a020f0;">when</span> (apply-fn (<span style="color: #da70d6;">first</span> funcs) args)
             (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> funcs))))))


<span style="color: #b22222;">;;</span><span style="color: #b22222;">(run-hook-with-args-until-success 'a 3)
</span></pre></div>


</div>

</div>

<div id="outline-container-4_2_7" class="outline-4">
<h4 id="sec-4_2_7"><span class="section-number-4">4.2.7</span> Spawn </h4>
<div class="outline-text-4" id="text-4_2_7">




<div class="org-src-container"><label class="org-src-name">forex-util-spawn()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.util.spawn
     (<span style="color: #da70d6;">:clone</span> clj.core)   
     (<span style="color: #da70d6;">:use</span> forex.util.general forex.util.zmq)
     (<span style="color: #da70d6;">:import</span> forex.util.zmq.Poller)
     (<span style="color: #da70d6;">:require</span> [forex.util.fiber.spawn <span style="color: #da70d6;">:as</span> s]))

(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">*pid*</span> (<span style="color: #da70d6;">atom</span> []))

(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">pid?</span> s/pid?)
(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">self</span> s/self)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">kill-all</span> s/kill-all)
(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">spawn-in-repl</span> s/spawn-in-repl) <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: add socket for this one
</span>
(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">?</span> s/?)

(<span style="color: #a020f0;">defalias</span> <span style="color: #0000ff;">make-tag</span> s/make-tag)
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">!</span> [pid msg]
  (<span style="color: #a020f0;">with-open</span> [local (<span style="color: #a020f0;">doto</span> (new-socket +push+)
                      (.connect (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"inproc://%s"</span> pid)))] 
    (s/! pid msg)
    (.snd local <span style="color: #bc8f8f;">"REQUEST"</span> +noblock+)))
(<span style="color: #a020f0;">defn</span>  <span style="color: #0000ff;">stop-all</span> []
  (<span style="color: #da70d6;">swap!</span> *pid*
         (<span style="color: #da70d6;">fn</span> [old]
           (<span style="color: #da70d6;">map</span> #(<span style="color: #a020f0;">if</span> (pid? %)
                   (! % <span style="color: #bc8f8f;">"STOP"</span>)) @*pid*))))


(<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">LocalSocket</span> [socket]
  PSocket
  (raw [this] (.raw socket)) 
  (recv [this flags] 
        (<span style="color: #a020f0;">when</span> (.recv socket flags)      
          (s/?)))  
  (recv [this] (recv this 0))
  (close [this] (.close socket))
  (hasMore [this] false))


(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*local*</span> (ThreadLocal.))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">self-get</span> [key]
  (<span style="color: #a020f0;">let</span> [map (.get *local*)]
    (<span style="color: #a020f0;">when</span> map 
      (<span style="color: #da70d6;">map</span> key))))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">self-assoc</span> [key obj]
  (<span style="color: #a020f0;">let</span> [map (.get *local*)]
    (<span style="color: #a020f0;">if</span> map 
     (.set *local* (<span style="color: #da70d6;">assoc</span> map key obj)))))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">local</span> nil)
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">spawn</span>
  ([thunk] (spawn thunk nil))
  ([thunk name] 
     (<span style="color: #a020f0;">let</span> [pid (s/spawn
                (<span style="color: #da70d6;">fn</span> [] 
                  (.set *local* {})
                  (<span style="color: #a020f0;">with-open</span>
                      [local-socket (LocalSocket. 
                                     (<span style="color: #a020f0;">doto</span>
                                         (new-string-socket +pull+)
                                       (.bind  (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"inproc://"</span> (self)))))]        
                    (<span style="color: #a020f0;">binding</span> [local local-socket]
                      (thunk))))
                name)]
       (<span style="color: #da70d6;">swap!</span> *pid* concat [pid])
       pid)))

(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">te</span> []
    (<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">pid</span> (spawn #(<span style="color: #a020f0;">let</span> [seq (event-seq [local])]
                       (<span style="color: #da70d6;">pr</span> (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"local %s %s%n"</span>
                                   (<span style="color: #da70d6;">first</span> seq)
                                   (<span style="color: #da70d6;">second</span> seq))))))))




(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">recv-multi</span>
  ([sock] (recv-multi sock 0))
  ([sock flags] 
     (<span style="color: #a020f0;">let</span> [first-msg (.recv sock flags)]
       (<span style="color: #a020f0;">when</span> first-msg 
         (<span style="color: #a020f0;">if</span> (.hasMore sock)
           (<span style="color: #a020f0;">loop</span> [msg [(String. (.recv sock)) first-msg]]
             (<span style="color: #a020f0;">if</span> (.hasMore sock)
               (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">cons</span> (String. (.recv sock)) msg))
               msg))
           first-msg)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">recv-all</span>
  ([sock] (recv-all sock 0))
  ([sock flags]
     (<span style="color: #a020f0;">let</span> [first-msg (recv-multi sock flags)]
       (<span style="color: #a020f0;">when</span> first-msg
         (<span style="color: #a020f0;">loop</span> [messages [[sock first-msg]]]
           (<span style="color: #a020f0;">if-let</span> [new-msg (recv-multi sock +noblock+)]
             (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">conj</span> messages [sock new-msg]))
             messages))))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: fair queue? prevent too much messages hogging sequence? who knows! ...
</span>
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">event-seq*</span> [p]
  (<span style="color: #da70d6;">lazy-seq</span>
   (<span style="color: #a020f0;">let</span> [amount (.poll p)]
     (<span style="color: #da70d6;">concat</span>
      <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: memory overflow with getting all messsages? probably not ....
</span>      (<span style="color: #a020f0;">doall</span>
       (<span style="color: #da70d6;">mapcat</span> #(<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">or</span> (.pollin p %) (.pollout p %)) (recv-all (.getSocket p %))) 
               (<span style="color: #da70d6;">range</span> 0 (.getSize p))))
      (event-seq* p))))) 


(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">event-seq</span> class)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">event-seq</span> clojure.lang.IPersistentVector [v]
  (event-seq (new-poller v)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">event-seq</span> Poller [p] (event-seq* p)) 

<span style="color: #b22222;">;;</span><span style="color: #b22222;">? with multiple sources or change to poll
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">!? (timeout)
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">?? (filter)
</span></pre></div>


</div>

</div>

<div id="outline-container-4_2_8" class="outline-4">
<h4 id="sec-4_2_8"><span class="section-number-4">4.2.8</span> ZMQ </h4>
<div class="outline-text-4" id="text-4_2_8">




<div class="org-src-container"><label class="org-src-name">forex-util-zmq()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.util.zmq
  (<span style="color: #da70d6;">:clone</span> clj.core)
  (<span style="color: #da70d6;">:import</span> (org.zeromq ZMQ))
  (<span style="color: #da70d6;">:use</span> forex.util.general))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+noblock+</span> 1)

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+p2p+</span> 0)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+pub+</span> 1)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+sub+</span> 2)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+req+</span> 3)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+rep+</span> 4)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+xreq+</span> 5)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+xrep+</span> 6)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+pull+</span> 7) 
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+push+</span> 8)

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+hwm+</span> 1)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+lwm+</span> 2)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+swap+</span> 3)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+affinity+</span> 4)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+identity+</span> 5)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+subscribe+</span> 6)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+unsubscribe+</span> 7)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+rate+</span> 8)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+recovery-ivl+</span> 9)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+mcast-loop+</span> 10)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+sndbuf+</span> 11)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+rcvbuf+</span> 12)

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+pollin+</span> 1)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+pollout+</span> 2)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+pollerr+</span> 4)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+more+</span> 2)

<span style="color: #b22222;">;;</span><span style="color: #b22222;">Context
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-context</span> [io-threads]
  (ZMQ/context io-threads))
(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*context*</span> (new-context 1))

(<span style="color: #a020f0;">defprotocol</span> <span style="color: #0000ff;">PSocket</span>
  (raw [this])
  (recv [this flags] [this])
  (bind [this address])
  (connect [this address])
  (hasMore [this])
  (close [this])
  (snd [this msg] [this msg flags])) 
(<span style="color: #a020f0;">defprotocol</span> <span style="color: #0000ff;">PPoller</span>
  (setTimeout [this timeout])
  (poll [this])
  (register [this socket])
  (getSocket [this i])
  (getSize [this])
  (pollin [this i])
  (pollout [this i])) 
(<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">Poller</span> [poll sockets] 
  PPoller 
  (getSize [_] (.getSize poll))
  (pollin [_ i] (.pollin poll i))
  (pollout [_ i] (.pollout poll i))
  (setTimeout [_ timeout] (.setTimeout poll timeout))
  (poll [_] (.poll poll))
  (register [_ socket]
            (.register poll
                       <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: what if we reload? wont work?
</span>                       (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">extends?</span> PSocket (<span style="color: #da70d6;">class</span> socket))
                         (.raw socket)
                         socket))
            (<span style="color: #da70d6;">swap!</span> sockets conj socket))
  (getSocket [_ i] (<span style="color: #da70d6;">nth</span> @sockets i)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-poller</span>
  ([sockets] (new-poller *context* sockets))
  ([context sockets]
     (<span style="color: #a020f0;">let</span> [p (Poller. (.poller context (<span style="color: #da70d6;">count</span> sockets)) (<span style="color: #da70d6;">atom</span> []))]
       (.setTimeout p -1)
       (on [sock sockets]
           (.register p sock))
       p)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: now just a string socket!
</span>(<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">StringSocket</span> [socket]
  PSocket 
  (raw [this] socket)
  (snd [this msg] (.snd this msg 0))
  (snd [this msg flags]
       (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> msg)
         (.send socket (.getBytes msg) flags)
         (.send socket msg flags))) 
  (recv [this flags] (<span style="color: #a020f0;">when-let</span> [it (.recv socket flags)] (String. it)))
  (recv [this] (recv this 0)) 
  (close [this] (.close socket))
  (bind [this address] (.bind socket address))
  (connect [this address] (.connect socket address))
  (hasMore [this] (.hasReceiveMore socket))) 
(<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">Socket</span> [socket]
  PSocket 
  (raw [this] socket)
  (snd [this msg] (.snd this msg 0))
  (snd [this msg flags]
       (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> msg)
         (.send socket (.getBytes msg) flags)
         (.send socket msg flags))) 
  (recv [this flags]  (.recv socket flags))
  (recv [this] (recv this 0)) 
  (close [this] (.close socket))
  (bind [this address] (.bind socket address))
  (connect [this address] (.connect socket address))
  (hasMore [this] (.hasReceiveMore socket)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-socket</span>
  ([type] (new-socket *context* type))
  ([context type] (Socket. (.socket context type))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-string-socket</span>
  ([type] (new-socket *context* type))
  ([context type] (StringSocket. (.socket context type))))

(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-poll</span>
    ([sockets] (new-poll *context* sockets))
    ([context sockets]
       (<span style="color: #a020f0;">let</span> [p (.poller context (<span style="color: #da70d6;">count</span> sockets))]
         (.setTimeout p -1)
         (on [sock sockets]
             (.register p (.socket sock)))
         p)))

  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-socket</span>
    ([socket-type]
       (new-socket *context* socket-type))
    ([context socket-type ]
       (.socket context socket-type))))
</pre></div>


</div>

</div>

<div id="outline-container-4_2_9" class="outline-4">
<h4 id="sec-4_2_9"><span class="section-number-4">4.2.9</span> GUI </h4>
<div class="outline-text-4" id="text-4_2_9">




<div class="org-src-container"><label class="org-src-name">forex-util-gui()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.util.gui
  (<span style="color: #da70d6;">:require</span> swank.swank)
  (<span style="color: #da70d6;">:use</span> forex.util.general clojure.contrib.miglayout forex.util.emacs forex.util.log)
  (<span style="color: #da70d6;">:import</span> 
   (java.awt Dimension Font event.MouseListener
             event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
   (javax.swing JComboBox JPopupMenu JMenuItem
                ImageIcon
                table.AbstractTableModel
                JScrollPane JTable
                JFrame JPanel JTextField JLabel JButton
                SwingUtilities)))

(<span style="color: #a020f0;">import</span> javax.swing.JOptionPane)

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-watcher</span> [var key f]
  (add-watch
   var key
   (<span style="color: #da70d6;">bound-fn</span> [&amp; args]
             (<span style="color: #a020f0;">try</span> (<span style="color: #da70d6;">apply</span> f args)
                  (<span style="color: #a020f0;">catch</span> Exception e

                    (severe <span style="color: #bc8f8f;">"caught exception in watcher %s: %s"</span>
                            [var key] e)
                    (.printStackTrace e))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">inform</span> [msg &amp; args]
  (JOptionPane/showMessageDialog
   nil (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> msg) args) <span style="color: #bc8f8f;">"!"</span> JOptionPane/INFORMATION_MESSAGE)) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">prompt</span>
  ([msg &amp; args]     
     (<span style="color: #a020f0;">let</span> [no-default true
           p (<span style="color: #a020f0;">if</span> no-default 
               (JOptionPane/showOptionDialog (JPanel.)
                                             (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> msg) args) <span style="color: #bc8f8f;">"???"</span>
                                             JOptionPane/YES_NO_OPTION
                                             JOptionPane/QUESTION_MESSAGE
                                             nil
                                             (<span style="color: #da70d6;">into-array</span>  [<span style="color: #bc8f8f;">"Yes"</span> <span style="color: #bc8f8f;">"No"</span>])
                                             <span style="color: #bc8f8f;">"No"</span>)
               (JOptionPane/showConfirmDialog
                nil (<span style="color: #da70d6;">apply</span> format (<span style="color: #da70d6;">str</span> msg) args)
                <span style="color: #bc8f8f;">"???"</span> JOptionPane/YES_NO_OPTION))]
       (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> JOptionPane/YES_OPTION p)
         true
         false))))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">create-image</span> [path]
  (.getImage (Toolkit/getDefaultToolkit) path))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">create-icon</span> [path]
  (<span style="color: #a020f0;">try</span>
    (ImageIcon. (create-image path))
    (<span style="color: #a020f0;">catch</span> Exception e
      (warn <span style="color: #bc8f8f;">"couldnt create image %s"</span> path)
      nil)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">get-fn</span> [a] (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">var?</span> a) (<span style="color: #da70d6;">var-get</span> a) a))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">call-fn</span> [a &amp; args]
  (thread
   (<span style="color: #a020f0;">let</span> [f (get-fn a)]
     (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> f) 
       (<span style="color: #da70d6;">apply</span> f args)
       (warn <span style="color: #bc8f8f;">"in listener, in var %s,val %s is not a function"</span> a f)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-key-listener</span> [obj f]
  (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">fn?</span> (get-fn f))
    (.addKeyListener obj (<span style="color: #da70d6;">proxy</span> [KeyListener] []
                           (keyReleased [e] (call-fn f e))
                           (keyPressed [e])
                           (keyTyped [e])))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-action-listener</span> [item val]
  (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">var?</span> val) (<span style="color: #da70d6;">fn?</span> (<span style="color: #da70d6;">var-get</span> val))) (<span style="color: #da70d6;">fn?</span> val))
    (<span style="color: #a020f0;">let</span> [f (<span style="color: #da70d6;">bound-fn</span> [e] (call-fn val e))]
      (.addActionListener item
                          (<span style="color: #da70d6;">proxy</span> [ActionListener] nil 
                            (actionPerformed [e]
                                             (<span style="color: #a020f0;">try</span>
                                               (f e)
                                               (<span style="color: #a020f0;">catch</span> Exception e
                                                 (severe <span style="color: #bc8f8f;">"error in action listener %s"</span> e)))))))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-popup-listener</span> [obj f]
  (<span style="color: #a020f0;">when</span>  (<span style="color: #da70d6;">fn?</span> (get-fn f))
    (<span style="color: #a020f0;">let</span> [f (<span style="color: #da70d6;">bound-fn</span> [e] (call-fn f e))]
     (.addMouseListener
      obj
      (<span style="color: #da70d6;">proxy</span> [MouseAdapter] nil
        (mousePressed [e] (<span style="color: #a020f0;">when</span> (.isPopupTrigger e) (f e)))
        (mouseReleased [e] (<span style="color: #a020f0;">when</span> (.isPopupTrigger e) (f e)))))))
  obj)
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO; println stack trace
</span>(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">invoke-later</span> [&amp; args]
  `(SwingUtilities/invokeLater (<span style="color: #da70d6;">bound-fn</span> []
                                         (<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> ~@args)

                                              (<span style="color: #a020f0;">catch</span> Exception e#
                                                (.printStackTrace e#)
                                                (<span style="color: #da70d6;">println</span> e#))))))
</pre></div>



</div>

</div>

<div id="outline-container-4_2_10" class="outline-4">
<h4 id="sec-4_2_10"><span class="section-number-4">4.2.10</span> Devel </h4>
<div class="outline-text-4" id="text-4_2_10">




<div class="org-src-container"><label class="org-src-name">forex-util-mql-devel()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.util.mql-devel
     (<span style="color: #da70d6;">:clone</span> clj.core)
     (<span style="color: #da70d6;">:use</span> forex.util.general))


(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">cond-out</span> [&amp; args]
  (<span style="color: #da70d6;">apply</span> str (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [a]
                    (<span style="color: #a020f0;">let</span> [name (<span style="color: #da70d6;">str</span> a)]
                      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">" else if (command==\"%s\") {\n\t   ret = process_%s(request);\n\t}"</span> name name)))
                  args)))

(cond-out
 AccountBalance
 AccountCredit
 AccountCompany
 AccountCurrency
 AccountEquity
 AccountFreeMargin
 AccountLeverage
 AccountMargin
 AccountName
 AccountNumber
 AccountServer
 AccountProfit
 OrderLots
 OrderDelete
 OrderCloseTime
 OrderType
 OrdersTotal
 OrderSend
 MarketInfo
 OrderClose
 OrderModify)
</pre></div>




<div class="org-src-container"><label class="org-src-name">forex-util-indicator-devel()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
<span style="color: #b22222;">;;</span><span style="color: #b22222;">this file allows one to automatically produce binding code for metatrader custom indicators
</span>(ns+ forex.util.mql-indicator-devel
  (<span style="color: #da70d6;">:clone</span> clj.core)
  (<span style="color: #da70d6;">:import</span> java.io.File))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">for+</span> [args &amp; body]
  (<span style="color: #a020f0;">let</span> [a (partition-all 2 args)]
    `(<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> <span style="color: #0000ff;">~</span>(<span style="color: #da70d6;">vec</span> (<span style="color: #da70d6;">map</span> first a)) ~@body) ~@(<span style="color: #da70d6;">map</span> second a))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">throwf</span> [msg &amp; args]
  (<span style="color: #a020f0;">throw</span> (Exception. (<span style="color: #da70d6;">apply</span> format msg args))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">args</span> [s]
  (<span style="color: #da70d6;">map</span> rest (<span style="color: #da70d6;">re-seq</span> #<span style="color: #bc8f8f;">"extern\s+(\w+)\s+(\w+)"</span> s)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">buffers</span> [s]
  (<span style="color: #da70d6;">count</span> (<span style="color: #da70d6;">re-seq</span> #<span style="color: #bc8f8f;">"SetIndexBuffer"</span> s)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">extract</span> [args]
  (<span style="color: #a020f0;">let</span> [type-to-fn (<span style="color: #da70d6;">fn</span> [type]
                     (<span style="color: #a020f0;">condp</span> = type
                         <span style="color: #bc8f8f;">"int"</span> <span style="color: #bc8f8f;">"StrToInteger"</span>
                         <span style="color: #bc8f8f;">"double"</span> <span style="color: #bc8f8f;">"StrToDouble"</span>
                         <span style="color: #bc8f8f;">"string"</span> nil
                         <span style="color: #bc8f8f;">"color"</span> <span style="color: #bc8f8f;">"StrToInteger"</span>
                         <span style="color: #bc8f8f;">"bool"</span> <span style="color: #bc8f8f;">"StrToInteger"</span>
                         (throwf <span style="color: #bc8f8f;">"unknown type %s"</span> type)))
        user-extract (<span style="color: #da70d6;">apply</span> str
                            (<span style="color: #da70d6;">interpose</span> <span style="color: #bc8f8f;">"\n"</span>
                                       (for+ [[type name] args index (<span style="color: #da70d6;">iterate</span> inc 6)]
                                             (<span style="color: #a020f0;">let</span> [type-fn (type-to-fn type)]
                                               (<span style="color: #a020f0;">if</span> type-fn
                                                 (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s %s = %s(command[%s]);"</span> type name type-fn index)
                                                 (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s %s = command[%s];"</span> type name index))))))
        always (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"
string symbol = command[2];
int timeframe = StrToInteger(command[3]);
int mode = StrToInteger(command[4]);
int shift = StrToInteger(command[5]);"</span>)]
    (<span style="color: #da70d6;">str</span> always <span style="color: #bc8f8f;">"\n"</span> user-extract)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">extension</span> [f] (<span style="color: #a020f0;">let</span> [e (<span style="color: #da70d6;">second</span> (.split (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">instance?</span> File f) (.getName f) f) <span style="color: #bc8f8f;">"\\."</span>))] (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> e) (.trim e))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">to-test</span> [all]
  (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%nstring process_INDICATORS(string commands[]) {%nstring ret = \"\";string command=commands[1];%n%s%nreturn(ret);}"</span>
          (<span style="color: #da70d6;">apply</span> str
                 <span style="color: #bc8f8f;">"if (command==\"0\") {\n}\n"</span>
                 (<span style="color: #da70d6;">map</span> #(<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"else if (command==\"%s\") {%nprotocol_found=true;%nret = %s(commands);%n}%n"</span> (<span style="color: #da70d6;">:function-name</span> %) (<span style="color: #da70d6;">:function-name</span> %)) all))))


(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">listify</span> [s] (<span style="color: #a020f0;">if-not</span> (<span style="color: #da70d6;">empty?</span> s) (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">apply</span> str (<span style="color: #da70d6;">interpose</span> <span style="color: #bc8f8f;">","</span> s)) <span style="color: #bc8f8f;">","</span>) <span style="color: #bc8f8f;">""</span> ))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">name-of</span> [f] (<span style="color: #da70d6;">first</span> (.split (.getName f) <span style="color: #bc8f8f;">"\\."</span>)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">iCustom</span>
  <span style="color: #bc8f8f;">"given a file, generate mql4 binding code to the indicator in the flie"</span>
  [f]
  (<span style="color: #a020f0;">let</span> [name (.replaceAll (<span style="color: #da70d6;">first</span> (.split (.getName f) <span style="color: #bc8f8f;">"\\."</span>)) <span style="color: #bc8f8f;">"( |-)+"</span> <span style="color: #bc8f8f;">"_"</span>)
        s (<span style="color: #da70d6;">slurp</span> f)
        args (<span style="color: #da70d6;">map</span> #(<span style="color: #da70d6;">list</span> (<span style="color: #da70d6;">first</span> %) (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"i_%s"</span> (<span style="color: #da70d6;">second</span> %))) (args s))
        buffers (buffers s)]
    (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">and</span> s args buffers)
      (<span style="color: #a020f0;">let</span> [custom (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"double val = iCustom(symbol,timeframe,\"%s\",%smode,shift);"</span> <span style="color: #b22222;">;</span><span style="color: #b22222;">
</span>                                             (name-of f) (listify (<span style="color: #da70d6;">map</span> second args))) 
            extract (extract args)

            return (<span style="color: #da70d6;">format</span>
                    <span style="color: #bc8f8f;">"
int err = GetLastError();
if(err!=0)
  return(\"error \" + err);
return(val); 
}"</span>)
            function-name (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Custom_%s"</span> name)
            function-header (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"string %s (string command[]) {"</span> function-name)] 
        {<span style="color: #da70d6;">:file</span> f <span style="color: #da70d6;">:file-name</span> name <span style="color: #da70d6;">:function-name</span> function-name <span style="color: #da70d6;">:args</span> args <span style="color: #da70d6;">:buffers</span> buffers
         <span style="color: #da70d6;">:code</span>  (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s %s %s %s"</span> function-header extract custom return)}))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">iCustom-all</span> [dir out]
  (<span style="color: #a020f0;">let</span> [files (.listFiles (File. dir))
        customs (<span style="color: #a020f0;">for</span> [f files <span style="color: #da70d6;">:when</span> (<span style="color: #da70d6;">=</span> (extension f) <span style="color: #bc8f8f;">"mq4"</span>)] (iCustom f))]
    (spit out (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"bool protocol_found = false;%n%s\n%s"</span> (<span style="color: #da70d6;">apply</span> str (<span style="color: #da70d6;">interpose</span> <span style="color: #bc8f8f;">"\n\n"</span> (<span style="color: #da70d6;">map</span> <span style="color: #da70d6;">:code</span> customs)))
                      (to-test customs)))))


<span style="color: #b22222;">;;</span><span style="color: #b22222;">example usage - first param is custom indicator folder, second is output file
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">do-it</span> []
  (iCustom-all
   <span style="color: #bc8f8f;">"/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/indicators/"</span>
   <span style="color: #bc8f8f;">"/home/seth/.wine/dosdevices/c:/Program Files/FXCM MT4 powered by BT/experts/include/INDICATORS.mqh"</span>))
</pre></div>



</div>
</div>

</div>

<div id="outline-container-4_3" class="outline-3">
<h3 id="sec-4_3"><span class="section-number-3">4.3</span> Backend </h3>
<div class="outline-text-3" id="text-4_3">


</div>

<div id="outline-container-4_3_1" class="outline-4">
<h4 id="sec-4_3_1"><span class="section-number-4">4.3.1</span> MQL Socket Service </h4>
<div class="outline-text-4" id="text-4_3_1">




<div class="org-src-container"><label class="org-src-name">mql-socket-service()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">forex.backend.mql.socket-service: provide background sockets which allow us to connect with metatrader. Provides functions to interact with the background socket
</span>
<span style="color: #b22222;">;;</span><span style="color: #b22222;">todo: bug with stopping all and then stopping again! so bug with stop..
</span>(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.backend.mql.socket-service
     (<span style="color: #da70d6;">:clone</span> clj.core) 
     (<span style="color: #da70d6;">:require</span>
      [forex.util.fiber.mbox <span style="color: #da70d6;">:as</span> m]
      [clojure.contrib.logging <span style="color: #da70d6;">:as</span> l]) 
     (<span style="color: #da70d6;">:import</span> (java.io DataInputStream ByteArrayInputStream))
     (<span style="color: #da70d6;">:use</span>
      forex.backend.mql.utils
      forex.util.emacs 
      forex.util.core forex.util.general
      forex.util.zmq forex.util.log
      forex.util.spawn))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: 10ms or so per request, a little slow...
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">also, unfortunately, if we add more servers, speed doesn't increase linearly. so the bottleneck is in the clojure code ... a better designed socket service should really be made.
</span><span style="color: #b22222;">;; </span><span style="color: #b22222;">in addition, if servers drop out, we will be waiting forever for them. this is bad.
</span>
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">mql-socket-recv-address</span> <span style="color: #bc8f8f;">"tcp://127.0.0.1:3010"</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">mql-socket-send-address</span> <span style="color: #bc8f8f;">"tcp://127.0.0.1:3005"</span>)

(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*ids*</span> (<span style="color: #da70d6;">atom</span> {}))
(<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">MqlError</span> [e])

<span style="color: #b22222;">;;</span><span style="color: #b22222;">socket service
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">mql-recv</span> [msg] 
  (catch-unexpected
   (<span style="color: #a020f0;">let</span> [[id type info] msg]
     (<span style="color: #a020f0;">when</span> id
       (<span style="color: #a020f0;">let</span> [type (String. type)
             msg-ask (<span style="color: #da70d6;">get</span> @*ids* id)
             result (<span style="color: #a020f0;">cond</span>
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"long"</span>) (Long/parseLong (String. info))
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"boolean"</span>)
                     (<span style="color: #a020f0;">let</span> [a (Integer/parseInt (String. info))]
                       (<span style="color: #a020f0;">condp</span> = a
                           1 true
                           0 false
                           (Exception. (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"unkown boolean return result of "</span> a))))
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"double[]"</span>) (into-doubles info)
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"double"</span>) (Double/parseDouble (String. info)) 
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"int"</span>) (Integer/parseInt (String. info))
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"string"</span>) (String. info) 
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"error"</span>) (MqlError. (parse-int (String. info)))
                     (<span style="color: #da70d6;">=</span> type <span style="color: #bc8f8f;">"global"</span>) (String. info)
                     true (Exception. (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"Unkown type "</span> type)))] 
         (<span style="color: #a020f0;">if</span> msg-ask
           (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">deliver</span> msg-ask result) (<span style="color: #da70d6;">swap!</span> *ids* dissoc id))
           (warn <span style="color: #bc8f8f;">"msg-ask corresponding to id %s is nil"</span> id))))))) 

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">socket-service-match</span> [events send receive]
  (<span style="color: #a020f0;">let</span> [event (<span style="color: #da70d6;">first</span> events)]
    (match
     event
     [local <span style="color: #bc8f8f;">"STOP"</span>] (<span style="color: #a020f0;">do</span> (info <span style="color: #bc8f8f;">"closing ..."</span>) <span style="color: #bc8f8f;">"STOP"</span>)  
     [local [<span style="color: #bc8f8f;">"REQUEST"</span> ?msg ?askin]]  
     (<span style="color: #a020f0;">let</span> [id (msg-id)  
           result  (.snd send (<span style="color: #da70d6;">str</span> id <span style="color: #bc8f8f;">" "</span> msg) +noblock+)]
       (<span style="color: #a020f0;">if-not</span> result  
         (<span style="color: #a020f0;">do</span>  
           (warn
            <span style="color: #bc8f8f;">"failed to queue request %s: are any metatrader scripts alive?"</span>
            msg)
           (catch-unexpected
            (<span style="color: #da70d6;">deliver</span> askin (Exception. <span style="color: #bc8f8f;">"metatrader side of socket service is down"</span>))))
         (<span style="color: #da70d6;">swap!</span> *ids* assoc id askin)))  
     [receive ?msg] (mql-recv msg)   
     ?msg (warn <span style="color: #bc8f8f;">"Ignoring invalid message %s"</span> msg))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: weird bug when stopping everything with an ea.
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">spawn-mql-socket-service</span>
  []  
  (debugging
   <span style="color: #bc8f8f;">"MQL Socket Service: "</span> 
   {<span style="color: #da70d6;">:pid</span> 
    (spawn-log  
     #(<span style="color: #a020f0;">with-open</span> [send (<span style="color: #a020f0;">doto</span> (new-socket +push+)
                         (.bind mql-socket-send-address))
                  receive (<span style="color: #a020f0;">doto</span> (new-socket +pull+)
                            (.bind mql-socket-recv-address))] 
        (<span style="color: #a020f0;">loop</span> [events (event-seq [receive local])]
          (<span style="color: #a020f0;">when-not</span> (<span style="color: #da70d6;">=</span> <span style="color: #bc8f8f;">"STOP"</span> (socket-service-match events send receive))
            (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> events)))))
     <span style="color: #bc8f8f;">"MQL Socket Service"</span>)})) 

<span style="color: #b22222;">;;</span><span style="color: #b22222;">global socket service
</span>(<span style="color: #a020f0;">defonce-</span> <span style="color: #0000ff;">*s*</span> (<span style="color: #da70d6;">atom</span> nil)) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">alive?</span> []
  (pid? (<span style="color: #da70d6;">:pid</span> @*s*))) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">start</span> []
  (<span style="color: #a020f0;">if</span> (alive?)
    (warn <span style="color: #bc8f8f;">"mql socket is already alive!"</span>)
    (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> *ids* {}) (<span style="color: #da70d6;">reset!</span> *s* (spawn-mql-socket-service)))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">stop</span> []
  (<span style="color: #a020f0;">if</span> (alive?)
    (! (<span style="color: #da70d6;">:pid</span> @*s*) <span style="color: #bc8f8f;">"STOP"</span>)
    (warn <span style="color: #bc8f8f;">"mql socket service is already stopped"</span>)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">interact with mql
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: if mql isnt alive and we retry/????
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">request</span> [askin msg]
  (<span style="color: #da70d6;">io!</span>
   (<span style="color: #a020f0;">if</span> (pid? (<span style="color: #da70d6;">:pid</span> @*s*)) 
     (! (<span style="color: #da70d6;">:pid</span> @*s*) [<span style="color: #bc8f8f;">"REQUEST"</span> msg askin])
     (throwf <span style="color: #bc8f8f;">"mql socket service is not alive"</span>))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: we added a debug message
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">so when we get the really annoying failures to
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">stop we can examine this:)
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">ALSO, we can now apparently get the write lock! hmm...
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">ALL BECAUSE WE DONT USE INFINITE TIMEOUT?
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">receive</span>
  ([msg] (receive msg true))
  ([msg resend]
     (<span style="color: #a020f0;">let</span> [ask-obj (<span style="color: #da70d6;">promise</span>)]
       (request ask-obj msg)
       (<span style="color: #a020f0;">loop</span> [i 0 ask ask-obj]
         (<span style="color: #a020f0;">if</span> (wait-for ask 5000) 
           (<span style="color: #a020f0;">let</span> [result @ask]
             (<span style="color: #a020f0;">cond</span> 
              (<span style="color: #da70d6;">instance?</span> Exception result) (<span style="color: #a020f0;">throw</span> result)
              (<span style="color: #a020f0;">or</span> result (<span style="color: #da70d6;">false?</span> result)) result
              true (throwf <span style="color: #bc8f8f;">"invalid result received %s"</span> result))) 
           (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">and</span> resend (<span style="color: #da70d6;">&lt;</span> i 3)) 
             (<span style="color: #a020f0;">let</span> [ask (<span style="color: #da70d6;">promise</span>)]
               (debug <span style="color: #bc8f8f;">"resending message %s"</span> msg)
               (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">+</span> i 1) ask))
             (<span style="color: #a020f0;">do</span> (debug <span style="color: #bc8f8f;">"too much time for msg %s"</span> msg)
                 (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">+</span> i 1) ask))))))))
</pre></div>




<div class="org-src-container"><label class="org-src-name">mql-socket-service-utils()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.backend.mql.utils  
  (<span style="color: #da70d6;">:use</span> forex.util.general)
  (<span style="color: #da70d6;">:import</span> (java.io DataInputStream ByteArrayInputStream))
  (<span style="color: #da70d6;">:use</span> forex.util.log))

(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*msg-id*</span> (<span style="color: #da70d6;">atom</span> 0))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">msg-id</span> []
  (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">swap!</span> *msg-id* inc)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">parse-int</span> [a]
  (<span style="color: #a020f0;">try</span> (Integer/parseInt a) (<span style="color: #a020f0;">catch</span> Exception e a)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">catch-unexpected</span> [&amp; body]
  `(<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> ~@body)
        (<span style="color: #a020f0;">catch</span> Exception e# (.printStackTrace e#) (warn e#))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">into-doubles</span> [array] 
  (<span style="color: #a020f0;">let</span> [stream (DataInputStream. (ByteArrayInputStream. array))]
    (<span style="color: #da70d6;">repeatedly</span> (<span style="color: #da70d6;">/</span> (<span style="color: #da70d6;">count</span> array) 8) #(.readDouble stream))))   
</pre></div>



</div>
</div>

</div>

<div id="outline-container-4_4" class="outline-3">
<h3 id="sec-4_4"><span class="section-number-3">4.4</span> Module </h3>
<div class="outline-text-3" id="text-4_4">


</div>

<div id="outline-container-4_4_1" class="outline-4">
<h4 id="sec-4_4_1"><span class="section-number-4">4.4.1</span> Account </h4>
<div class="outline-text-4" id="text-4_4_1">




<div class="org-src-container"><label class="org-src-name">account-core()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">forex.module.order.core - interface with mql backend
</span>(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.module.account.core
  (<span style="color: #da70d6;">:clone</span> clj.core)
  (<span style="color: #da70d6;">:use</span> forex.util.core
        forex.util.emacs 
        forex.util.general
        forex.module.error))

(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">order</span>
  {<span style="color: #da70d6;">:buy</span> 0 <span style="color: #da70d6;">:sell</span> 1 <span style="color: #da70d6;">:buy-limit</span> 2 <span style="color: #da70d6;">:sell-limit</span> 3 <span style="color: #da70d6;">:buy-stop</span> 4 <span style="color: #da70d6;">:sell-stop</span> 5})

(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">color</span>
  {<span style="color: #da70d6;">:red</span> 230 <span style="color: #da70d6;">:yellow</span> 65535 <span style="color: #da70d6;">:green</span> 65280 <span style="color: #da70d6;">:blue</span> 13749760
   <span style="color: #da70d6;">:purple</span>  16711935 <span style="color: #da70d6;">:white</span> 16777215 <span style="color: #da70d6;">:black</span> 0})

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">get!</span> [hash key]
  (<span style="color: #a020f0;">if-let</span> [it (<span style="color: #da70d6;">hash</span> key)]
    it
    (throwf <span style="color: #bc8f8f;">"invalid key %s in hash %s"</span> key hash)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">the below can throw errors - how to handle this? 
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-modify</span>
  ([ticket price sl tp]
     (order-modify ticket price sl tp <span style="color: #da70d6;">:blue</span>))
  ([ticket price sl tp color_of]
     (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderModify %s %s %s %s %s"</span>
                      (<span style="color: #da70d6;">first</span> ticket)
                      price sl tp (get! color color_of))
              false))) 

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-send</span>
  ([symbol cmd volume price] (order-send symbol cmd volume price 0 0))
  ([symbol cmd volume price sl tp] (order-send symbol cmd volume price sl tp 3))
  ([symbol cmd volume price sl tp slip]
     (receive
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderSend %s %s %s %s %s %s %s"</span>
              symbol (get! order cmd)
              volume price slip sl tp)
      false)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-close</span> [ticket lots price slippage color_of]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderClose %s %s %s %s %s"</span>
                   (<span style="color: #da70d6;">first</span> ticket) lots price slippage (get! color color_of))
           false))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-delete</span> [ticket]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderDelete %s"</span> (<span style="color: #da70d6;">first</span> ticket))
           false))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-close-time</span> [ticket]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderCloseTime %s"</span> (<span style="color: #da70d6;">first</span> ticket))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">market-info</span> [symbol type]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"MarketInfo %s %s"</span> symbol type)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-close-time</span> [ticket]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderCloseTime %s"</span> (<span style="color: #da70d6;">first</span> ticket))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-type</span> [ticket]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderType %s"</span> (<span style="color: #da70d6;">first</span> ticket))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">order-lots</span> [ticket]
  (receive (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"OrderLots %s"</span> (<span style="color: #da70d6;">first</span> ticket))))
</pre></div>






<div class="org-src-container"><label class="org-src-name">account-utils()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)

(ns+ forex.module.account.utils
     (<span style="color: #da70d6;">:clone</span> clj.core)
     (<span style="color: #da70d6;">:use</span> forex.util.core
           forex.util.emacs  
           forex.util.general
           forex.module.error

           )
     (<span style="color: #da70d6;">:require</span>  [forex.module.account.core <span style="color: #da70d6;">:as</span> core]))


<span style="color: #b22222;">;;</span><span style="color: #b22222;">account common
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">sym</span> [a] (<span style="color: #da70d6;">symbol</span> (camel-to-dash a)))
(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">single</span> [name] `(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">~</span>(sym name) [] (receive! ~name)))
(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">singles</span> [&amp; names] `(<span style="color: #a020f0;">do</span> ~@(<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [a] `(single ~a)) names)))


<span style="color: #b22222;">;;</span><span style="color: #b22222;">none of the below singles or double-singles should throw a mql error - therefore, it is a bug if they do
</span>(singles
 <span style="color: #bc8f8f;">"AccountCurrency"</span>
 <span style="color: #bc8f8f;">"AccountCompany"</span>
 <span style="color: #bc8f8f;">"AccountServer"</span> 
 <span style="color: #bc8f8f;">"AccountName"</span>
 <span style="color: #bc8f8f;">"AccountNumber"</span>
 <span style="color: #bc8f8f;">"AccountCredit"</span>
 <span style="color: #bc8f8f;">"AccountBalance"</span>
 <span style="color: #bc8f8f;">"AccountEquity"</span>
 <span style="color: #bc8f8f;">"AccountFreeMargin"</span>
 <span style="color: #bc8f8f;">"AccountLeverage"</span>
 <span style="color: #bc8f8f;">"AccountMargin"</span>
 <span style="color: #bc8f8f;">"AccountProfit"</span>
 <span style="color: #bc8f8f;">"OrdersTotal"</span>)
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">demo?</span> [] (receive <span style="color: #bc8f8f;">"IsDemo"</span>))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">connected?</span> [] (receive <span style="color: #bc8f8f;">"IsConnected"</span>))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">trade?</span> [] (receive <span style="color: #bc8f8f;">"IsTradeAllowed"</span>))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span>
(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">define-market-info</span> [&amp; args]
  `(<span style="color: #a020f0;">do</span> ~@(<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [[name num]]
                `(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">~</span>(symbolicate <span style="color: #bc8f8f;">"mode-"</span> name)
                   ([] (~(symbolicate <span style="color: #bc8f8f;">"mode-"</span> name) (env <span style="color: #da70d6;">:symbol</span>)))
                   ([symbol#]
                      (<span style="color: #a020f0;">let</span> [res# (core/market-info symbol# ~num)]
                        (<span style="color: #a020f0;">if</span> (e? res#)
                          (throwf <span style="color: #bc8f8f;">"market-info error %s"</span> (<span style="color: #da70d6;">:e</span> res#))
                          res#)))))
              (group args)))) 

(define-market-info
  low 1
  high 2
  time 5
  bid 9
  ask 10
  point 11
  digits 12
  spread 13
  stoplevel 14
  lotsize 15
  tickvalue 16
  ticksize 17
  swaplong 18
  swapshort 19
  starting 20
  expiration 21
  trade-allowed 22
  minlot 23
  lotstep 24
  maxlot 25
  swaptype 26
  profitcalcmode 27
  margincalcmode 28
  margininit 29
  marginmaintenance 30
  marginhedged 31
  marginrequired 32
  freezelevel 33)

(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">demo?</span> []
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">re-find</span> #<span style="color: #bc8f8f;">"(?i)demo"</span> (account-server))
      true
      false)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">sell?</span> [{type <span style="color: #da70d6;">:type</span>}]
  (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell-stop</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell-limit</span>)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">buy?</span> [{type <span style="color: #da70d6;">:type</span>}]
  (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy-stop</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy-limit</span>)))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">to-big</span> [num] (BigDecimal/valueOf (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">integer?</span> num) (<span style="color: #da70d6;">double</span> num) num)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">lot</span> 
  ([num] (lot num (env <span style="color: #da70d6;">:symbol</span>)))
  ([num symbol]
     (<span style="color: #da70d6;">double</span> (<span style="color: #a020f0;">let</span> [a (to-big num)  
                   b (to-big (mode-minlot symbol))]
               (<span style="color: #da70d6;">*</span> b (.intValue (<span style="color: #da70d6;">/</span> a b)))))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">assert-order</span> [order] (is? [(<span style="color: #a020f0;">or</span> (sell? order) (buy? order))]))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">o--</span> [o &amp; args]
  (assert-order o)
  (<span style="color: #a020f0;">if</span> (sell? o) (<span style="color: #da70d6;">-</span> (<span style="color: #da70d6;">apply</span> - args)) (<span style="color: #da70d6;">apply</span> - args)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">o+</span> [o &amp; args]
  (assert-order o) 
  (<span style="color: #a020f0;">if</span> (sell? o) (<span style="color: #da70d6;">apply</span> - args) (<span style="color: #da70d6;">apply</span> + args)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">o-</span> [o &amp; args]
  (assert-order o)
  (<span style="color: #a020f0;">if</span> (sell? o) (<span style="color: #da70d6;">apply</span> + args) (<span style="color: #da70d6;">apply</span> - args)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">omax</span> [order &amp; args]
  (assert-order order)
  (<span style="color: #a020f0;">let</span> [args (<span style="color: #da70d6;">filter</span> #(<span style="color: #da70d6;">not</span> (zero? %)) args)]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> args)
      (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">:sl</span> order) 0) 
      (<span style="color: #da70d6;">apply</span> (<span style="color: #a020f0;">if</span> (buy? order) max min) args))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">omin</span> [order &amp; args]
  (assert-order order)
  (<span style="color: #a020f0;">let</span> [args (<span style="color: #da70d6;">filter</span> #(<span style="color: #da70d6;">not</span> (zero? %)) args)]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> args)
      (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">:sl</span> order) 0) 
      (<span style="color: #da70d6;">apply</span> (<span style="color: #a020f0;">if</span> (buy? order) min max)
             args))))


<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: change for 4 digit broker
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">digits</span> []
  (mode-digits <span style="color: #bc8f8f;">"EURUSD"</span>))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: check for valid symbol on all of this??
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">spread</span>
  ([] (spread (env <span style="color: #da70d6;">:symbol</span>)))
  ([symbol]
     (<span style="color: #a020f0;">let</span> [d (digits) spread (mode-spread symbol)]
       (<span style="color: #a020f0;">cond</span>
        (<span style="color: #da70d6;">=</span> d 5) (<span style="color: #da70d6;">/</span> spread 10)
        (<span style="color: #da70d6;">=</span> d 4) spread))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">point</span>
  ([pt] (<span style="color: #da70d6;">/</span> pt (point)))
  ([]
     (<span style="color: #a020f0;">let</span> [d (digits)]  
       (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> d 5)
         (<span style="color: #da70d6;">*</span> 10 (mode-point))
         (mode-point)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">pip</span> [pt] (<span style="color: #da70d6;">*</span> (point) pt))
</pre></div>




<div class="org-src-container"><label class="org-src-name">account-common()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: unit test everything
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: create a new atom-hash on merging, etc????????
</span>(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.module.account
     (<span style="color: #da70d6;">:clone</span> clj.core)
     (<span style="color: #da70d6;">:require</span> forex.backend.mql.socket-service)
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(:import forex.backend.mql.socket-service.MqlError)
</span>     (<span style="color: #da70d6;">:use</span> forex.util.core
           forex.util.emacs  
           forex.util.general forex.util.log
           forex.module.indicator
           forex.module.error forex.module.account.utils)

     (<span style="color: #da70d6;">:require</span>  [forex.module.account.core <span style="color: #da70d6;">:as</span> core]))

(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">*account-warn-on-mql-error*</span> true)

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">account-warn</span>
  ([err order] (account-warn err order <span style="color: #bc8f8f;">""</span>))
  ([err order msg &amp; args]
     (<span style="color: #a020f0;">if</span> *account-warn-on-mql-error* 
       (<span style="color: #a020f0;">do</span> (warn <span style="color: #bc8f8f;">"MQL error %s on order %s - %s"</span> (<span style="color: #da70d6;">:e</span> err)
                 order (<span style="color: #da70d6;">apply</span> format msg args)) err)
       err)))
(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">with-order</span> [order &amp; body]
  `(<span style="color: #a020f0;">let</span> [o# ~order]
     (<span style="color: #a020f0;">if-not</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:lots</span> o#) 0)
       (<span style="color: #a020f0;">do</span> ~@body)
       (<span style="color: #a020f0;">do</span> (warn <span style="color: #bc8f8f;">"attempting to change order %s with zero lots"</span> o#)
           o#)))) 

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">&gt;?</span> [a] (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">number?</span> a) (<span style="color: #da70d6;">&gt;=</span> a 0)))

(<span style="color: #da70d6;">comment</span>
  (<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">default</span> [&amp; body] 
    `(<span style="color: #a020f0;">binding</span> [*default* @~#'err/*er*]
       ~@body)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: do we need all of these assertions?
</span>(<span style="color: #a020f0;">def-</span> <span style="color: #0000ff;">value-to-order-type</span>
  {0 <span style="color: #da70d6;">:buy</span> 1 <span style="color: #da70d6;">:sell</span> 2 <span style="color: #da70d6;">:buy-limit</span>
   3 <span style="color: #da70d6;">:sell-limit</span> 4 <span style="color: #da70d6;">:buy-stop</span>
   5 <span style="color: #da70d6;">:sell-stop</span>}) 

(<span style="color: #a020f0;">defprotocol</span> <span style="color: #0000ff;">POrder</span>
  (order-close-time [this])
  (order-type [this])
  (delete! [this] )
  (close! [this] [this new-lots])
  (modify! [this sl-tp-map])
  (order! [this])
  (open? [this]) (close? [this])
  (order? [this]) 
  (market? [this]) (entry? [this]))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">order-close-time*</span> [{id <span style="color: #da70d6;">:id</span>}]
  {<span style="color: #da70d6;">:pre</span> [(<span style="color: #da70d6;">string?</span> (<span style="color: #da70d6;">first</span> id))]}
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">we dont need to know mql4 error codes for order close time
</span>  (aif (core/order-close-time id) it -1)) <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: return 0 instead?
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">order-type*</span>  [{id <span style="color: #da70d6;">:id</span>}] 
  {<span style="color: #da70d6;">:pre</span> [(<span style="color: #da70d6;">string?</span> (<span style="color: #da70d6;">first</span> id))]}
  (aif (core/order-type id)
       (value-to-order-type (<span style="color: #da70d6;">int</span> it))))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">delete!*</span> [{id <span style="color: #da70d6;">:id</span> lots <span style="color: #da70d6;">:lots</span> <span style="color: #da70d6;">:as</span> o}]
  (with-order o
    (<span style="color: #a020f0;">if-not</span> (<span style="color: #da70d6;">=</span> lots 0)
      (aif (core/order-delete id) (<span style="color: #da70d6;">merge</span> o {<span style="color: #da70d6;">:lots</span> 0}) it)
      o)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TOOD: make more robust? does metatrader always append modified trade? is it thread safe?
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">close!*</span>
  ([o] (close! o 0))
  ([{<span style="color: #da70d6;">:keys</span> [price lots slip id symbol] <span style="color: #da70d6;">:as</span> order} new-lots]
     (with-order order
       (is? [(<span style="color: #da70d6;">string?</span> (<span style="color: #da70d6;">first</span> id)) (<span style="color: #da70d6;">string?</span> symbol) 
             [price (<span style="color: #da70d6;">pos?</span> price)]
             [(<span style="color: #da70d6;">number?</span> lots) (<span style="color: #da70d6;">&gt;=</span> lots 0)]])
       (is? (<span style="color: #da70d6;">&gt;=</span> (<span style="color: #da70d6;">-</span> lots new-lots) 0))
       (<span style="color: #a020f0;">if-not</span> (<span style="color: #da70d6;">=</span> new-lots lots)
         (aif (core/order-close id (<span style="color: #da70d6;">-</span> lots new-lots)
                                (<span style="color: #a020f0;">if</span> (sell? order)
                                  (ask symbol)
                                  (bid symbol))
                                slip <span style="color: #da70d6;">:blue</span>)
              (<span style="color: #da70d6;">merge</span> order {<span style="color: #da70d6;">:lots</span> new-lots 
                            <span style="color: #da70d6;">:id</span> (<span style="color: #a020f0;">cond</span>
                                 (<span style="color: #da70d6;">=</span> new-lots 0) id 
                                 (<span style="color: #da70d6;">=</span> it false)
                                 (<span style="color: #a020f0;">do</span> (severe <span style="color: #bc8f8f;">"dropping a partial close id for order %s"</span>
                                             (<span style="color: #da70d6;">merge</span> order {<span style="color: #da70d6;">:lots</span> new-lots}))
                                     id) 
                                 true  (<span style="color: #da70d6;">concat</span> (<span style="color: #da70d6;">list</span> it) id))})
              (account-warn it order <span style="color: #bc8f8f;">"invalid new lots %s"</span> new-lots))
         order)))) 

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: normalize so we dont get mql error 1?
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: act as a regular modify if we dont pass in sl,tp,or price 
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">modify!*</span> [order {<span style="color: #da70d6;">:keys</span> [sl tp] <span style="color: #da70d6;">:as</span> mod}]
  (with-order order
    (<span style="color: #a020f0;">let</span> [sl (<span style="color: #a020f0;">or</span> sl (<span style="color: #da70d6;">:sl</span> order))
          tp (<span style="color: #a020f0;">or</span> tp (<span style="color: #da70d6;">:tp</span> order)) 
          price (<span style="color: #da70d6;">:price</span> order)] 
      (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">number?</span> sl) (<span style="color: #da70d6;">number?</span> tp))
        (<span style="color: #a020f0;">do</span>  
          (is? [sl tp price (&gt;? sl) (&gt;? tp) (<span style="color: #da70d6;">pos?</span> price)]) 
          (<span style="color: #a020f0;">if-not</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">=</span> sl (<span style="color: #da70d6;">:sl</span> order))
                       (<span style="color: #da70d6;">=</span> tp (<span style="color: #da70d6;">:tp</span> order)))
            (aif (core/order-modify (<span style="color: #da70d6;">:id</span> order) (<span style="color: #da70d6;">:price</span> order) sl tp)
                 (<span style="color: #da70d6;">merge</span> order (<span style="color: #da70d6;">merge</span> mod {<span style="color: #da70d6;">:sl</span> sl <span style="color: #da70d6;">:tp</span> tp}))
                 (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:e</span> it) 1)
                   (<span style="color: #da70d6;">merge</span> order mod)
                   (account-warn it order <span style="color: #bc8f8f;">"sl %s tp %s"</span> sl tp)))
            (<span style="color: #da70d6;">merge</span> order mod)))
        (<span style="color: #da70d6;">merge</span> order mod)))))   

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TOODOs: how do we get map with defaults?
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">verify-order</span> [{<span style="color: #da70d6;">:keys</span> [slip symbol type price tp sl lots]
                      <span style="color: #da70d6;">:or</span> {slip 3 sl 0 tp 0}}]
  (is? [(<span style="color: #da70d6;">number?</span> slip) (<span style="color: #da70d6;">&gt;</span> slip 0) (<span style="color: #da70d6;">integer?</span> slip)]
       <span style="color: #bc8f8f;">"invalid order slip %s"</span> slip)
  (is? [ (<span style="color: #da70d6;">keyword?</span> type) (<span style="color: #da70d6;">number?</span> lots)
         (<span style="color: #da70d6;">number?</span> tp) (<span style="color: #da70d6;">number?</span> sl) (<span style="color: #da70d6;">number?</span> price)]) 
  (is? [ (<span style="color: #da70d6;">string?</span> symbol) (<span style="color: #da70d6;">&gt;</span> lots 0)
         (<span style="color: #da70d6;">&gt;=</span> tp 0) (<span style="color: #da70d6;">&gt;=</span> sl 0) (<span style="color: #da70d6;">&gt;=</span> price 0)])  
  (<span style="color: #a020f0;">cond</span>
   (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell-limit</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell-stop</span>))
   (is? (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (zero? sl) (zero? tp))
            (<span style="color: #a020f0;">and</span> (zero? sl) tp (<span style="color: #da70d6;">&lt;</span> tp price))
            (<span style="color: #a020f0;">and</span> (zero? tp) sl (<span style="color: #da70d6;">&gt;</span> sl price))
            (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&lt;</span> tp sl) (<span style="color: #da70d6;">&lt;</span> tp price) (<span style="color: #da70d6;">&gt;</span> sl price)))
        <span style="color: #bc8f8f;">"invalid %s order with sl/tp %s/%s with price of %s"</span> type sl tp price)
   (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy-limit</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy-stop</span>))
   (is? (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (zero? sl) (zero? tp))
            (<span style="color: #a020f0;">and</span> (zero? sl) tp (<span style="color: #da70d6;">&gt;</span> tp price))
            (<span style="color: #a020f0;">and</span> (zero? tp) sl (<span style="color: #da70d6;">&lt;</span> sl price))
            (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&gt;</span> tp sl) (<span style="color: #da70d6;">&gt;</span> tp price) (<span style="color: #da70d6;">&lt;</span> sl price)))
        <span style="color: #bc8f8f;">"invalid %s order with sl/tp %s/%s with price of %s"</span> type sl tp price)
   true (throwf <span style="color: #bc8f8f;">"invalid %s order with sl/tp %s/%s with price of %s"</span>
                type sl tp price))) 
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: change to make reliable and to work for ECN brokers and such
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">see http://forum.mql4.com/36608
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: what happens if second modify fails? how can programmer find this out?
</span>
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">order!*</span> [{<span style="color: #da70d6;">:keys</span> [symbol type price tp sl lots slip]
                 <span style="color: #da70d6;">:as</span> order
                 <span style="color: #da70d6;">:or</span> { symbol (env <span style="color: #da70d6;">:symbol</span>) sl 0 tp 0 slip 3}}]
  (<span style="color: #a020f0;">let</span> [price (<span style="color: #a020f0;">or</span> price (<span style="color: #a020f0;">if</span> (sell? order) (bid symbol) (ask symbol)))
        order (<span style="color: #da70d6;">merge</span> 
               {<span style="color: #da70d6;">:symbol</span> symbol
                <span style="color: #da70d6;">:slip</span> slip}
               (<span style="color: #da70d6;">merge</span> order {<span style="color: #da70d6;">:sl</span> 0 <span style="color: #da70d6;">:tp</span> 0 <span style="color: #da70d6;">:id</span> <span style="color: #bc8f8f;">""</span> <span style="color: #da70d6;">:price</span> price}))]
    (with-order order    
      (verify-order order)
      (aif (core/order-send symbol type lots price 0 0 slip)
           (<span style="color: #a020f0;">let</span> [result
                 (<span style="color: #a020f0;">let</span> [o (<span style="color: #da70d6;">merge</span> order {<span style="color: #da70d6;">:id</span> [it]})]
                   <span style="color: #b22222;">;;</span><span style="color: #b22222;">now, use modify to change sl and tp
</span>                   (aif (modify!* o {<span style="color: #da70d6;">:sl</span> sl <span style="color: #da70d6;">:tp</span> tp})
                        (<span style="color: #da70d6;">merge</span> o {<span style="color: #da70d6;">:sl</span> sl <span style="color: #da70d6;">:tp</span> tp})
                        o))
                 spread (spread)]
             (<span style="color: #da70d6;">merge</span> result {<span style="color: #da70d6;">:spread</span> spread <span style="color: #da70d6;">:break</span> (o+ result price (pip spread))})) 
           (account-warn it order))))) 

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">open?*</span> [order] 
  (<span style="color: #da70d6;">=</span> (order-close-time order) 0))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">close?*</span> [order]
  (<span style="color: #da70d6;">not</span> (open? order)))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">order?*</span> [order]
  (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">nil?</span> (order-type order))))   
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">market?*</span>
  <span style="color: #bc8f8f;">"determine if order is market order"</span>
  [order]
  (<span style="color: #a020f0;">let</span> [type (order-type order)]
    (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy</span>)))) 
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">entry?*</span>
  <span style="color: #bc8f8f;">"determine if order is entry order"</span>
  [order]
  (<span style="color: #a020f0;">let</span> [type (order-type order)]
    (<span style="color: #a020f0;">and</span> type (<span style="color: #da70d6;">not</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell</span>) (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy</span>))))))

(<span style="color: #da70d6;">extend</span> clojure.lang.IPersistentMap
  POrder {<span style="color: #da70d6;">:order-close-time</span> order-close-time*
          <span style="color: #da70d6;">:order-type</span> order-type*
          <span style="color: #da70d6;">:delete!</span> delete!*
          <span style="color: #da70d6;">:close!</span> close!*
          <span style="color: #da70d6;">:modify!</span> modify!*
          <span style="color: #da70d6;">:order!</span> order!*

          <span style="color: #da70d6;">:open?</span> open?*
          <span style="color: #da70d6;">:close?</span> close?*
          <span style="color: #da70d6;">:order?</span> order?*
          <span style="color: #da70d6;">:market?</span> market?*
          <span style="color: #da70d6;">:entry?</span> entry?*})

(<span style="color: #da70d6;">extend-type</span> forex.backend.mql.socket-service.MqlError
  POrder
  (order! [this] this)
  (delete! [this] this)
  (close! [this] this)
  (close! [this _] this)
  (modify! [this] this))

(<span style="color: #da70d6;">extend-type</span> forex.util.core.AtomHash <span style="color: #b22222;">;;</span><span style="color: #b22222;">clojure.lang.Atom
</span>  POrder
  (order-close-time [this] (order-close-time @this))
  (order-type [this] (order-type @this))
  (order! [this] (aif (order! @this)
                      (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> (.val this) it) this)
                      it))
  (delete! [this] (aif (delete! @this) (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> (.val this) it) this) it))  
  (close!
   ([this new-amount] (aif (close! @this new-amount) (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> (.val this) it) this) it))
   ([this] (close! this 0)))
  (modify! [this sl-tp] (aif (modify! @this sl-tp) (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> (.val this) it) this) it))
  (open? [this] (open? @this))
  (close? [this] (<span style="color: #da70d6;">not</span> (open? @this)))
  (order? [this] (order? @this))
  (market? [this] (market? @this))
  (entry? [this] (entry? @this)))
</pre></div>


</div>

</div>

<div id="outline-container-4_4_2" class="outline-4">
<h4 id="sec-4_4_2"><span class="section-number-4">4.4.2</span> Ea </h4>
<div class="outline-text-4" id="text-4_4_2">




<div class="org-src-container"><label class="org-src-name">ea-common()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: it would be awesome if we could directly modify vars of an ea. but we cant, we can only stop , merge, start. TOOD: lookup how set! works!
</span>
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.module.ea 
     (<span style="color: #da70d6;">:clone</span> clj.core) 
     (<span style="color: #da70d6;">:use</span> forex.util.core
           forex.util.general 
           forex.util.spawn forex.util.emacs
           clojure.contrib.core)
     (<span style="color: #da70d6;">:import</span> clojure.lang.Atom)
     (<span style="color: #da70d6;">:require</span> [clj-time.core <span style="color: #da70d6;">:as</span> t])
     (<span style="color: #da70d6;">:use</span>  
      forex.util.emacs
      forex.util.log  
      forex.module.error 
      forex.module.indicator 
      forex.module.account)
     (<span style="color: #da70d6;">:import</span> forex.util.core.AtomHash  java.util.concurrent.TimeUnit))
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">save-file</span> nil) 
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">ea-on-exit-hook</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">ea-on-start-hook</span>)
(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*ea-registry*</span> (<span style="color: #da70d6;">atom</span> []))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">register-ea</span> []
  (<span style="color: #da70d6;">swap!</span> *ea-registry*
         (<span style="color: #da70d6;">fn</span> [old]
           (<span style="color: #da70d6;">filter</span> #(<span style="color: #da70d6;">find-ns</span> (<span style="color: #da70d6;">symbol</span> %))
                   (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">some</span> #(<span style="color: #da70d6;">=</span> % (<span style="color: #da70d6;">str</span> *ns*)) old)
                     old
                     (<span style="color: #da70d6;">conj</span> old (<span style="color: #da70d6;">str</span> *ns*)))))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">saving objects to strings and going back -slow, but it works
</span>(<span style="color: #a020f0;">import</span> (java.io ByteArrayOutputStream ObjectOutputStream
                 ByteArrayInputStream ObjectInputStream)
        org.apache.commons.codec.binary.Base64)
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">bytes-to-obj</span>
  <span style="color: #bc8f8f;">"convert bytes to object"</span>
  [obj]
  (.readObject
   (ObjectInputStream.
    (ByteArrayInputStream. obj))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">obj-to-bytes</span>
   <span style="color: #bc8f8f;">"convert object to bytes"</span>
   [obj]
   (<span style="color: #a020f0;">with-open</span> [bos (ByteArrayOutputStream.)
               stream (ObjectOutputStream. bos)]
     (.writeObject stream obj)
     (.flush stream) 
     (.toByteArray bos))) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">encode</span> [o]
  (Base64/encodeBase64String (obj-to-bytes o)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">decode</span> [o]
  (bytes-to-obj (Base64/decodeBase64 o)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">print-dup</span> <span style="color: #da70d6;">:default</span> [o w]
  (.write w (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"#=(forex.module.ea/decode \""</span> (encode o) <span style="color: #bc8f8f;">"\")"</span>)))  
<span style="color: #b22222;">;;;;;;;;;;;;;;;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;;;;;;;;;;;;;;;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;;;;;;;;;;;;;;;;;;; </span><span style="color: #b22222;">
</span>

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">get-fn</span> [a] (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">var?</span> a) (<span style="color: #da70d6;">var-get</span> a) a)) 
(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*ea*</span> nil)
(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*args*</span> nil) 
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">with-ea</span> [[ea &amp; name] &amp; body]
  `(<span style="color: #a020f0;">let</span> [ea# ~ea]
     (debugging (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s %s:"</span> ~(<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">first</span> name) <span style="color: #bc8f8f;">""</span>) (<span style="color: #da70d6;">:name</span> ea#))
                (<span style="color: #a020f0;">binding</span> [*ea* ea# *args* (<span style="color: #da70d6;">:args</span> ea#)]
                  (wenv {<span style="color: #da70d6;">:symbol</span> (<span style="color: #da70d6;">:symbol</span> ea#) <span style="color: #da70d6;">:period</span> (<span style="color: #da70d6;">:period</span> ea#)}
                        ~@body)))))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">locking-read</span>[lock &amp; body]
  `(<span style="color: #a020f0;">let</span> [l# (.readLock ~lock)]
     (<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> (.lock l#) ~@body)
          (<span style="color: #a020f0;">finally</span> (.unlock l#)))))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: for some reason, write lock never can lock
</span>(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">locking-write</span> [lock &amp; body]
  `(<span style="color: #a020f0;">let</span> [l# (.writeLock ~lock)]
     (<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> (.lock l#) ~@body)
          (<span style="color: #a020f0;">finally</span> (.unlock l#)))))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">locking-write-timeout</span> [[ lock timeout] &amp; body]
  `(<span style="color: #a020f0;">let</span> [l# (.writeLock ~lock)]
     (<span style="color: #a020f0;">if</span> (.tryLock l# ~timeout TimeUnit/MILLISECONDS)
       (<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span>  ~@body)
            (<span style="color: #a020f0;">finally</span> (.unlock l#))))))


(deferror *ea-stop* [*clj-forex-error*] [message]
  {<span style="color: #da70d6;">:msg</span> (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"ea stop: "</span> message)})


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">exit</span>
  ([msg] (raise *ea-stop* msg))
  ([msg &amp; args] (raise *ea-stop* (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> msg)
                                   (<span style="color: #da70d6;">apply</span> format msg args)
                                   (<span style="color: #da70d6;">concat</span> [msg] args)))))



<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: do we really want to copy these objects? yes, in most cases perhaps
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">but we should add an option to the ea definition (we will do that later, before first release)
</span>(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">copy-ea-obj</span> class)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ea-obj</span> <span style="color: #da70d6;">:default</span> [o] o)
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ea-obj</span> clojure.lang.Atom [o] (<span style="color: #da70d6;">atom</span> (copy-ea-obj @o)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ea-obj</span> clojure.lang.Ref [o] (<span style="color: #da70d6;">ref</span> (copy-ea-obj @o)))
(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">copy-ea-obj</span> forex.util.core.AtomHash [o] (atom-hash (copy-ea-obj @o)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">copy-ea-objs</span> [map]
  (<span style="color: #da70d6;">apply</span> hash-map
         (<span style="color: #da70d6;">mapcat</span> (<span style="color: #da70d6;">fn</span> [[key val]]
                   (<span style="color: #da70d6;">list</span> key (copy-ea-obj val)))
                 map)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">##ea implementation
</span>(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*eas*</span> (<span style="color: #da70d6;">atom</span> []))
(<span style="color: #a020f0;">import</span> java.util.concurrent.locks.ReentrantReadWriteLock)
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: lock orphaning
</span>(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">*ea-pre-lock*</span>
  (java.util.concurrent.locks.ReentrantReadWriteLock. true))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">every</span> [pred coll]
  (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> coll)
    false
    (<span style="color: #a020f0;">loop</span> [a coll]
      (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> a)
        true
        (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">not</span> (pred (<span style="color: #da70d6;">first</span> a)))
          false
          (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">rest</span> a)))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">query</span> [m]
  (<span style="color: #a020f0;">let</span> [a (<span style="color: #da70d6;">filter</span>
           (<span style="color: #da70d6;">fn</span> [ea]
             (<span style="color: #a020f0;">if</span> (every (<span style="color: #da70d6;">fn</span> [[key val]]
                          (<span style="color: #da70d6;">=</span> val (<span style="color: #da70d6;">get</span> ea key)))
                        m) 
               ea))
           @*eas*)]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">count</span> a) 1) (<span style="color: #da70d6;">first</span> a) a)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">alive?</span> [ea] (pid? (<span style="color: #da70d6;">:pid</span> ea)))

(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">catch-unexpected</span> [prefix &amp; body]
  `(<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> ~@body)
        (<span style="color: #a020f0;">catch</span> Exception e#
          (severe <span style="color: #bc8f8f;">"%s - caught unexpected error %s"</span> ~prefix e#))))


(<span style="color: #da70d6;">require</span> 'clojure.contrib.error-kit)
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO; how to create unbound var for error-kit???
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ping</span> [a] (! (<span style="color: #da70d6;">:pid</span> a) <span style="color: #bc8f8f;">"PING"</span>))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ping-all</span> [] (<span style="color: #a020f0;">doall</span> (<span style="color: #da70d6;">map</span> ping @*eas*)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: we need a monitor which pings and then sets something.... like in erlang
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-by-tick</span> [{<span style="color: #da70d6;">:keys</span> [deinit init start] <span style="color: #da70d6;">:as</span> ea}]
  (with-ea [ea]   
    (<span style="color: #a020f0;">try</span>
      (run-hooks ea-on-start-hook)
      (clojure.contrib.error-kit/with-handler
        (<span style="color: #a020f0;">loop</span> [prev-close nil]
          (sleep 1) 
          (<span style="color: #a020f0;">when-not</span>
              (match (? 0) 
                     <span style="color: #bc8f8f;">"STOP"</span> true
                     <span style="color: #bc8f8f;">"PING"</span> (<span style="color: #a020f0;">do</span> (out <span style="color: #bc8f8f;">"ping"</span>) nil)) 
            (<span style="color: #a020f0;">let</span> [new-close (close)]  
              (<span style="color: #a020f0;">when-not</span> (<span style="color: #da70d6;">=</span> new-close prev-close)
                (<span style="color: #a020f0;">let</span> [func (get-fn start)]
                  (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> func)
                    (locking-read *ea-pre-lock*
                                  (func (<span style="color: #da70d6;">:args</span> ea)))
                    (warn <span style="color: #bc8f8f;">"%s is not a function. start cannot be called"</span> func))))
              (<span style="color: #a020f0;">recur</span> new-close))))
        (clojure.contrib.error-kit/handle *ea-stop* [message] (out <span style="color: #bc8f8f;">"stopping ea ... %s"</span> message)))  
      (<span style="color: #a020f0;">catch</span> Exception e 
        (severe <span style="color: #bc8f8f;">"stopping ea... caught exception %s"</span> e)
        (<span style="color: #da70d6;">reset!</span> (<span style="color: #da70d6;">:exit</span> ea) e)
        (.printStackTrace e))
      (<span style="color: #a020f0;">finally</span>
       (<span style="color: #a020f0;">when-not</span> @(<span style="color: #da70d6;">:exit</span> ea) (<span style="color: #da70d6;">reset!</span> (<span style="color: #da70d6;">:exit</span> ea) true))
       (info <span style="color: #bc8f8f;">"running deinit ..."</span>)
       (catch-unexpected
        <span style="color: #bc8f8f;">"deinit"</span> 
        (<span style="color: #a020f0;">let</span> [de (get-fn deinit)]
          (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> de)
            (de)
            (warn <span style="color: #bc8f8f;">"deinit %s is not a function. ignoring ...."</span> de))))))
    (run-hooks ea-on-exit-hook)))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">timeframe?</span> [a] (<span style="color: #da70d6;">number?</span> a))
(<span style="color: #a020f0;">defrecord</span> <span style="color: #0000ff;">EA</span> [name type ns init deinit start symbol period args
               pid run vars exit]) 

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">constant-map</span> [&amp; args] {})
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">constant-true</span> [&amp; args] {})
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-ea</span>
  ([] (new-ea {}))
  ([{<span style="color: #da70d6;">:keys</span> [ns symbol period run args vars] <span style="color: #da70d6;">:or</span> {symbol (env <span style="color: #da70d6;">:symbol</span>)
                                                 run run-by-tick
                                                 vars {}
                                                 period (env <span style="color: #da70d6;">:period</span>)}}]
     (<span style="color: #a020f0;">let</span> [ns (<span style="color: #a020f0;">cond</span>
               (<span style="color: #da70d6;">nil?</span> ns) *ns*
               (<span style="color: #da70d6;">symbol?</span> ns) (<span style="color: #da70d6;">find-ns</span> ns)
               (<span style="color: #da70d6;">string?</span> ns) (<span style="color: #da70d6;">find-ns</span> (<span style="color: #da70d6;">symbol</span> ns))
               true ns)]
       (is? (ns? ns))
       (is? [(<span style="color: #da70d6;">map?</span> vars) (<span style="color: #da70d6;">every?</span> var? (<span style="color: #da70d6;">keys</span> vars))])
       (<span style="color: #a020f0;">let</span> [name (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">ns-name</span> ns))
             start (ns-symbol 'start ns)
             init (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">let</span> [fn (ns-symbol 'init ns)]
                        (<span style="color: #a020f0;">if</span> (get-fn fn) fn))
                      constant-map)
             deinit (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">let</span> [fn (ns-symbol 'deinit ns)]
                          (<span style="color: #a020f0;">if</span> (get-fn fn) fn))
                        constant-true)] 
         (is? [(<span style="color: #da70d6;">fn?</span> (get-fn init)) (<span style="color: #da70d6;">fn?</span> (get-fn deinit)) (<span style="color: #da70d6;">string?</span> name)
               (<span style="color: #da70d6;">string?</span> symbol) (<span style="color: #da70d6;">fn?</span> run) (timeframe? period)])
         (EA. (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s %s, %s"</span> name symbol period) (<span style="color: #da70d6;">last</span> (.split name <span style="color: #bc8f8f;">"\\."</span>))
              ns
              init deinit start symbol period (<span style="color: #a020f0;">or</span> args {})
              nil run
              (<span style="color: #da70d6;">merge</span> (copy-ea-objs (ns-vars ns)) vars)
              (<span style="color: #da70d6;">atom</span> 0)))))) 

<span style="color: #b22222;">;;</span><span style="color: #b22222;">how to get it to access actual var? as long as we dont use set!
</span>(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">clojure.core/print-method</span> EA [o w]
  (.write w  (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"&lt;EA \"%s\" %s %s |%s|&gt;"</span>
                     (<span style="color: #da70d6;">:name</span> o) (pid? (<span style="color: #da70d6;">:pid</span> o))
                     (<span style="color: #da70d6;">:args</span> o) (<span style="color: #da70d6;">:vars</span> o))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: pid without spawn!!
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-start</span> [ea]
  (<span style="color: #a020f0;">let</span> [ea (<span style="color: #da70d6;">merge</span> ea {<span style="color: #da70d6;">:exit</span> (<span style="color: #da70d6;">atom</span> false)})]
   (with-ea [ea <span style="color: #bc8f8f;">"START"</span>] 
     (<span style="color: #da70d6;">with-bindings</span> (<span style="color: #da70d6;">:vars</span> ea)
       (<span style="color: #a020f0;">let</span> [new-ea (<span style="color: #da70d6;">merge</span> ea {<span style="color: #da70d6;">:pid</span> (spawn
                                   #((<span style="color: #da70d6;">:run</span> ea) ea)
                                   (<span style="color: #da70d6;">:name</span> ea))})]
         (<span style="color: #da70d6;">swap!</span> *eas* conj new-ea) 
         new-ea)))))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">restart</span> [ea]  
  (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">not</span> (alive? ea))
    <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: for some reason, if we change it to (hash old), it screws up! what!
</span>    (<span style="color: #a020f0;">let</span> [old (<span style="color: #da70d6;">swap!</span> *eas*
                     (<span style="color: #da70d6;">fn</span> [old] (<span style="color: #a020f0;">doall</span> (<span style="color: #da70d6;">filter</span> #(<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">hash</span> ea) (<span style="color: #da70d6;">hash</span> %))) old))))]
      (<span style="color: #a020f0;">try</span>
        (run-start ea)
        (<span style="color: #a020f0;">catch</span> Exception e (<span style="color: #da70d6;">swap!</span> *eas* conj ea)
               (.printStackTrace e)
               (out <span style="color: #bc8f8f;">"caught exception when running start %s"</span> e))))))

 <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: check return type
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-init</span> [ea]
  (with-ea [ea <span style="color: #bc8f8f;">"INIT"</span>]
    (<span style="color: #a020f0;">let</span> [result ((get-fn (<span style="color: #da70d6;">:init</span> ea)) (<span style="color: #da70d6;">:args</span> ea))]
      (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">map?</span> result)
        (<span style="color: #da70d6;">merge</span> ea {<span style="color: #da70d6;">:vars</span> (<span style="color: #da70d6;">merge</span> (<span style="color: #da70d6;">:vars</span> ea) result)})))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-all</span> [ea]
  (<span style="color: #a020f0;">try</span>
    (with-ea [ea <span style="color: #bc8f8f;">"ALL"</span>]
      (<span style="color: #a020f0;">let</span> [new-ea (run-init ea)]
        (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">instance?</span> EA new-ea)
          (run-start new-ea)))
      (<span style="color: #a020f0;">catch</span> Exception e
        (out <span style="color: #bc8f8f;">"caught exception %s"</span> e)))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">filter-map</span> [f map]
  (<span style="color: #a020f0;">let</span> [vals (<span style="color: #da70d6;">mapcat</span> identity (<span style="color: #da70d6;">filter</span> (<span style="color: #da70d6;">fn</span> [[key val]]
                                        (f key)) map))]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> vals) {} (<span style="color: #da70d6;">apply</span> hash-map vals))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run</span>
  ([] (run *ns* {}))
  ([args] (run *ns* args))
  ([ns args] 
     <span style="color: #b22222;">;;</span><span style="color: #b22222;">todo: not default, no nil
</span>     (run-all (new-ea {<span style="color: #da70d6;">:ns</span> ns 
                       <span style="color: #da70d6;">:args</span> (filter-map #(<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">var?</span> %))
                                               (<span style="color: #da70d6;">not</span> (#{<span style="color: #da70d6;">:symbol</span> <span style="color: #da70d6;">:period</span>} %))) args)
                       <span style="color: #da70d6;">:vars</span> (filter-map var? args)
                       <span style="color: #da70d6;">:symbol</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">:symbol</span> args) (env <span style="color: #da70d6;">:symbol</span>))
                       <span style="color: #da70d6;">:period</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">:period</span> args) (env <span style="color: #da70d6;">:period</span>))}))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">sym</span> [] (<span style="color: #da70d6;">:symbol</span> *ea*))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">period</span> [] (<span style="color: #da70d6;">:period</span> *ea*))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: wait till it stops and delete
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">stop</span> [ea]
  (<span style="color: #a020f0;">let</span> [stop-it (<span style="color: #da70d6;">fn</span> [e]
                  (<span style="color: #a020f0;">if</span> (pid? (<span style="color: #da70d6;">:pid</span> e))
                    (<span style="color: #a020f0;">do</span> (! (<span style="color: #da70d6;">:pid</span> e) <span style="color: #bc8f8f;">"STOP"</span>) 
                        true)))]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">map?</span> ea)
      (stop-it ea)
      (<span style="color: #da70d6;">map</span> stop-it ea))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">clear-eas</span> [] (<span style="color: #da70d6;">count</span> (<span style="color: #da70d6;">reset!</span> *eas* (<span style="color: #da70d6;">filter</span> alive? @*eas*))))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">SAVE/LOAD
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">save-eas</span>
  ([] (save-eas save-file 1000))
  ([save-file] (save-eas save-file 1000))
  ([save-file timeout]
     (debugging <span style="color: #bc8f8f;">"Save EA:"</span>
      (<span style="color: #a020f0;">try</span>
        (locking-write-timeout [*ea-pre-lock* (<span style="color: #a020f0;">or</span> timeout 1000)] 
                               (info <span style="color: #bc8f8f;">"saving ..."</span>)
                               (frm-save save-file @*eas*)
                               (<span style="color: #da70d6;">count</span> @*eas*))
        (<span style="color: #a020f0;">catch</span> Exception e
          (warn <span style="color: #bc8f8f;">"failed to save eas %s"</span> e))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">load-eas</span> 
  ([] (load-eas save-file false))
  ([append] (load-eas save-file append))
  ([file append]
     (debugging <span style="color: #bc8f8f;">"Load EA:"</span>
      (<span style="color: #a020f0;">try</span>
        (<span style="color: #a020f0;">let</span> [eas (frm-load file)]
          (is? [(<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">empty?</span> eas) (every #(<span style="color: #da70d6;">instance?</span> EA %) eas))])
          (<span style="color: #a020f0;">if</span> append (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">swap!</span> *eas* concat eas) (<span style="color: #da70d6;">count</span> eas)) (<span style="color: #da70d6;">vec</span> eas)))
        (<span style="color: #a020f0;">catch</span> Exception e
          (warn <span style="color: #bc8f8f;">"failed to load eas %s %s: %s"</span> file append e))))))
</pre></div>


</div>

</div>

<div id="outline-container-4_4_3" class="outline-4">
<h4 id="sec-4_4_3"><span class="section-number-4">4.4.3</span> Error </h4>
<div class="outline-text-4" id="text-4_4_3">




<div class="org-src-container"><label class="org-src-name">error-common()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.module.error
     (<span style="color: #da70d6;">:clone</span> clj.core)
     (<span style="color: #da70d6;">:require</span> forex.backend.mql.socket-service)
     (<span style="color: #da70d6;">:require</span> [forex.backend.mql.socket-service <span style="color: #da70d6;">:as</span> s])
     (<span style="color: #da70d6;">:use</span> forex.util.general
           forex.util.core
           forex.util.emacs 
           forex.util.general))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">e?</span> [a]
  (<span style="color: #da70d6;">instance?</span> forex.backend.mql.socket-service.MqlError a))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">aif</span>
  ([test then] `(aif ~test ~then nil))
  ([test then else]
     `(<span style="color: #a020f0;">let</span> [~'it ~test] 
        (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">and</span> ~'it (<span style="color: #da70d6;">not</span> (e? ~'it)))
          ~then
          ~else)))) 
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">awhen</span> [test &amp; body] `(aif ~test (<span style="color: #a020f0;">do</span> ~@body)))
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">aif-not</span> 
  ([test then] `(aif-not ~test ~then nil))
  ([test then else]
     `(<span style="color: #a020f0;">let</span> [~'it ~test]
        (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">not</span> (<span style="color: #a020f0;">and</span> ~'it (<span style="color: #da70d6;">not</span> (e? ~'it))))
          ~then
          ~else)))) 
(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">awhen-not</span> [test &amp; body] `(aif-not ~test (<span style="color: #a020f0;">do</span> ~@body)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">receive with errors
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">receive!</span>
  ([msg] (receive! msg nil))
  ([msg try]
     (<span style="color: #a020f0;">loop</span> [retries 0]
       (<span style="color: #a020f0;">let</span> [result (s/receive msg)]
         (<span style="color: #a020f0;">if</span> (e? result)
           (<span style="color: #a020f0;">let</span> [e (<span style="color: #da70d6;">:e</span> result)]
            (<span style="color: #a020f0;">cond</span> 
             (<span style="color: #a020f0;">and</span> try (<span style="color: #da70d6;">&lt;</span> retries try) (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> e 4066) (<span style="color: #da70d6;">=</span> e 4054))) (<span style="color: #a020f0;">do</span> (Thread/sleep 300) (<span style="color: #a020f0;">recur</span> (<span style="color: #da70d6;">inc</span> retries)))
             true (throwf <span style="color: #bc8f8f;">"MQL error %s"</span> e)))
           result)))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">receive with default instead of errors, returns error object for errors
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">is customizable to default to errors!
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">receive</span>
  ([msg] (receive msg true))
  ([msg resend] (s/receive msg resend)))
</pre></div>


</div>

</div>

<div id="outline-container-4_4_4" class="outline-4">
<h4 id="sec-4_4_4"><span class="section-number-4">4.4.4</span> Indicator </h4>
<div class="outline-text-4" id="text-4_4_4">




<div class="org-src-container"><label class="org-src-name">indicator-common()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.module.indicator
  (<span style="color: #da70d6;">:clone</span> clj.core)
  (<span style="color: #da70d6;">:use</span>
   forex.util.core
   forex.util.general
   forex.module.account.utils
   forex.module.error)   
  (<span style="color: #da70d6;">:require</span> [forex.module.error <span style="color: #da70d6;">:as</span> s]))

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+m1+</span> 1)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+m5+</span> 5)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+m15+</span> 15)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+h1+</span> 60)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+h4+</span> 240)
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">+d1+</span> (<span style="color: #da70d6;">*</span> 24 +h1+))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">cross?</span>
  ([signal main] (cross? signal main 0))
  ([signal main i]
     (<span style="color: #a020f0;">let</span> [i1 (<span style="color: #da70d6;">+</span> i 1) i2 (<span style="color: #da70d6;">+</span> i 2)
           a1 (signal i1) a2 (signal i2)
           b1 (<span style="color: #228b22;">main</span> i1) b2 (<span style="color: #228b22;">main</span> i2)] 
       (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&gt;</span> a1 b1) (<span style="color: #da70d6;">&lt;</span> a2 b2) [<span style="color: #da70d6;">:buy</span> i])
           (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&lt;</span> a1 b1) (<span style="color: #da70d6;">&gt;</span> a2 b2) [<span style="color: #da70d6;">:sell</span> i])
           nil))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">env?</span> [] (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">string?</span> (env <span style="color: #da70d6;">:symbol</span>)) (<span style="color: #da70d6;">integer?</span> (env <span style="color: #da70d6;">:period</span>))))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">&gt;?</span> [a] (<span style="color: #a020f0;">or</span> (zero? a) (<span style="color: #da70d6;">pos?</span> a)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">high low open close
</span>(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">off</span> [a] (<span style="color: #da70d6;">+</span> (<span style="color: #a020f0;">or</span> (env <span style="color: #da70d6;">:i</span>) 0) a))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">receive-double!</span>
  ([a] (receive-double! a 3))
  ([a retries] {<span style="color: #da70d6;">:pre</span> (env?)} (<span style="color: #da70d6;">double</span> (<span style="color: #da70d6;">first</span> (receive! a retries))))) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">high</span>
  ([] (high 0))    
  ([i] (receive-double! (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"iHigh %s %s %s 1"</span> (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>) (off i)))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">open</span>  
  ([] (open 0)) 
  ([i] (receive-double! (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"iOpen %s %s %s 1"</span> (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>) (off i)))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">low</span>
  ([] (low 0))
  ([i] (receive-double! (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"iLow %s %s %s 1"</span> (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>) (off i)))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">close</span>
  ([] (close 0))
  ([i] (receive-double! (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"iClose %s %s %s 1"</span> (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>) (off i)))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: change
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ask</span>
  ([] (ask (env <span style="color: #da70d6;">:symbol</span>)))
  ([symbol] (aif (mode-ask symbol)
                 it (throwf <span style="color: #bc8f8f;">"MQL error %s"</span> (<span style="color: #da70d6;">:e</span> it)))))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">bid==close 
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">bid</span>
  ([] (bid (env <span style="color: #da70d6;">:symbol</span>)))
  ([symbol] (aif (mode-bid symbol) it (throwf <span style="color: #bc8f8f;">"MQL error %s"</span> (<span style="color: #da70d6;">:e</span> it)))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">an example of acessing a custom ea
</span>

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">moving-averages</span>
  ([method] (<span style="color: #da70d6;">fn</span>
              ([period] (moving-averages method period))
              ([period offset] (moving-averages method period offset))))
  ([method period] (moving-averages method period 0))
  ([method period offset]
     {<span style="color: #da70d6;">:pre</span> [(env?)  (&gt;? offset)
            (<span style="color: #da70d6;">number?</span> method) (&gt;? period)]}
     (receive-double! 
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Default_Moving_Averages %s %s %s %s 1 %s 0 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>) <span style="color: #b22222;">;;</span><span style="color: #b22222;">period/method
</span>              0 (off offset) period method)
      3))) 
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">sma</span> (moving-averages 0))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">ema</span> (moving-averages 1))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">smma</span> (moving-averages 2))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">lwma</span> (moving-averages 3))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">todo - check for valif params - above 1?
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">psar</span>
  <span style="color: #bc8f8f;">"step (0.02), maximum 0.2"</span>
  ([params] (psar params 0))
  ([params offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset)  (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">count</span> params) 2)]}
     (receive-double!
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Default_Parabolic %s %s %s %s 1 %s %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              0 (off offset) (<span style="color: #da70d6;">first</span> params) (<span style="color: #da70d6;">second</span> params))
      3)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">cci</span>
  ([period] (cci period 0))
  ([period offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset)  (<span style="color: #da70d6;">number?</span> period)]}
     (receive-double!
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Default_CCI %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              0 (off offset) period)
      3)))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">momentum</span>
  ([period] (momentum period 0))
  ([period offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset)  (<span style="color: #da70d6;">number?</span> period)]}
     (receive-double!
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Default_Momentum %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              0 (off offset) period)
      3)))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">atr</span>
  ([period] (atr period 0))
  ([period offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset) (<span style="color: #da70d6;">number?</span> period)]}
     (receive-double! 
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Default_ATR %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              0 (off offset) period)
      3)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">rsi</span>
  ([period] (rsi period 0))
  ([period offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset) (<span style="color: #da70d6;">number?</span> period)]}
     (receive-double! 
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Default_RSI %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              0 (off offset) period)
      3)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">vma</span>
  ([params] (vma params 0))
  ([params offset]
     {<span style="color: #da70d6;">:pre</span> [(env?)  (&gt;? offset) (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">count</span> params) 4)]}
     (receive-double! 
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Custom_FantailVMA3 %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              0 (off offset) (<span style="color: #da70d6;">apply</span> str (<span style="color: #da70d6;">interpose</span> <span style="color: #bc8f8f;">" "</span> params)))
      3)))


(<span style="color: #a020f0;">defmacro-</span> <span style="color: #0000ff;">indicator-fn</span> [[params index] &amp; body]
  `(<span style="color: #da70d6;">fn</span> <span style="color: #0000ff;">a</span>#
     ([~params] (a# ~params 0))
     ([~params ~index]
        ~@body)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">rsi-black</span> 
  ([params] (<span style="color: #da70d6;">fn</span> 
              ([mode offset] (rsi-black params mode offset))
              ([offset] (rsi-black params 0 offset))))
  ([params mode] (<span style="color: #da70d6;">fn</span>
                   ([offset] (rsi-black params mode offset))
                   ([] (rsi-black params mode  0))))
  ([params mode offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset) (&gt;? mode) 
            (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">count</span> params) 5)]}
     (receive-double! 
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Custom_Rsi_BlackFeet_modded %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              mode (off offset) (<span style="color: #da70d6;">apply</span> str (<span style="color: #da70d6;">interpose</span> <span style="color: #bc8f8f;">" "</span> params)))
      3)))

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">rsi-black-signal</span>
  (indicator-fn [params index]
                (rsi-black params 1
                               index)))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">rsi-black-main</span>
  (indicator-fn [params index]
                (rsi-black params 0 index)))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">blazan-dynamic-stop</span>
  ([params] (<span style="color: #da70d6;">fn</span> 
              ([mode offset] (blazan-dynamic-stop params mode offset))
              ([offset] (blazan-dynamic-stop params 0 offset))))
  ([params mode] (<span style="color: #da70d6;">fn</span>
                   ([offset] (blazan-dynamic-stop params mode offset))
                   ([] (blazan-dynamic-stop params mode  0))))
  ([params mode offset]
     {<span style="color: #da70d6;">:pre</span> [(env?) (&gt;? offset) (&gt;? mode) 
            (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">count</span> params) 4)]}
     (receive-double! 
      (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Custom_Blazan_Dynamic_Stop %s %s %s %s 1 %s"</span>
              (env <span style="color: #da70d6;">:symbol</span>) (env <span style="color: #da70d6;">:period</span>)
              mode (off offset) (<span style="color: #da70d6;">apply</span> str (<span style="color: #da70d6;">interpose</span> <span style="color: #bc8f8f;">" "</span> params)))
      3)))



(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">hit?</span> [order val]
  (<span style="color: #a020f0;">cond</span>
   (sell? order)
   (<span style="color: #da70d6;">&lt;=</span> (close) val)
   (buy? order)
   (<span style="color: #da70d6;">&gt;=</span> (close) val )
   true (throwf <span style="color: #bc8f8f;">"invalid order type %s"</span> order)))



(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">risk</span>
  ([percent sl] (risk percent sl (close)))
  ([percent sl price] (risk percent sl price (env <span style="color: #da70d6;">:symbol</span>)))
  ([percent sl price symbol]
     (wenv {<span style="color: #da70d6;">:symbol</span> symbol}
      (lot (<span style="color: #da70d6;">*</span> 0.1 (<span style="color: #da70d6;">/</span> (<span style="color: #da70d6;">*</span> (<span style="color: #da70d6;">/</span> percent 100) (account-balance))
                     (point (Math/abs (<span style="color: #da70d6;">-</span> price sl)))))))))
</pre></div>


</div>
</div>

</div>

<div id="outline-container-4_5" class="outline-3">
<h3 id="sec-4_5"><span class="section-number-3">4.5</span> Interface </h3>
<div class="outline-text-3" id="text-4_5">




<div class="org-src-container"><label class="org-src-name">interface-ea-new()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: still a work in progress. for now, lets just execute a function in user
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">ea ns, and that function will prompt user and run ea!
</span>
(<span style="color: #a020f0;">ns</span> forex.interface.ea-new
  (<span style="color: #da70d6;">:use</span> forex.util.log clojure.contrib.with-ns
        forex.module.ea
        clojure.contrib.miglayout forex.util.emacs 
        forex.util.gui)
  (<span style="color: #da70d6;">:use</span> forex.interface.gui) 
  (<span style="color: #da70d6;">:import</span> 
   (java.awt Dimension Font event.MouseListener
             event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
   (javax.swing JComboBox JPopupMenu JMenuItem
                ImageIcon
                table.AbstractTableModel 
                JScrollPane JTable
                JFrame JPanel JTextField JLabel JButton
                SwingUtilities)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ns-args</span> [ns]
  (ns-metas ns (<span style="color: #da70d6;">fn</span> [s] (<span style="color: #da70d6;">:arg</span> (<span style="color: #da70d6;">meta</span> s)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ea-new-gui</span> []
  (<span style="color: #a020f0;">when-let</span> [it (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">:selector</span> gui)
                     (.getSelectedItem (<span style="color: #da70d6;">:selector</span> gui)))]
    (<span style="color: #a020f0;">when-let</span> [ns (<span style="color: #da70d6;">find-ns</span> (<span style="color: #da70d6;">symbol</span> it))]
      (<span style="color: #da70d6;">println</span> <span style="color: #bc8f8f;">"selection is "</span> ns))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">var-name</span> [a]
  (<span style="color: #da70d6;">last</span> (.split (<span style="color: #da70d6;">str</span> a) <span style="color: #bc8f8f;">"/"</span>)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: throw slot value not working!s + add metadata to jlabel,etc
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">read-eval</span> [a]
  (<span style="color: #a020f0;">let</span> [a (<span style="color: #a020f0;">try</span> (<span style="color: #da70d6;">read-string</span> (.getText a))
               (<span style="color: #a020f0;">catch</span> Exception e (.getText a)))]
    (<span style="color: #a020f0;">if</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">string?</span> a) (<span style="color: #da70d6;">symbol?</span> a)) (<span style="color: #da70d6;">str</span> a) (<span style="color: #da70d6;">eval</span> a))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-start</span> [frame panel]
  (<span style="color: #da70d6;">println</span> <span style="color: #bc8f8f;">"result is "</span> (<span style="color: #da70d6;">keys</span> (components panel))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">generate-ea-gui</span> [ns] 
  (<span style="color: #a020f0;">let</span> [args (ns-args ns)
        panel (JPanel.) frame (jframe (<span style="color: #da70d6;">str</span> (<span style="color: #da70d6;">ns-name</span> ns)))]
    (<span style="color: #a020f0;">doto</span> frame
      (.add (<span style="color: #da70d6;">apply</span> miglayout panel
                   (<span style="color: #da70d6;">concat</span>
                    (<span style="color: #da70d6;">mapcat</span> (<span style="color: #da70d6;">fn</span> [[key val]]
                              (<span style="color: #a020f0;">let</span> [label (JLabel. (var-name key))]
                                [label (JTextField. 30)         
                                 <span style="color: #da70d6;">:wrap</span>]))
                            args)
                    [(<span style="color: #a020f0;">doto</span> (JButton. <span style="color: #bc8f8f;">"start"</span>)
                       (add-action-listener (<span style="color: #da70d6;">fn</span> [e] (on-start frame panel))))
                     <span style="color: #bc8f8f;">"push,growx,span,center"</span>])))
      (.pack)
      (.setVisible true)))) 

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">run-init-gui</span> []
  (<span style="color: #a020f0;">let</span> [ns (<span style="color: #da70d6;">symbol</span> (.getSelectedItem (<span style="color: #da70d6;">:selector</span> gui)))]
   (<span style="color: #a020f0;">if-let</span> [it (<span style="color: #da70d6;">get</span> (<span style="color: #da70d6;">ns-map</span> ns) 'init-gui)]
     (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">fn?</span> (<span style="color: #da70d6;">var-get</span> it))
       (<span style="color: #a020f0;">binding</span> [*ns* (<span style="color: #da70d6;">the-ns</span> ns)]
         ((<span style="color: #da70d6;">var-get</span> it))) 
       (inform <span style="color: #bc8f8f;">"symbol init-gui in namespace %s is not a function"</span> ns ))
     (inform <span style="color: #bc8f8f;">"%s does not have an init-gui function"</span> ns)))) 

(<span style="color: #da70d6;">alter-var-root</span>
 #'forex.interface.gui/gui-key-map
 merge {\n #'run-init-gui})
</pre></div>






<div class="org-src-container"><label class="org-src-name">interface-ea-table()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.interface.ea-table
  (<span style="color: #da70d6;">:require</span> swank.swank) 
  (<span style="color: #da70d6;">:use</span> forex.util.log 
        clojure.contrib.miglayout forex.util.emacs 
        forex.util.gui forex.interface.tray)
  (<span style="color: #da70d6;">:use</span> forex.module.ea forex.interface.gui)
  (<span style="color: #da70d6;">:import</span>
   (java.awt
    Dimension Font event.MouseListener
    event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
   (javax.swing JComboBox JPopupMenu JMenuItem
                ImageIcon
                table.AbstractTableModel 
                JScrollPane JTable
                JFrame JPanel JTextField JLabel JButton
                SwingUtilities))) 

(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">ea-table-gui</span>  nil)
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">italic</span> [a] (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"&lt;html&gt;&lt;i&gt;%s&lt;/i&gt;&lt;html&gt;"</span> a))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">color</span> [a color]
  (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"&lt;html&gt;&lt;color=%s&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/color&gt;&lt;html&gt;"</span> color a))




(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">table-model</span> [titles data]
  (<span style="color: #da70d6;">proxy</span> [AbstractTableModel] []
    (getRowCount [] (<span style="color: #da70d6;">count</span> data))
    (getColumnCount [] (<span style="color: #da70d6;">count</span> titles))
    (getValueAt [row column] (<span style="color: #da70d6;">nth</span> (<span style="color: #da70d6;">nth</span> data  row) column))
    (getColumnClass [_] String)
    (getColumnName [col] (<span style="color: #da70d6;">nth</span> titles col))))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ea-table-model</span> [eas] 
  (table-model
   [(italic <span style="color: #bc8f8f;">"Name"</span>) (italic <span style="color: #bc8f8f;">"Symbol"</span>) (italic <span style="color: #bc8f8f;">"Period"</span>) (italic <span style="color: #bc8f8f;">"Running?"</span>) (italic <span style="color: #bc8f8f;">"Args"</span>)]
   (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [ea] 
          [(<span style="color: #da70d6;">:type</span> ea) (<span style="color: #da70d6;">:symbol</span> ea) (<span style="color: #da70d6;">:period</span> ea)
           (<span style="color: #a020f0;">let</span> [exit @(<span style="color: #da70d6;">:exit</span> ea)]
             (<span style="color: #a020f0;">cond</span>
              (<span style="color: #a020f0;">and</span> (alive? ea) (<span style="color: #da70d6;">=</span> exit false)) (color true <span style="color: #bc8f8f;">"blue"</span>)
              true  (<span style="color: #a020f0;">if-not</span> (<span style="color: #da70d6;">=</span> true  exit)
                      (color false <span style="color: #bc8f8f;">"red"</span>)
                      false)))
           (<span style="color: #da70d6;">:args</span> ea)
           ea])
        eas)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">update-table</span> [table eas]
  (<span style="color: #da70d6;">locking</span> table
   (.setModel table (ea-table-model eas))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">update-ea-table</span>
  ([] (update-ea-table false))
  ([force]
     (<span style="color: #a020f0;">let</span> [{<span style="color: #da70d6;">:keys</span> [table frame]} ea-table-gui]
       (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">and</span> table frame (<span style="color: #a020f0;">or</span> force (.isVisible frame))) 
         (update-table table @*eas*)))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-ea-table-watch</span> []
  (add-hook #'ea-on-start-hook #'update-ea-table)
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODOD: better add-to-list, not repeat, maybe per *ns*?
</span>  (add-hook #'ea-on-exit-hook #'update-ea-table)
  (<span style="color: #ff0000; font-weight: bold;">add-watcher</span> *eas* <span style="color: #bc8f8f;">"table update"</span> (<span style="color: #da70d6;">fn</span> [&amp; args]
                                      (update-ea-table))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">gui-new-table</span> [frame]
  (<span style="color: #a020f0;">let</span> [eas @*eas*
        table (JTable. (ea-table-model eas))
        panel
        (miglayout (JPanel.)
                   (JScrollPane. table) 
                   <span style="color: #bc8f8f;">"span,grow"</span> <span style="color: #da70d6;">:wrap</span> 
                   (<span style="color: #a020f0;">doto</span>  (JButton. <span style="color: #bc8f8f;">"refresh"</span>)
                     (add-action-listener
                      (<span style="color: #da70d6;">fn</span> [e] (update-table table @*eas*))))
                   (<span style="color: #a020f0;">doto</span> (JButton. <span style="color: #bc8f8f;">"stop"</span>)
                     (add-action-listener
                      (<span style="color: #da70d6;">fn</span> [e]
                        <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: locking on a table is bad if youre going to have a prompt - will lock up stopping of eas, etc. x
</span>                        (<span style="color: #da70d6;">locking</span> table 
                          (<span style="color: #a020f0;">let</span> [i (.getSelectedRow table)
                                ea (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">&gt;=</span> i 0) (.getValueAt (.getModel table)
                                                               i (.getColumnCount table)))]
                            (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&gt;=</span> i 0)
                                       (prompt <span style="color: #bc8f8f;">"do you really want to stop ea %s"</span> i))
                              (stop ea))))))) 
                   (<span style="color: #a020f0;">doto</span> (JButton. <span style="color: #bc8f8f;">"clear"</span>)
                     (add-action-listener
                      (<span style="color: #da70d6;">fn</span> [e]
                        (<span style="color: #a020f0;">when</span> (prompt <span style="color: #bc8f8f;">"Do you really want to clear stopped eas?"</span> true)
                          (update-table
                           table
                           (<span style="color: #da70d6;">swap!</span> *eas* (<span style="color: #da70d6;">fn</span> [old]
                                          (<span style="color: #da70d6;">filter</span> alive? old)))))))))]
    (<span style="color: #da70d6;">alter-var-root</span>  #'ea-table-gui (<span style="color: #da70d6;">constantly</span> {<span style="color: #da70d6;">:table</span> table <span style="color: #da70d6;">:frame</span> frame}))
    panel))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">display-ea-table</span> []
  (<span style="color: #a020f0;">if-not</span> (<span style="color: #da70d6;">:frame</span> ea-table-gui)
    (<span style="color: #a020f0;">let</span> [frame (jframe <span style="color: #bc8f8f;">"expert advisors"</span>)]
      (<span style="color: #a020f0;">doto</span> frame 
        (.add (gui-new-table frame))
        (.pack)
        (.setVisible true))
      (add-ea-table-watch))
    (<span style="color: #a020f0;">do</span> (update-ea-table true) 
        (.setVisible (<span style="color: #da70d6;">:frame</span> ea-table-gui) true))))

(<span style="color: #da70d6;">alter-var-root</span>
 #'forex.interface.gui/gui-key-map
 merge {\v #'display-ea-table})
</pre></div>




<div class="org-src-container"><label class="org-src-name">interface-gui()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">(clojure.core/use 'nstools.ns)
</span>(<span style="color: #a020f0;">ns</span> forex.interface.gui
  (<span style="color: #da70d6;">:require</span> swank.swank)  
  (<span style="color: #da70d6;">:use</span>
   forex.util.general
   forex.util.log
   forex.module.ea forex.util.general
   clojure.contrib.miglayout forex.util.emacs 
   forex.util.gui forex.interface.tray)
  (<span style="color: #da70d6;">:import</span> 
   (java.awt Dimension Font event.MouseListener
             event.MouseAdapter Toolkit event.ActionListener event.KeyListener)
   (javax.swing JComboBox JPopupMenu JMenuItem
                ImageIcon SwingConstants
                table.AbstractTableModel 
                JScrollPane JTable
                JFrame JPanel JTextField JLabel JButton JFileChooser
                SwingUtilities)))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: all action listeners should be vars for maximum flexibility - because sometimes it all goes away!
</span>
<span style="color: #b22222;">;;</span><span style="color: #b22222;">Useful User Vars
</span>(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">gui</span> nil) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">message</span> [msg &amp; args]
  (<span style="color: #a020f0;">when-let</span> [it (<span style="color: #da70d6;">:status</span> gui)]
    (.setText it (<span style="color: #da70d6;">apply</span> format msg args))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">LOADING EAS
</span>(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">prev-load-file</span> (<span style="color: #da70d6;">atom</span> nil))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-load-eas</span> []
  (<span style="color: #a020f0;">let</span> [fileopen (<span style="color: #a020f0;">if</span> @prev-load-file (JFileChooser. @prev-load-file) (JFileChooser.))
        ret (.showDialog fileopen nil <span style="color: #bc8f8f;">"Load"</span>)] 
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> ret JFileChooser/APPROVE_OPTION)
      (<span style="color: #a020f0;">let</span> [file (.getSelectedFile fileopen)]
        (with-out-str+ out (<span style="color: #a020f0;">if-let</span> [it (load-eas file true)] (message <span style="color: #bc8f8f;">"loaded %s eas"</span> it) (inform (<span style="color: #da70d6;">str</span> out))))
        (<span style="color: #da70d6;">reset!</span> prev-load-file (.getParentFile file))))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">SAVING EAS
</span>(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">prev-save-file</span> (<span style="color: #da70d6;">atom</span> nil))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-save-eas</span> []
  (message <span style="color: #bc8f8f;">"saving ..."</span>)
  (<span style="color: #a020f0;">let</span> [fileopen
        (<span style="color: #a020f0;">if</span> @prev-save-file (JFileChooser. @prev-save-file) (JFileChooser.))
        ret (.showDialog fileopen nil <span style="color: #bc8f8f;">"Save"</span>)]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> ret JFileChooser/APPROVE_OPTION)
      (<span style="color: #a020f0;">let</span> [file (.getSelectedFile fileopen)]
        (<span style="color: #da70d6;">reset!</span> prev-save-file (.getParentFile file))
        (<span style="color: #a020f0;">if-let</span> [it (save-eas file)]
          (message <span style="color: #bc8f8f;">"saved %s eas"</span> it)
          (inform <span style="color: #bc8f8f;">"unable to acquire ea write lock in order to save all eas"</span>)))))) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-log</span> []
  (message <span style="color: #bc8f8f;">"open log file @ %s/.forex/"</span> (System/getProperty <span style="color: #bc8f8f;">"user.home"</span>))) 
<span style="color: #b22222;">;;</span><span style="color: #b22222;">User Customization
</span>(defhook gui-on-exit-hooks) 
(defhook gui-create-pre-hook)
(defhook gui-create-post-hook)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">swank-port</span> 4005) 
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">gui-image</span> <span style="color: #bc8f8f;">"pictures/clojure.gif"</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">gui-icon-image</span> <span style="color: #bc8f8f;">"pictures/clojure.gif"</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">gui-window-image</span> <span style="color: #bc8f8f;">"pictures/clojure.gif"</span>)

(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">gui-key-map</span> 
  {\l #'on-log  
   \s 
   #(<span style="color: #a020f0;">do</span>
      (swank.swank/start-repl swank-port)
      (message <span style="color: #bc8f8f;">"started swank on port %s"</span> swank-port))})
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-restart-eas</span> []
  (<span style="color: #a020f0;">dorun</span> (<span style="color: #da70d6;">map</span> restart @*eas*))
  (message <span style="color: #bc8f8f;">"restarted %s eas"</span> (<span style="color: #da70d6;">count</span> @*eas*))) 
(<span style="color: #a020f0;">defvar</span>
  <span style="color: #0000ff;">gui-menu-items</span>
  [{<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"new ea"</span> <span style="color: #da70d6;">:key</span> \n}
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"save eas"</span> <span style="color: #da70d6;">:action</span> #'on-save-eas}
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"load eas"</span> <span style="color: #da70d6;">:action</span> #'on-load-eas}
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"view eas"</span> <span style="color: #da70d6;">:key</span> \v} 
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"log"</span> <span style="color: #da70d6;">:key</span> \l <span style="color: #da70d6;">:action</span> #'on-log}
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"start swank"</span> <span style="color: #da70d6;">:key</span> \s}
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"restart eas"</span> <span style="color: #da70d6;">:key</span> \r <span style="color: #da70d6;">:action</span> #'on-restart-eas} 
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"load forex-user"</span> 
    <span style="color: #da70d6;">:action</span> #(<span style="color: #a020f0;">try</span>       
               (message <span style="color: #bc8f8f;">"loading ..."</span>)
               (<span style="color: #da70d6;">require</span> <span style="color: #da70d6;">:reload</span> 'forex-user)
               (message <span style="color: #bc8f8f;">"loaded forex-user"</span>)
               (<span style="color: #a020f0;">catch</span> Exception e
                 (message <span style="color: #bc8f8f;">"failed to load forex-user"</span>)
                 (inform <span style="color: #bc8f8f;">"failed to load forex-user %s"</span> e)))}
   {<span style="color: #da70d6;">:name</span> <span style="color: #bc8f8f;">"preferences"</span> <span style="color: #da70d6;">:key</span> \p}])
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">gui-frame-title</span> <span style="color: #bc8f8f;">"clj-forex"</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">gui-reminder-visible</span> true) 
<span style="color: #b22222;">;;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">jframe</span> [title]
  (<span style="color: #a020f0;">doto</span>
      (JFrame. title)
    (.setIconImage (create-image gui-window-image))))

(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">get-fn</span> [a] (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">var?</span> a) (<span style="color: #da70d6;">var-get</span> a) a))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-key</span> [e] 
  (<span style="color: #a020f0;">when-let</span> [it (get-fn (<span style="color: #da70d6;">get</span> gui-key-map (.getKeyChar e)))]
    (<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">fn?</span> it) (it))
         (<span style="color: #a020f0;">catch</span> Exception e
           (.printStackTrace e)
           (severe e))))) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-menu-item</span> [parent {<span style="color: #da70d6;">:keys</span> [name key action]}]
  (<span style="color: #a020f0;">let</span> [item (JMenuItem. (<span style="color: #da70d6;">str</span> name <span style="color: #bc8f8f;">" ("</span> key <span style="color: #bc8f8f;">")"</span>))]
    (add-action-listener 
     item (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">not</span> action) (<span style="color: #da70d6;">bound-fn</span>
                                 [e]
                                 (<span style="color: #a020f0;">let</span> [key-map-fn (get-fn (<span style="color: #da70d6;">get</span> gui-key-map key))]
                                   (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">fn?</span> key-map-fn) (key-map-fn)))))
              (<span style="color: #da70d6;">bound-fn</span> [e] (thread (action))))) <span style="color: #b22222;">;;</span><span style="color: #b22222;">no e
</span>    (.add parent item)
    item)) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-popup</span> [e] 
  (<span style="color: #a020f0;">try</span>
    (<span style="color: #a020f0;">let</span> [menu (JPopupMenu.)]
      (<span style="color: #a020f0;">dorun</span> (<span style="color: #da70d6;">map</span> #(add-menu-item menu %) gui-menu-items))
      (.show menu
             (.getComponent e)
             (.getX e) (.getY e)))
    (<span style="color: #a020f0;">catch</span> Exception e (<span style="color: #da70d6;">println</span> e))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-exit</span> [icon] 
  (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">empty?</span> gui-on-exit-hooks)
    (remove-system-icon icon)
    (run-hook-with-args gui-on-exit-hooks icon)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-click</span> [icon]
  (.setVisible (<span style="color: #da70d6;">:frame</span> gui) true))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">gui-make-icon</span> []
  (system-icon
   {<span style="color: #da70d6;">:image</span> gui-icon-image
    <span style="color: #da70d6;">:on-click</span>  on-click 
    <span style="color: #da70d6;">:on-exit</span> on-exit}))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">new-gui</span> []
  (<span style="color: #da70d6;">alter-var-root</span> #'gui (<span style="color: #da70d6;">constantly</span> nil))
  (run-hooks gui-create-pre-hook)
  (<span style="color: #a020f0;">let</span> [icon (gui-make-icon)
        image (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">string?</span> gui-image) (create-icon gui-image))
        panel
        (<span style="color: #a020f0;">doto</span> (miglayout  
               (JPanel.)  <span style="color: #da70d6;">:column</span> <span style="color: #bc8f8f;">"center"</span> 
               (JLabel. (<span style="color: #a020f0;">if</span> image image <span style="color: #bc8f8f;">""</span>))  <span style="color: #bc8f8f;">"width 245!"</span> <span style="color: #bc8f8f;">"span,growx,pushx"</span> <span style="color: #da70d6;">:wrap</span> 
               (JComboBox. (<span style="color: #da70d6;">into-array</span> String @*ea-registry*))
               {<span style="color: #da70d6;">:id</span> <span style="color: #da70d6;">:selector</span>} <span style="color: #bc8f8f;">"span,growx,pushx"</span>  <span style="color: #da70d6;">:wrap</span>
               (<span style="color: #a020f0;">doto</span> (JLabel. <span style="color: #bc8f8f;">"&lt;html&gt;n = new ea&lt;br&gt;v = view eas&lt;br&gt;l = log&lt;br&gt;s = start swank&lt;html&gt;"</span>) (.setHorizontalAlignment SwingConstants/CENTER))

               {<span style="color: #da70d6;">:id</span> <span style="color: #da70d6;">:reminder</span>} <span style="color: #da70d6;">:wrap</span>
               (<span style="color: #a020f0;">doto</span> (JLabel. <span style="color: #bc8f8f;">""</span>)
                 (.setFont (Font. <span style="color: #bc8f8f;">"SansSerif"</span> Font/ITALIC 12)))
               {<span style="color: #da70d6;">:id</span> <span style="color: #da70d6;">:status</span>} <span style="color: #bc8f8f;">"h 20!"</span> <span style="color: #bc8f8f;">"growx,align left,span"</span>))  
        frame (<span style="color: #a020f0;">doto</span> (jframe gui-frame-title)
                (.setDefaultCloseOperation JFrame/HIDE_ON_CLOSE) 
                (.add panel)
                (.pack)) 
        {<span style="color: #da70d6;">:keys</span> [selector reminder view]} (components panel)] 
    (<span style="color: #a020f0;">when-not</span> gui-reminder-visible (.setVisible reminder false))
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">(add-action-listener selector (bound-fn* on-selector))
</span>    (<span style="color: #a020f0;">dorun</span> (<span style="color: #da70d6;">map</span> (<span style="color: #da70d6;">fn</span> [obj]
                  (add-key-listener obj #'on-key)
                  (add-popup-listener obj #'on-popup))
                (<span style="color: #da70d6;">conj</span> (<span style="color: #da70d6;">vals</span> (components panel)) panel)))
    (<span style="color: #da70d6;">alter-var-root</span>  #'gui (<span style="color: #da70d6;">constantly</span> (<span style="color: #da70d6;">merge</span> (components panel) {<span style="color: #da70d6;">:frame</span> frame <span style="color: #da70d6;">:panel</span> panel <span style="color: #da70d6;">:icon</span> icon})))
    (run-hooks gui-create-post-hook)
    frame))


(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-ea-registry-watch</span> []
  (<span style="color: #ff0000; font-weight: bold;">add-watcher</span>
   *ea-registry* <span style="color: #bc8f8f;">"registry-add"</span>
   (<span style="color: #da70d6;">fn</span> [key ref old new] 
     (<span style="color: #a020f0;">when-let</span> [it (<span style="color: #da70d6;">:selector</span> gui)]
       (.removeAllItems it)
       (<span style="color: #a020f0;">dorun</span> (<span style="color: #da70d6;">map</span> #(.addItem it %) new))))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">invoke-new-gui</span>
  ([] (invoke-new-gui <span style="color: #bc8f8f;">""</span>))
  ([msg] 
     (invoke-later
      (<span style="color: #a020f0;">when-let</span> [it (<span style="color: #da70d6;">:icon</span> gui)]
        (remove-system-icon it))
      (<span style="color: #a020f0;">when-let</span> [it (<span style="color: #da70d6;">:frame</span> gui)]
        (.setVisible it false))
      (new-gui)
      (.setVisible (<span style="color: #da70d6;">:frame</span> gui) true) 
      (add-system-icon (<span style="color: #da70d6;">:icon</span> gui)) 
      (<span style="color: #a020f0;">when</span> msg (message msg))
      (add-ea-registry-watch))))
</pre></div>






<div class="org-src-container"><label class="org-src-name">interface-main()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.interface.main
  (<span style="color: #da70d6;">:require</span> swank.swank)
  (<span style="color: #da70d6;">:use</span> forex.interface.gui forex.interface.ea-table forex.interface.ea-new)
  (<span style="color: #da70d6;">:use</span> forex.util.emacs forex.util.gui forex.interface.tray))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">on-system-exit</span> [icon]
  (<span style="color: #a020f0;">when</span> (prompt (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"Do you really want to exit %s?
This will stop all running expert advisors."</span> gui-frame-title))
    (System/exit 0)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">-main</span> [&amp; args]
  (<span style="color: #a020f0;">let</span> [user-exception 
        (<span style="color: #a020f0;">try</span>
          (<span style="color: #da70d6;">require</span> 'forex-user) 
          nil
          (<span style="color: #a020f0;">catch</span> Exception e 
            (.printStackTrace e)
            e))] 
    (add-to-list  
     #'gui-on-exit-hooks on-system-exit)
    (invoke-new-gui (<span style="color: #a020f0;">when</span> user-exception <span style="color: #bc8f8f;">"error when loading forex-user: check log"</span>))))
</pre></div>




<div class="org-src-container"><label class="org-src-name">interface-tray()</label><pre class="src src-clojure">
(<span style="color: #a020f0;">ns</span> forex.interface.tray
  (<span style="color: #da70d6;">:use</span> forex.util.gui)
  (<span style="color: #da70d6;">:import</span>                        
   (javax.swing JFrame)
   (java.awt Toolkit SystemTray  EventQueue TrayIcon TrayIcon$MessageType PopupMenu MenuItem)
   (java.awt.event ActionListener)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">remove-system-icon</span> [icon] (.remove (SystemTray/getSystemTray) icon))
(<span style="color: #a020f0;">defn-</span> <span style="color: #0000ff;">setup-popup-menu</span>
  ([menu icon] (setup-popup-menu menu icon (<span style="color: #da70d6;">constantly</span> true)))
  ([menu icon on-exit]
     (<span style="color: #a020f0;">let</span> [exit (MenuItem. <span style="color: #bc8f8f;">"Exit"</span>)]
       (add-action-listener
        exit (<span style="color: #a020f0;">if</span> on-exit
               (<span style="color: #da70d6;">bound-fn</span> [e] (<span style="color: #a020f0;">try</span>
                               (on-exit icon)
                               (<span style="color: #a020f0;">catch</span> Exception e
                                 (.printStackTrace e)
                                 (<span style="color: #da70d6;">println</span> <span style="color: #bc8f8f;">"ERROR IN ON-EXIT %s"</span> e))))
               (<span style="color: #da70d6;">fn</span> [e] (remove-system-icon icon))))
       (.add menu exit)
       menu)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">system-icon</span> [{<span style="color: #da70d6;">:keys</span> [image on-exit on-click on-exit]}]
  {<span style="color: #da70d6;">:pre</span> [(<span style="color: #da70d6;">string?</span> image)]}
  (<span style="color: #a020f0;">let</span> [menu (PopupMenu.)
        tray-icon
        (<span style="color: #a020f0;">doto</span> (TrayIcon. (.getImage (Toolkit/getDefaultToolkit) image)
                         nil menu)
          (.setImageAutoSize true))]
    (setup-popup-menu menu tray-icon on-exit) 
    (<span style="color: #a020f0;">when</span> on-click (add-action-listener tray-icon (<span style="color: #da70d6;">bound-fn</span> [e] (<span style="color: #a020f0;">try</span> (on-click tray-icon) (<span style="color: #a020f0;">catch</span> Exception e (<span style="color: #da70d6;">println</span> <span style="color: #bc8f8f;">"ERROR IN ON-CLICK %s"</span> e))))))  
    tray-icon)) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">add-system-icon</span> [icon] (.add (SystemTray/getSystemTray) icon) icon)

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">icon-info</span>
  ([icon txt] (icon-info icon <span style="color: #bc8f8f;">"info"</span> txt))
  ([icon caption txt] (.displayMessage icon caption txt TrayIcon$MessageType/INFO)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">icon-warning</span>
  ([icon txt] (icon-warning icon <span style="color: #bc8f8f;">"warning"</span> txt))
  ([icon caption txt] (.displayMessage icon caption txt TrayIcon$MessageType/WARNING)))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">icon-error</span>
  ([icon txt] (icon-error icon <span style="color: #bc8f8f;">"error"</span> txt))
  ([icon caption txt] (.displayMessage icon caption txt TrayIcon$MessageType/ERROR)))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">(def icon (add-system-icon (system-icon {:image  "/home/seth/Desktop/clojure.gif" :on-click (fn [_] (println "HI"))})))
</span></pre></div>



</div>

</div>

<div id="outline-container-4_6" class="outline-3">
<h3 id="sec-4_6"><span class="section-number-3">4.6</span> User </h3>
<div class="outline-text-3" id="text-4_6">




<div class="org-src-container"><label class="org-src-name">forex_user()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: bug when no account is connected! yikes!
</span>
<span style="color: #b22222;">;;</span><span style="color: #b22222;">forex_user is the ns in which customization will occur
</span>(<span style="color: #da70d6;">println</span> <span style="color: #bc8f8f;">"LOADING forex-user"</span>)
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex-user  
     (<span style="color: #da70d6;">:clone</span> forex.default) 
     (<span style="color: #da70d6;">:use</span> forex.interface.gui forex.util.log clj.io))
(<span style="color: #da70d6;">require</span> <span style="color: #da70d6;">:reload</span> 'forex.examples.timeout-ea.timeout-ea)
<span style="color: #b22222;">;;</span><span style="color: #b22222;">(require :reload-all 'forex.interface.main)
</span>(<span style="color: #a020f0;">when-not</span> (backend/alive?)
  (backend/start))

(<span style="color: #a020f0;">when-not</span> log-file
  (setq forex.util.log/log
        (new-logger (.replaceAll
                     (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"log_%s.txt"</span> (now)) <span style="color: #bc8f8f;">":"</span> <span style="color: #bc8f8f;">"_"</span>))))


<span style="color: #b22222;">;;</span><span style="color: #b22222;">ALL ABOUT AUTOSAVING
</span>(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">ea-auto-save-minutes</span>  5)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">ea-auto-save-file</span>
  (<span style="color: #a020f0;">let</span> [file (<span style="color: #da70d6;">format</span> <span style="color: #bc8f8f;">"%s/.forex/auto/ea-auto-save"</span>
                     (System/getProperty <span style="color: #bc8f8f;">"user.home"</span>))]
    (make-parents file)
    file))  
(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">ea-auto-save-thread</span> (<span style="color: #a020f0;">doto</span> (thread
                                    (<span style="color: #a020f0;">loop</span> []
                                      (sleep (<span style="color: #da70d6;">*</span> 60 ea-auto-save-minutes))
                                      (<span style="color: #a020f0;">when-not</span> (<span style="color: #da70d6;">empty?</span> @*eas*)
                                        (save-eas ea-auto-save-file))
                                      (<span style="color: #a020f0;">recur</span>)))
                               (.setName <span style="color: #bc8f8f;">"ea auto save"</span>)))

(add-to-list #'ea-on-exit-hook #(<span style="color: #a020f0;">when-not</span> (<span style="color: #da70d6;">empty?</span> @*eas*) (save-eas ea-auto-save-file)))
(add-to-list #'ea-on-start-hook #(<span style="color: #a020f0;">when-not</span> (<span style="color: #da70d6;">empty?</span> @*eas*) (save-eas ea-auto-save-file)))

(<span style="color: #a020f0;">defonce</span> <span style="color: #0000ff;">ea-shutdown-hook</span> (Thread. #(save-eas ea-auto-save-file 500)))
(add-shutdown-hook ea-shutdown-hook)
<span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span>


(<span style="color: #da70d6;">comment</span> 
  (setq gui-frame-title <span style="color: #bc8f8f;">"MINE!"</span>
        gui-reminder-visible true))
</pre></div>



</div>

</div>

<div id="outline-container-4_7" class="outline-3">
<h3 id="sec-4_7"><span class="section-number-3">4.7</span> Templates </h3>
<div class="outline-text-3" id="text-4_7">




<div class="org-src-container"><label class="org-src-name">template()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.default
     (<span style="color: #da70d6;">:clone</span> clj.core)
     (<span style="color: #da70d6;">:use</span> forex.util.general)
     (<span style="color: #da70d6;">:use</span> forex.util.core
           forex.util.emacs
           forex.util.log) 
     (<span style="color: #da70d6;">:use</span> forex.module.error
           forex.module.ea
           forex.module.indicator
           forex.module.account forex.module.account.utils
           [clj-time.core <span style="color: #da70d6;">:exclude</span> [extend start]])
     (<span style="color: #da70d6;">:require</span>
      [forex.backend.mql.socket-service <span style="color: #da70d6;">:as</span> backend]))
</pre></div>




<div class="org-src-container"><label class="org-src-name">gui-template()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.gui 
     (<span style="color: #da70d6;">:clone</span> clj.core)
     (<span style="color: #da70d6;">:import</span> (javax.swing JScrollPane JFrame JPanel JTextArea
                           JLabel JButton SwingUtilities))
     (<span style="color: #da70d6;">:use</span> forex.util.general forex.util.gui clojure.contrib.miglayout)
     (<span style="color: #da70d6;">:use</span> forex.util.core
           forex.util.emacs
           forex.util.log)  
     (<span style="color: #da70d6;">:use</span> forex.module.error
           forex.module.ea
           forex.module.indicator
           forex.module.account forex.module.account.utils
           [clj-time.core <span style="color: #da70d6;">:exclude</span> [extend start]])
     (<span style="color: #da70d6;">:require</span>
      [forex.backend.mql.socket-service <span style="color: #da70d6;">:as</span> backend]))
</pre></div>



</div>

</div>

<div id="outline-container-4_8" class="outline-3">
<h3 id="sec-4_8"><span class="section-number-3">4.8</span> Examples </h3>
<div class="outline-text-3" id="text-4_8">

<p>Notice that examples are right now just examples, they arent particularly
profitable, they are examples of using clj-forex. I decided to release
them without thoroughly testing so that one can see an early look of how to
use clj-forex&hellip;.
</p>



<div class="org-src-container"><label class="org-src-name">timeout-ea()</label><pre class="src src-clojure">
<span style="color: #b22222;">;;</span><span style="color: #b22222;">forex.examples.timeout-ea : ea which manages the orders of a trade
</span>(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.examples.timeout-ea.timeout-ea
     (<span style="color: #da70d6;">:clone</span> forex.gui) 
     (<span style="color: #da70d6;">:use</span> forex.examples.timeout-ea.utils
           forex.interface.gui)
     (<span style="color: #da70d6;">:import</span> (javax.swing JScrollPane JTextField)))
(register-ea)
 <span style="color: #b22222;">;;</span><span style="color: #b22222;">ea vars   
</span>(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">state</span> (<span style="color: #da70d6;">atom</span> <span style="color: #da70d6;">:timeout</span>))
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">end-time</span>)
(<span style="color: #a020f0;">defvar</span> <span style="color: #0000ff;">order</span>) 
<span style="color: #b22222;">;; </span><span style="color: #b22222;">
</span>(<span style="color: #da70d6;">declare</span> timeout break-even trail)

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: when we order, and modify fails, how do we get the error? later :)...
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">init</span> [{<span style="color: #da70d6;">:keys</span> [type sl price hour lots]}]
  (aif (order! {<span style="color: #da70d6;">:type</span> type <span style="color: #da70d6;">:sl</span> sl <span style="color: #da70d6;">:price</span> price <span style="color: #da70d6;">:lots</span> lots
                })
       {#'end-time (plus (now) (hours hour))
        #'order (atom-hash it)} 
       (<span style="color: #da70d6;">:e</span> it)))  

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">start</span> [args]
  (<span style="color: #a020f0;">cond</span>
   (close? order) (exit <span style="color: #bc8f8f;">"order is now closed"</span>)
   (<span style="color: #da70d6;">=</span> @state <span style="color: #da70d6;">:timeout</span>) (timeout args)
   (<span style="color: #da70d6;">=</span> @state <span style="color: #da70d6;">:break-even</span>) (break-even args)
   (<span style="color: #da70d6;">=</span> @state <span style="color: #da70d6;">:trail</span>) (trail))) 

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">timeout</span> [_]
  (<span style="color: #a020f0;">cond</span>
   <span style="color: #b22222;">;;</span><span style="color: #b22222;">changed to market
</span>   (market? order)
   (<span style="color: #a020f0;">do</span> (<span style="color: #da70d6;">reset!</span> state <span style="color: #da70d6;">:break-even</span>) (out <span style="color: #bc8f8f;">"order opened - monitoring tp1"</span>))
   <span style="color: #b22222;">;;</span><span style="color: #b22222;">entry order reach sl 
</span>   (<span style="color: #a020f0;">if</span> (sell? order) (<span style="color: #da70d6;">&gt;</span> (close) (<span style="color: #da70d6;">:sl</span> order)) (<span style="color: #da70d6;">&lt;</span> (close) (<span style="color: #da70d6;">:sl</span> order)))
   <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: reliable delete????
</span>   (awhen (delete! order) (exit <span style="color: #bc8f8f;">"entry order reached sl. deleting ..."</span>))
   <span style="color: #b22222;">;;</span><span style="color: #b22222;">timed out
</span>   (after? (now) end-time)
   (awhen (delete! order) (exit <span style="color: #bc8f8f;">"order timed out"</span>))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: better sl saving 
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">break-even</span> [{<span style="color: #da70d6;">:keys</span> [sl tp2 tp1]}]
  (<span style="color: #a020f0;">if</span> (hit? order tp1)
    (<span style="color: #a020f0;">do</span> (out <span style="color: #bc8f8f;">"closing to half ..."</span>) 
        (awhen (<span style="color: #a020f0;">-&gt;</span> (modify! order {<span style="color: #da70d6;">:sl</span> (<span style="color: #da70d6;">:break</span> order)})
                   (close! (lot (<span style="color: #da70d6;">/</span> (<span style="color: #da70d6;">:lots</span> order) 2))))               
               (out <span style="color: #bc8f8f;">"trailing order"</span>) (<span style="color: #da70d6;">reset!</span> state <span style="color: #da70d6;">:trail</span>)))
    (modify! order {<span style="color: #da70d6;">:sl</span> sl})))  

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">hh</span> [a]
  (<span style="color: #da70d6;">apply</span> max (<span style="color: #da70d6;">map</span> high (<span style="color: #da70d6;">range</span> 1 (<span style="color: #da70d6;">inc</span> a)))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">ll</span> [a]
  (<span style="color: #da70d6;">apply</span> min (<span style="color: #da70d6;">map</span> low (<span style="color: #da70d6;">range</span> 1 (<span style="color: #da70d6;">inc</span> a)))))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">trail</span> []
  (modify! order {<span style="color: #da70d6;">:sl</span> (omax order (<span style="color: #da70d6;">:sl</span> order)  (<span style="color: #a020f0;">if</span> (sell? order) (hh 3) (ll 3)))})) 
<span style="color: #b22222;">;;;</span><span style="color: #b22222;">GUI
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">init-gui</span> [] 
  (<span style="color: #a020f0;">let</span> [panel (JPanel.)
        text (JTextArea. 20 30)
        risk (JTextField. <span style="color: #bc8f8f;">"1"</span> 7)
        frame (jframe <span style="color: #bc8f8f;">"timeout ea"</span>)]
    (<span style="color: #a020f0;">doto</span> frame
      (.add (miglayout
             panel <span style="color: #da70d6;">:layout</span> <span style="color: #bc8f8f;">"center"</span> <span style="color: #da70d6;">:column</span> <span style="color: #bc8f8f;">"center"</span> <span style="color: #da70d6;">:row</span> <span style="color: #bc8f8f;">"center"</span>
             (JLabel. <span style="color: #bc8f8f;">"paste email text"</span>) <span style="color: #da70d6;">:wrap</span>
             (JScrollPane. text) <span style="color: #bc8f8f;">"span,grow"</span> <span style="color: #da70d6;">:wrap</span>
             risk (JLabel. <span style="color: #bc8f8f;">"% risk"</span>) <span style="color: #da70d6;">:wrap</span>
             (<span style="color: #a020f0;">doto</span> (JButton. <span style="color: #bc8f8f;">"ok"</span>)
               (add-action-listener
                (<span style="color: #da70d6;">fn</span> [e]
                  (<span style="color: #a020f0;">try</span>
                    (<span style="color: #a020f0;">let</span> [risk (Double/parseDouble (.getText risk))
                          parsed (match-method risk (.getText text))]
                      (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> 0 (<span style="color: #da70d6;">:lots</span> parsed))
                        (inform <span style="color: #bc8f8f;">"not enough $ to trade order %s"</span> parsed)
                        (<span style="color: #a020f0;">if</span> parsed
                          (<span style="color: #a020f0;">when</span> (prompt <span style="color: #bc8f8f;">"is order %s ok?"</span> parsed)
                            (with-out-str+ out
                              (<span style="color: #a020f0;">if-not</span> (run parsed) 
                                (inform <span style="color: #bc8f8f;">"failed to run ea %s"</span> (<span style="color: #da70d6;">str</span> out))
                                (.setVisible frame false)))) 
                          (inform <span style="color: #bc8f8f;">"failed to match input text"</span>))))
                    (<span style="color: #a020f0;">catch</span> Exception e (inform <span style="color: #bc8f8f;">"invalid risk %s"</span> (.getText risk)))))))
             <span style="color: #bc8f8f;">"w 50%"</span>
             (<span style="color: #a020f0;">doto</span> (JButton. <span style="color: #bc8f8f;">"cancel"</span>)
               (add-action-listener (<span style="color: #da70d6;">fn</span> [_] (.setVisible frame false))))
             <span style="color: #bc8f8f;">"w 50%"</span>))
      (.pack)
      (.setVisible true))))
</pre></div>






<div class="org-src-container"><label class="org-src-name">timeout-ea-utils()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.examples.timeout-ea.utils
     (<span style="color: #da70d6;">:clone</span> forex.default)
     (<span style="color: #da70d6;">:use</span> forex.util.general)) 

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">price</span>
  ([val] (price val (env <span style="color: #da70d6;">:symbol</span>)))
  ([val symbol] 
     (<span style="color: #da70d6;">*</span> (mode-tickvalue symbol) (point val)))) 
<span style="color: #b22222;">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><span style="color: #b22222;">
</span>(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">method-regex</span>
  (<span style="color: #da70d6;">re-pattern</span> (.replaceAll
               (<span style="color: #da70d6;">str</span> <span style="color: #bc8f8f;">"(?i)\\s*(Propulsion|Pip Reactor|Impulse|Spring)\\s+Method"</span>
                    <span style="color: #bc8f8f;">".+running on (\\w+/\\w+)"</span>
                    <span style="color: #bc8f8f;">".+generated a (Buy|Sell) Signal @ (\\d{0,15}\\.\\d{0,15})"</span>
                    <span style="color: #bc8f8f;">".+Stop @ (\\d{0,15}\\.\\d{0,15})"</span>
                    <span style="color: #bc8f8f;">".+(?:1st|First) Limit @ (\\d{0,15}\\.\\d{0,15})"</span>
                    <span style="color: #bc8f8f;">".+(?:2nd|Second) Limit @ (\\d{0,15}\\.\\d{0,15})"</span>) 
               <span style="color: #bc8f8f;">"\\s+"</span> <span style="color: #bc8f8f;">"\\\\s+"</span>)))

(<span style="color: #a020f0;">defmacro</span> <span style="color: #0000ff;">catch-un</span> [&amp; body]
  `(<span style="color: #a020f0;">try</span> (<span style="color: #a020f0;">do</span> ~@body) (<span style="color: #a020f0;">catch</span> Exception e#
                      (.printStackTrace e#) (warn <span style="color: #bc8f8f;">"caught unexpected error: %s"</span> e#))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">match-method</span> [risk-percent s]
  (<span style="color: #a020f0;">when</span> s 
    (debugging <span style="color: #bc8f8f;">"Matching Profit Multiplier Trade: "</span>
               (catch-un 
                (<span style="color: #a020f0;">when-let</span> [it (<span style="color: #da70d6;">first</span> (<span style="color: #da70d6;">re-seq</span> method-regex (.replaceAll s <span style="color: #bc8f8f;">"[\\r\\n]+"</span> <span style="color: #bc8f8f;">" "</span>)))]
                  (<span style="color: #a020f0;">let</span> [[method-type symbol type price stop tp1 tp2] (<span style="color: #da70d6;">rest</span> it)
                        method (.toLowerCase method-type)
                        symbol (.replaceAll symbol <span style="color: #bc8f8f;">"/"</span> <span style="color: #bc8f8f;">""</span>)]
                    {<span style="color: #da70d6;">:method</span> method
                     <span style="color: #da70d6;">:hour</span> (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> method <span style="color: #bc8f8f;">"pip reactor"</span>) 4 12) 
                     <span style="color: #da70d6;">:symbol</span> symbol
                     <span style="color: #da70d6;">:type</span> (<span style="color: #a020f0;">condp</span> = (.toLowerCase type)
                               <span style="color: #bc8f8f;">"buy"</span> <span style="color: #da70d6;">:buy-stop</span>
                               <span style="color: #bc8f8f;">"sell"</span> <span style="color: #da70d6;">:sell-stop</span>)
                     <span style="color: #da70d6;">:price</span> (Double/parseDouble price)
                     <span style="color: #da70d6;">:sl</span> (Double/parseDouble stop)
                     <span style="color: #da70d6;">:lots</span> (risk risk-percent
                                 (Double/parseDouble stop)
                                 (Double/parseDouble price)
                                 symbol)
                     <span style="color: #da70d6;">:tp1</span> (Double/parseDouble tp1)
                     <span style="color: #da70d6;">:tp2</span> (Double/parseDouble tp2)}))))))
</pre></div>






<div class="org-src-container"><label class="org-src-name">renko()</label><pre class="src src-clojure">
(clojure.core/<span style="color: #da70d6;">use</span> 'nstools.ns)
(ns+ forex.examples.renko.renko
     (<span style="color: #da70d6;">:clone</span> forex.default) 
     (<span style="color: #da70d6;">:use</span> forex.util.general)) 
(register-ea) 
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: *ea-stop* already refers to: #'forex.module.ea/*ea-stop* in namespace: forex.default 
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: on GBP/JPY, why did it enter so late???? 
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO!!!: speed up ns+ by alot! and dont have it automatically reload it, please!!!
</span>
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: test reusing of account.utils
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: defaults per currency
</span>(<span style="color: #a020f0;">def</span> ^{<span style="color: #da70d6;">:var</span> true} <span style="color: #0000ff;">state</span> (<span style="color: #da70d6;">atom</span> <span style="color: #da70d6;">:monitor</span>)) 
(<span style="color: #a020f0;">def</span> ^{<span style="color: #da70d6;">:var</span> true} <span style="color: #0000ff;">order</span> (atom-hash))
(<span style="color: #a020f0;">def</span> ^{<span style="color: #da70d6;">:var</span> true} <span style="color: #0000ff;">trail-time-period</span> 5)

(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">main</span> (<span style="color: #da70d6;">partial</span> vma [2 2 100 1]))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">signal</span> (<span style="color: #da70d6;">partial</span> vma [2 2 1 1] ))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">middle</span> (<span style="color: #da70d6;">partial</span> vma [2 2 26 1]))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">support</span> (blazan-dynamic-stop [150 70 1 10000] 1))
(<span style="color: #a020f0;">def</span> <span style="color: #0000ff;">resistance</span> (blazan-dynamic-stop [150 70 1 10000] 0))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">UTILS
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">up?</span> [signal i]
  (<span style="color: #a020f0;">let</span> [diff (<span style="color: #da70d6;">-</span> (signal i) (signal (<span style="color: #da70d6;">+</span> i 1)))]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">&gt;=</span> diff 0) 
      diff
      false))) 
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">down?</span> [signal i]
  (<span style="color: #a020f0;">let</span> [diff (<span style="color: #da70d6;">-</span> (signal i) (signal (<span style="color: #da70d6;">+</span> i 1)))]
    (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">&lt;=</span> diff 0)
      diff
      false)))    
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">reset</span> []
  (<span style="color: #da70d6;">reset!</span> state <span style="color: #da70d6;">:monitor</span>) (<span style="color: #da70d6;">reset!</span> order nil) (out <span style="color: #bc8f8f;">"order closed"</span>))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">calculate-lots</span> [] (lot (<span style="color: #da70d6;">*</span> 0.01 (<span style="color: #da70d6;">/</span> (account-balance) 100))))
<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: use symbol in o for profit! 
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">profit</span>
  ([o] (wenv {<span style="color: #da70d6;">:symbol</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">:symbol</span> o) (env <span style="color: #da70d6;">:symbol</span>))} (profit o (close) (<span style="color: #da70d6;">:break</span> o))))
  ([o a] (profit o a (<span style="color: #da70d6;">:break</span> o)))
  ([o a b] (point (o-- o a b))))

<span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: exit half when cross middle? enter half more when recross? 
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">OPEN CONDITION 
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">open-condition</span> [i]  
  (<span style="color: #a020f0;">if-let</span> [[dir i] (cross? signal main i)]
    (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">=</span> dir <span style="color: #da70d6;">:buy</span>) (<span style="color: #da70d6;">&gt;</span> (signal i) (middle i)) {<span style="color: #da70d6;">:type</span> <span style="color: #da70d6;">:buy</span> <span style="color: #da70d6;">:i</span> i <span style="color: #da70d6;">:category</span>  <span style="color: #da70d6;">:long</span> <span style="color: #da70d6;">:state</span> <span style="color: #da70d6;">:init</span>})
        (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">=</span> dir <span style="color: #da70d6;">:sell</span>) (<span style="color: #da70d6;">&lt;</span> (signal i) (middle  i)) {<span style="color: #da70d6;">:type</span> <span style="color: #da70d6;">:sell</span> <span style="color: #da70d6;">:i</span> i <span style="color: #da70d6;">:category</span> <span style="color: #da70d6;">:long</span> <span style="color: #da70d6;">:state</span> <span style="color: #da70d6;">:init</span>}))
    (<span style="color: #a020f0;">when-let</span> [[dir i] (cross? signal middle i)]
      (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">=</span> dir <span style="color: #da70d6;">:buy</span>) <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: better reentry , oui? slope? 
</span>               (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&lt;</span> (middle i) (<span style="color: #228b22;">main</span> i)) (<span style="color: #da70d6;">&gt;</span> (middle (<span style="color: #da70d6;">+</span> i 10)) (<span style="color: #228b22;">main</span> (<span style="color: #da70d6;">+</span> i 10)))
                        {<span style="color: #da70d6;">:type</span> <span style="color: #da70d6;">:buy</span> <span style="color: #da70d6;">:i</span> i <span style="color: #da70d6;">:category</span> <span style="color: #da70d6;">:long</span> <span style="color: #da70d6;">:state</span> <span style="color: #da70d6;">:init</span>}) <span style="color: #b22222;">;;</span><span style="color: #b22222;">the dip
</span>                   (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&lt;=</span> (Math/abs (<span style="color: #da70d6;">-</span> (<span style="color: #228b22;">main</span> i) (middle i))) (pip 20)) (<span style="color: #a020f0;">or</span> (up? main i) (up? main (<span style="color: #da70d6;">+</span> i 1)))
                        (<span style="color: #da70d6;">&gt;</span> (middle i) (<span style="color: #228b22;">main</span> i)) 
                        <span style="color: #b22222;">;;</span><span style="color: #b22222;">{:type :buy :i i :category :scalp}
</span>                        nil
                        ))) <span style="color: #b22222;">;;</span><span style="color: #b22222;">thin 
</span>          (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">=</span> dir <span style="color: #da70d6;">:sell</span>)
               (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&gt;</span> (middle i) (<span style="color: #228b22;">main</span> i)) (<span style="color: #da70d6;">&lt;</span> (middle (<span style="color: #da70d6;">+</span> i 10)) (<span style="color: #228b22;">main</span> (<span style="color: #da70d6;">+</span> i 10)))
                        {<span style="color: #da70d6;">:type</span> <span style="color: #da70d6;">:sell</span> <span style="color: #da70d6;">:i</span> i <span style="color: #da70d6;">:category</span> <span style="color: #da70d6;">:long</span> <span style="color: #da70d6;">:state</span> <span style="color: #da70d6;">:init</span>}) <span style="color: #b22222;">;;</span><span style="color: #b22222;">the dip
</span>                   (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&lt;=</span> (Math/abs (<span style="color: #da70d6;">-</span> (<span style="color: #228b22;">main</span> i) (middle i))) (pip 20)) (<span style="color: #a020f0;">or</span> (down? main i) (down? main (<span style="color: #da70d6;">+</span> i 1)))
                        (<span style="color: #da70d6;">&lt;</span> (middle i) (<span style="color: #228b22;">main</span> i))
                        <span style="color: #b22222;">;;</span><span style="color: #b22222;">{:type :sell :i i :category :scalp}
</span>                        nil
                        )))))))   

<span style="color: #b22222;">;;</span><span style="color: #b22222;">ORDER MANAGEMENT
</span>(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">close-condition</span> (<span style="color: #da70d6;">fn</span> [o &amp; args] (<span style="color: #da70d6;">:category</span> o)))
(<span style="color: #a020f0;">defmulti</span> <span style="color: #0000ff;">check</span> (<span style="color: #da70d6;">fn</span> [o &amp; args] (<span style="color: #da70d6;">:category</span> o)))
<span style="color: #b22222;">;;;</span><span style="color: #b22222;">SCALP ORDER MANAGEMENT
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">should-close?</span> [{<span style="color: #da70d6;">:keys</span> [type] <span style="color: #da70d6;">:as</span> o}] 
  (<span style="color: #a020f0;">cond</span>
   (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy</span>)
   (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">&lt;</span> (signal 1) (<span style="color: #228b22;">main</span> 1)) (<span style="color: #da70d6;">&lt;</span> (signal 1) (middle 1)))
   (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell</span>)
   (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">&gt;</span> (signal 1) (<span style="color: #228b22;">main</span> 1)) (<span style="color: #da70d6;">&gt;</span> (signal 1) (middle 1)))))

<span style="color: #b22222;">;;;</span><span style="color: #b22222;">LONG ORDER MANAGEMENT
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: take profit via price action !!!!; if GBPJPY is owning, why not trail on 1 minute level? basically, alot of this take profit stuff and entering
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">and exiting is based on a variety of conditions! Im sensing some AI like programming taking place! doesn't need to be ai, but how about using
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">programming which takes into account the context? see http://web.media.mit.edu/~push/ and the phd thesis EM-ONE: An Architecture for Reflective Commonsense Thinking
</span>
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">cci-close?</span>
  <span style="color: #bc8f8f;">"This is a tight virtual stop on the five minute level. 
   For buy, if cci&gt;100, set cross-sl to previous middle value.
   If signal(1) is less than cross-sl, then exit. Opposite for sell"</span>
  [{<span style="color: #da70d6;">:keys</span> [type state] <span style="color: #da70d6;">:as</span> o} period] 
  (<span style="color: #a020f0;">when</span> (<span style="color: #da70d6;">=</span> state <span style="color: #da70d6;">:trail</span>) 
    (wenv {<span style="color: #da70d6;">:period</span> period}    
          <span style="color: #b22222;">;;</span><span style="color: #b22222;">modify cross-sl 
</span>          (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">&gt;</span> (cci 30 1) 100) (<span style="color: #da70d6;">&lt;</span> (cci 30 1) -100))
            <span style="color: #b22222;">;;</span><span style="color: #b22222;">we will not update the cross-sl so that it will generate  a close signal, this would be bad!
</span>            (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (buy? o) (<span style="color: #da70d6;">&gt;</span> (signal 1) (middle 1)))
                      (<span style="color: #a020f0;">and</span> (sell? o) (<span style="color: #da70d6;">&lt;</span> (signal 1) (middle 1))))
              (modify! o {<span style="color: #da70d6;">:cross-sl</span> (middle 1)})))  
          <span style="color: #b22222;">;;</span><span style="color: #b22222;">check close condition
</span>          (<span style="color: #a020f0;">when-let</span> [cross-sl (<span style="color: #da70d6;">:cross-sl</span> o)]
            (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (buy? o) (<span style="color: #da70d6;">&lt;=</span> (signal 1) cross-sl)) 
                (<span style="color: #a020f0;">and</span> (sell? o) (<span style="color: #da70d6;">&gt;=</span> (signal 1) cross-sl))))))) 

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">close-condition</span> <span style="color: #da70d6;">:long</span> [{<span style="color: #da70d6;">:keys</span> [type state] <span style="color: #da70d6;">:as</span> o}] 
  (<span style="color: #a020f0;">if</span> (<span style="color: #da70d6;">=</span> state <span style="color: #da70d6;">:init</span>)
    (<span style="color: #a020f0;">and</span> (should-close? o)
         (<span style="color: #a020f0;">do</span> (out <span style="color: #bc8f8f;">"init close"</span>) true)) <span style="color: #b22222;">;;</span><span style="color: #b22222;">TODO: GBPUSD screwed up for -30 pips how to effectively close this? how bout pick better entry poitns? or dont pick exhaustion
</span>    (<span style="color: #a020f0;">or</span> (<span style="color: #a020f0;">and</span> (<span style="color: #a020f0;">cond</span>
              (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:buy</span>)
              (<span style="color: #da70d6;">&lt;</span> (signal 1) (<span style="color: #228b22;">main</span> 1))
              (<span style="color: #da70d6;">=</span> type <span style="color: #da70d6;">:sell</span>)
              (<span style="color: #da70d6;">&gt;</span> (signal 1) (<span style="color: #228b22;">main</span> 1)))
             (<span style="color: #a020f0;">do</span> (out <span style="color: #bc8f8f;">"cross close"</span>) true))
        (<span style="color: #a020f0;">and</span> (cci-close? o trail-time-period) (<span style="color: #a020f0;">do</span> (out <span style="color: #bc8f8f;">"cci close"</span>) true))))) 

(<span style="color: #a020f0;">defmethod</span> <span style="color: #0000ff;">check</span> <span style="color: #da70d6;">:long</span> [o]
  (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">and</span> (<span style="color: #da70d6;">&gt;=</span> (profit o) 20) (<span style="color: #da70d6;">not</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:state</span> o) <span style="color: #da70d6;">:trail</span>))) (modify! o {<span style="color: #da70d6;">:state</span> <span style="color: #da70d6;">:trail</span>}) (out <span style="color: #bc8f8f;">"changed to trail"</span>))
  <span style="color: #b22222;">;;</span><span style="color: #b22222;">actual sl the server sees. this is a safety stop, in case our ea gets screwed up, turns off, etc.
</span>  (<span style="color: #a020f0;">when</span> (<span style="color: #a020f0;">or</span> (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:sl</span> o) 0) (<span style="color: #da70d6;">=</span> (<span style="color: #da70d6;">:state</span> o) <span style="color: #da70d6;">:trail</span>))
    (modify! o {<span style="color: #da70d6;">:sl</span> (omax o (<span style="color: #da70d6;">:sl</span> o) (o- o (<span style="color: #228b22;">main</span> 1) (pip 20)))})))  
<span style="color: #b22222;">;;</span><span style="color: #b22222;">(run)
</span><span style="color: #b22222;">;;</span><span style="color: #b22222;">MAIN  
</span>(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">gobble</span> [o] 
  (<span style="color: #a020f0;">if</span> (close? o) 
    (reset)
    (awhen-not (<span style="color: #a020f0;">and</span> (close-condition o) (close! o))
               (check o))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">monitor</span> []  
  (<span style="color: #a020f0;">when-let</span> [{<span style="color: #da70d6;">:keys</span> [type category] <span style="color: #da70d6;">:as</span> o} (open-condition 0)] 
    (awhen (order! (<span style="color: #da70d6;">merge</span> o  {<span style="color: #da70d6;">:type</span> type <span style="color: #da70d6;">:lots</span> (calculate-lots)})) 
           (<span style="color: #da70d6;">reset!</span> order it)
           (<span style="color: #da70d6;">reset!</span> state <span style="color: #da70d6;">:gobble</span>)   
           (out <span style="color: #bc8f8f;">"entered %s %s order"</span> type category))))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">start</span> [args] 
  (<span style="color: #a020f0;">cond</span>
   (<span style="color: #da70d6;">=</span> @state <span style="color: #da70d6;">:monitor</span>) (monitor)
   (<span style="color: #da70d6;">=</span> @state <span style="color: #da70d6;">:gobble</span>) (gobble order)))

(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">vars</span> [ea] (<span style="color: #da70d6;">:vars</span> ea))
(<span style="color: #a020f0;">defn</span> <span style="color: #0000ff;">getv</span> [vvar ea] (<span style="color: #da70d6;">get</span> (<span style="color: #da70d6;">:vars</span> ea) vvar))
</pre></div>



</div>
</div>
</div>
<div id="postamble">
<p class="author"> Author: Seth Burleigh
</p>
<p class="date"> Date: 2011-02-20 12:28:25 CST</p>
<p class="creator">HTML generated by org-mode 7.4 in emacs 23</p>
</div>
</div>
</body>
</html>
